"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const w=require("fetch-ponyfill"),D=require("form-data"),d=require("xstate");let _=globalThis.fetch;const y=async(t,e,{accessToken:r,name:s,fileId:a,bucketId:o,adminSecret:n,onUploadProgress:l,headers:u={}}={})=>{var T;const p={...u};o&&e.append("bucket-id",o),n&&(p["x-hasura-admin-secret"]=n),r&&(p.Authorization=`Bearer ${r}`);const U=`${t}/files`;if(typeof XMLHttpRequest=="undefined")try{e instanceof D&&(_=w().fetch);const c=await _(U,{method:"POST",headers:p,body:e}),i=await c.json();return c.ok?{fileMetadata:i,error:null}:{error:{status:c.status,message:((T=i==null?void 0:i.error)==null?void 0:T.message)||c.statusText,error:c.statusText},fileMetadata:null}}catch(c){return{error:{status:0,message:c.message,error:c.message},fileMetadata:null}}return new Promise(c=>{let i=new XMLHttpRequest;i.responseType="json",i.onload=()=>{var f,g,L,S,F;return i.status<200||i.status>=300?c({fileMetadata:null,error:{error:(g=(f=i.response)==null?void 0:f.error)!=null?g:i.response,message:(F=(S=(L=i.response)==null?void 0:L.error)==null?void 0:S.message)!=null?F:i.response,status:i.status}}):c({fileMetadata:i.response,error:null})},i.onerror=()=>c({fileMetadata:null,error:{error:i.statusText,message:i.statusText,status:i.status}}),l&&i.upload.addEventListener("progress",l,!1),i.open("POST",U,!0),Object.entries(p).forEach(([f,g])=>{i.setRequestHeader(f,g)}),i.send(e)})};let m;typeof m=="undefined"&&(m=w().fetch);class I{constructor({url:e}){this.url=e}async uploadFormData({formData:e,headers:r,bucketId:s}){const{error:a,fileMetadata:o}=await y(this.url,e,{accessToken:this.accessToken,adminSecret:this.adminSecret,bucketId:s,headers:r});return a?{fileMetadata:null,error:a}:o&&!("processedFiles"in o)?{fileMetadata:{processedFiles:[o]},error:null}:{fileMetadata:o,error:null}}async uploadFile({file:e,bucketId:r,id:s,name:a}){const o=typeof window=="undefined"?new D:new FormData;o.append("file[]",e),o.append("metadata[]",JSON.stringify({id:s,name:a}));const{error:n,fileMetadata:l}=await y(this.url,o,{accessToken:this.accessToken,adminSecret:this.adminSecret,bucketId:r,fileId:s,name:a});return n?{fileMetadata:null,error:n}:l&&"processedFiles"in l?{fileMetadata:l.processedFiles[0],error:null}:{fileMetadata:l,error:null}}async getPresignedUrl(e){try{const{fileId:r}=e,s=await m(`${this.url}/files/${r}/presignedurl`,{method:"GET",headers:this.generateAuthHeaders()});if(!s.ok)throw new Error(await s.text());return{presignedUrl:await s.json(),error:null}}catch(r){return{presignedUrl:null,error:r}}}async delete(e){try{const{fileId:r}=e,s=await m(`${this.url}/files/${r}`,{method:"DELETE",headers:this.generateAuthHeaders()});if(!s.ok)throw new Error(await s.text());return{error:null}}catch(r){return{error:r}}}setAccessToken(e){return this.accessToken=e,this}setAdminSecret(e){return this.adminSecret=e,this}generateAuthHeaders(){if(!(!this.adminSecret&&!this.accessToken))return this.adminSecret?{"x-hasura-admin-secret":this.adminSecret}:{Authorization:`Bearer ${this.accessToken}`}}}function E(t,e){if(!e||Object.keys(e).length===0)return t;const r=new URL(t),s=Object.entries(e).reduce((a,[o,n])=>({...a,[o.charAt(0)]:n}),{});return Object.entries(s).forEach(([a,o])=>{o&&r.searchParams.set(a,o)}),r.toString()}class M{constructor({url:e,adminSecret:r}){this.url=e,this.api=new I({url:e}),this.setAdminSecret(r)}async upload(e){return"file"in e?this.api.uploadFile(e):this.api.uploadFormData(e)}getPublicUrl(e){const{fileId:r,...s}=e;return E(`${this.url}/files/${r}`,s)}async getPresignedUrl(e){const{fileId:r,...s}=e,{presignedUrl:a,error:o}=await this.api.getPresignedUrl(e);if(o)return{presignedUrl:null,error:o};if(!a)return{presignedUrl:null,error:new Error("Invalid file id")};const n=E(a.url,s);return{presignedUrl:{...a,url:n},error:null}}async delete(e){const{error:r}=await this.api.delete(e);return r?{error:r}:{error:null}}setAccessToken(e){return this.api.setAccessToken(e),this}setAdminSecret(e){return this.api.setAdminSecret(e),this}}let O;typeof O=="undefined"&&(O=D);const A={progress:null,loaded:0,error:null,bucketId:void 0,file:void 0,id:void 0},R=()=>d.createMachine({predictableActionArguments:!0,schema:{context:{},events:{}},tsTypes:{},context:{...A},initial:"idle",on:{DESTROY:{actions:"sendDestroy",target:"stopped"}},states:{idle:{on:{ADD:{actions:"addFile"},UPLOAD:{cond:"hasFile",target:"uploading"}}},uploading:{entry:"resetProgress",on:{UPLOAD_PROGRESS:{actions:["incrementProgress","sendProgress"]},UPLOAD_DONE:"uploaded",UPLOAD_ERROR:"error",CANCEL:"idle"},invoke:{src:"uploadFile"}},uploaded:{entry:["setFileMetadata","sendDone"],on:{ADD:{actions:"addFile",target:"idle"},UPLOAD:{actions:"resetContext",target:"uploading"}}},error:{entry:["setError","sendError"],on:{ADD:{actions:"addFile",target:"idle"},UPLOAD:{actions:"resetContext",target:"uploading"}}},stopped:{type:"final"}}},{guards:{hasFile:(t,e)=>!!t.file||!!e.file},actions:{incrementProgress:d.assign({loaded:(t,{loaded:e})=>e,progress:(t,{progress:e})=>e}),setFileMetadata:d.assign({id:(t,{id:e})=>e,bucketId:(t,{bucketId:e})=>e,progress:t=>100}),setError:d.assign({error:(t,{error:e})=>e}),sendProgress:()=>{},sendError:()=>{},sendDestroy:()=>{},sendDone:()=>{},resetProgress:d.assign({progress:t=>null,loaded:t=>0}),resetContext:d.assign(t=>A),addFile:d.assign({file:(t,{file:e})=>e,bucketId:(t,{bucketId:e})=>e,id:(t,{id:e})=>e})},services:{uploadFile:(t,e)=>r=>{const s=e.file||t.file,a=new O;a.append("file[]",s);let o=0;return y(e.url,a,{fileId:e.id||t.id,bucketId:e.bucketId||t.bucketId,accessToken:e.accessToken,adminSecret:e.adminSecret,name:e.name||s.name,onUploadProgress:n=>{const l=n.total?Math.round(n.loaded*s.size/n.total):0,u=l-o;o=l,r({type:"UPLOAD_PROGRESS",progress:n.total?Math.round(l*100/n.total):0,loaded:l,additions:u})}}).then(({fileMetadata:n,error:l})=>{if(l&&r({type:"UPLOAD_ERROR",error:l}),n&&!("processedFiles"in n)){const{id:u,bucketId:p}=n;r({type:"UPLOAD_DONE",id:u,bucketId:p})}if(n&&"processedFiles"in n){const{id:u,bucketId:p}=n.processedFiles[0];r({type:"UPLOAD_DONE",id:u,bucketId:p})}}),()=>{}}}}),{pure:P,sendParent:h}=d.actions,k=()=>d.createMachine({id:"files-list",schema:{context:{},events:{}},tsTypes:{},predictableActionArguments:!0,context:{progress:null,files:[],loaded:0,total:0},initial:"idle",on:{UPLOAD:{cond:"hasFileToDownload",actions:"addItem",target:"uploading"},ADD:{actions:"addItem"},REMOVE:{actions:"removeItem"}},states:{idle:{entry:["resetProgress","resetLoaded","resetTotal"],on:{CLEAR:{actions:"clearList",target:"idle"}}},uploading:{entry:["upload","startProgress","resetLoaded","resetTotal"],on:{UPLOAD_PROGRESS:{actions:["incrementProgress"]},UPLOAD_DONE:[{cond:"isAllUploaded",target:"uploaded"},{cond:"isAllUploadedOrError",target:"error"}],UPLOAD_ERROR:[{cond:"isAllUploaded",target:"uploaded"},{cond:"isAllUploadedOrError",target:"error"}],CANCEL:{actions:"cancel",target:"idle"}}},uploaded:{entry:"setUploaded",on:{CLEAR:{actions:"clearList",target:"idle"}}},error:{on:{CLEAR:{actions:"clearList",target:"idle"}}}}},{guards:{hasFileToDownload:(t,e)=>t.files.some(r=>r.getSnapshot().matches("idle"))||!!e.files,isAllUploaded:t=>t.files.every(e=>{var r;return(r=e.getSnapshot())==null?void 0:r.matches("uploaded")}),isAllUploadedOrError:t=>t.files.every(e=>{const r=e.getSnapshot();return(r==null?void 0:r.matches("error"))||(r==null?void 0:r.matches("uploaded"))})},actions:{incrementProgress:d.assign((t,e)=>{const r=t.loaded+e.additions,s=Math.round(r*100/t.total);return{...t,loaded:r,progress:s}}),setUploaded:d.assign({progress:t=>100,loaded:({files:t})=>t.map(e=>e.getSnapshot()).filter(e=>e.matches("uploaded")).reduce((e,r)=>{var s;return e+((s=r.context.file)==null?void 0:s.size)},0)}),resetTotal:d.assign({total:({files:t})=>t.map(e=>e.getSnapshot()).filter(e=>!e.matches("uploaded")).reduce((e,r)=>{var s;return e+((s=r.context.file)==null?void 0:s.size)},0)}),resetLoaded:d.assign({loaded:t=>0}),startProgress:d.assign({progress:t=>0}),resetProgress:d.assign({progress:t=>null}),addItem:d.assign((t,{files:e,bucketId:r})=>{const s=e?Array.isArray(e)?e:"item"in e?Array.from(e):[e]:[],a=t.total+s.reduce((n,l)=>n+l.size,0),o=Math.round(t.loaded*100/a);return{files:[...t.files,...s.map(n=>d.spawn(R().withConfig({actions:{sendProgress:h((l,{additions:u})=>({type:"UPLOAD_PROGRESS",additions:u})),sendDone:h("UPLOAD_DONE"),sendError:h("UPLOAD_ERROR"),sendDestroy:h("REMOVE")}}).withContext({...A,file:n,bucketId:r}),{sync:!0}))],total:a,loaded:t.loaded,progress:o}}),removeItem:d.assign({files:t=>t.files.filter(e=>{var s,a;const r=(s=e.getSnapshot())==null?void 0:s.matches("stopped");return r&&((a=e.stop)==null||a.call(e)),!r})}),clearList:P(t=>t.files.map(e=>d.send({type:"DESTROY"},{to:e.id}))),upload:P((t,e)=>t.files.map(r=>d.send(e,{to:r.id}))),cancel:P(t=>t.files.map(e=>d.send({type:"CANCEL"},{to:e.id})))}}),b=async(t,e)=>new Promise(r=>{e.send({type:"UPLOAD",...t}),e.subscribe(s=>{var a;s.matches("error")?r({error:s.context.error,isError:!0,isUploaded:!1}):s.matches("uploaded")&&r({error:null,isError:!1,isUploaded:!0,id:s.context.id,bucketId:s.context.id,name:(a=s.context.file)==null?void 0:a.name})})}),x=async(t,e)=>new Promise(r=>{e.send({type:"UPLOAD",...t,files:t.files}),e.onTransition(s=>{s.matches("error")?r({errors:s.context.files.filter(a=>{var o;return(o=a.getSnapshot())==null?void 0:o.context.error}),isError:!0,files:[]}):s.matches("uploaded")&&r({errors:[],isError:!1,files:s.context.files})})});exports.HasuraStorageApi=I;exports.HasuraStorageClient=M;exports.INITIAL_FILE_CONTEXT=A;exports.appendImageTransformationParameters=E;exports.createFileUploadMachine=R;exports.createMultipleFilesUploadMachine=k;exports.uploadFilePromise=b;exports.uploadMultipleFilesPromise=x;
//# sourceMappingURL=index.cjs.js.map
