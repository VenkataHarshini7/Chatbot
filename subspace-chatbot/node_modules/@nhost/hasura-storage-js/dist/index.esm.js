import R from "fetch-ponyfill";
import O from "form-data";
import { createMachine as I, assign as l, spawn as M, send as A, actions as k } from "xstate";
let _ = globalThis.fetch;
const y = async (t, e, {
  accessToken: r,
  name: s,
  fileId: o,
  bucketId: a,
  adminSecret: n,
  onUploadProgress: d,
  headers: u = {}
} = {}) => {
  var L;
  const p = {
    ...u
  };
  a && e.append("bucket-id", a), n && (p["x-hasura-admin-secret"] = n), r && (p.Authorization = `Bearer ${r}`);
  const U = `${t}/files`;
  if (typeof XMLHttpRequest == "undefined")
    try {
      e instanceof O && (_ = R().fetch);
      const c = await _(U, {
        method: "POST",
        headers: p,
        body: e
        // * https://github.com/form-data/form-data/issues/513
      }), i = await c.json();
      return c.ok ? { fileMetadata: i, error: null } : { error: {
        status: c.status,
        message: ((L = i == null ? void 0 : i.error) == null ? void 0 : L.message) || c.statusText,
        // * errors from hasura-storage are not codified
        error: c.statusText
      }, fileMetadata: null };
    } catch (c) {
      return { error: {
        status: 0,
        message: c.message,
        error: c.message
      }, fileMetadata: null };
    }
  return new Promise((c) => {
    let i = new XMLHttpRequest();
    i.responseType = "json", i.onload = () => {
      var f, h, T, S, w;
      return i.status < 200 || i.status >= 300 ? c({
        fileMetadata: null,
        error: {
          error: (h = (f = i.response) == null ? void 0 : f.error) != null ? h : i.response,
          message: (w = (S = (T = i.response) == null ? void 0 : T.error) == null ? void 0 : S.message) != null ? w : i.response,
          status: i.status
        }
      }) : c({ fileMetadata: i.response, error: null });
    }, i.onerror = () => c({
      fileMetadata: null,
      error: { error: i.statusText, message: i.statusText, status: i.status }
    }), d && i.upload.addEventListener("progress", d, !1), i.open("POST", U, !0), Object.entries(p).forEach(([f, h]) => {
      i.setRequestHeader(f, h);
    }), i.send(e);
  });
};
let m;
typeof m == "undefined" && (m = R().fetch);
class x {
  constructor({ url: e }) {
    this.url = e;
  }
  async uploadFormData({
    formData: e,
    headers: r,
    bucketId: s
  }) {
    const { error: o, fileMetadata: a } = await y(this.url, e, {
      accessToken: this.accessToken,
      adminSecret: this.adminSecret,
      bucketId: s,
      headers: r
    });
    return o ? { fileMetadata: null, error: o } : a && !("processedFiles" in a) ? {
      fileMetadata: {
        processedFiles: [a]
      },
      error: null
    } : { fileMetadata: a, error: null };
  }
  async uploadFile({
    file: e,
    bucketId: r,
    id: s,
    name: o
  }) {
    const a = typeof window == "undefined" ? new O() : new FormData();
    a.append("file[]", e), a.append("metadata[]", JSON.stringify({ id: s, name: o }));
    const { error: n, fileMetadata: d } = await y(this.url, a, {
      accessToken: this.accessToken,
      adminSecret: this.adminSecret,
      bucketId: r,
      fileId: s,
      name: o
    });
    return n ? { fileMetadata: null, error: n } : d && "processedFiles" in d ? {
      fileMetadata: d.processedFiles[0],
      error: null
    } : { fileMetadata: d, error: null };
  }
  async getPresignedUrl(e) {
    try {
      const { fileId: r } = e, s = await m(`${this.url}/files/${r}/presignedurl`, {
        method: "GET",
        headers: this.generateAuthHeaders()
      });
      if (!s.ok)
        throw new Error(await s.text());
      return { presignedUrl: await s.json(), error: null };
    } catch (r) {
      return { presignedUrl: null, error: r };
    }
  }
  async delete(e) {
    try {
      const { fileId: r } = e, s = await m(`${this.url}/files/${r}`, {
        method: "DELETE",
        headers: this.generateAuthHeaders()
      });
      if (!s.ok)
        throw new Error(await s.text());
      return { error: null };
    } catch (r) {
      return { error: r };
    }
  }
  /**
   * Set the access token to use for authentication.
   *
   * @param accessToken Access token
   * @returns Hasura Storage API instance
   */
  setAccessToken(e) {
    return this.accessToken = e, this;
  }
  /**
   * Set the admin secret to use for authentication.
   *
   * @param adminSecret Hasura admin secret
   * @returns Hasura Storage API instance
   */
  setAdminSecret(e) {
    return this.adminSecret = e, this;
  }
  generateAuthHeaders() {
    if (!(!this.adminSecret && !this.accessToken))
      return this.adminSecret ? {
        "x-hasura-admin-secret": this.adminSecret
      } : {
        Authorization: `Bearer ${this.accessToken}`
      };
  }
}
function F(t, e) {
  if (!e || Object.keys(e).length === 0)
    return t;
  const r = new URL(t), s = Object.entries(e).reduce(
    (o, [a, n]) => ({ ...o, [a.charAt(0)]: n }),
    {}
  );
  return Object.entries(s).forEach(([o, a]) => {
    a && r.searchParams.set(o, a);
  }), r.toString();
}
class j {
  constructor({ url: e, adminSecret: r }) {
    this.url = e, this.api = new x({ url: e }), this.setAdminSecret(r);
  }
  async upload(e) {
    return "file" in e ? this.api.uploadFile(e) : this.api.uploadFormData(e);
  }
  /**
   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url
   */
  getPublicUrl(e) {
    const { fileId: r, ...s } = e;
    return F(
      `${this.url}/files/${r}`,
      s
    );
  }
  /**
   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })
   *
   * if (error) {
   *   throw error;
   * }
   *
   * console.log('url: ', presignedUrl.url)
   * console.log('expiration: ', presignedUrl.expiration)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url
   */
  async getPresignedUrl(e) {
    const { fileId: r, ...s } = e, { presignedUrl: o, error: a } = await this.api.getPresignedUrl(e);
    if (a)
      return { presignedUrl: null, error: a };
    if (!o)
      return { presignedUrl: null, error: new Error("Invalid file id") };
    const n = F(
      o.url,
      s
    );
    return {
      presignedUrl: {
        ...o,
        url: n
      },
      error: null
    };
  }
  /**
   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.
   *
   * @example
   * ```ts
   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/delete
   */
  async delete(e) {
    const { error: r } = await this.api.delete(e);
    return r ? { error: r } : { error: null };
  }
  /**
   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.storage.setAccessToken('some-access-token')
   * ```
   *
   * @param accessToken Access token
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token
   */
  setAccessToken(e) {
    return this.api.setAccessToken(e), this;
  }
  /**
   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in "admin mode".
   *
   * @example
   * ```ts
   * nhost.storage.setAdminSecret('some-admin-secret')
   * ```
   *
   * @param adminSecret Hasura admin secret
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret
   */
  setAdminSecret(e) {
    return this.api.setAdminSecret(e), this;
  }
}
let E;
typeof E == "undefined" && (E = O);
const D = {
  progress: null,
  loaded: 0,
  error: null,
  bucketId: void 0,
  file: void 0,
  id: void 0
}, b = () => I(
  {
    predictableActionArguments: !0,
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    context: { ...D },
    initial: "idle",
    on: {
      DESTROY: { actions: "sendDestroy", target: "stopped" }
    },
    states: {
      idle: {
        on: {
          ADD: { actions: "addFile" },
          UPLOAD: { cond: "hasFile", target: "uploading" }
        }
      },
      uploading: {
        entry: "resetProgress",
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress", "sendProgress"] },
          UPLOAD_DONE: "uploaded",
          UPLOAD_ERROR: "error",
          CANCEL: "idle"
        },
        invoke: { src: "uploadFile" }
      },
      uploaded: {
        entry: ["setFileMetadata", "sendDone"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      error: {
        entry: ["setError", "sendError"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      stopped: { type: "final" }
    }
  },
  {
    guards: {
      hasFile: (t, e) => !!t.file || !!e.file
    },
    actions: {
      incrementProgress: l({
        loaded: (t, { loaded: e }) => e,
        progress: (t, { progress: e }) => e
      }),
      setFileMetadata: l({
        id: (t, { id: e }) => e,
        bucketId: (t, { bucketId: e }) => e,
        progress: (t) => 100
      }),
      setError: l({ error: (t, { error: e }) => e }),
      sendProgress: () => {
      },
      sendError: () => {
      },
      sendDestroy: () => {
      },
      sendDone: () => {
      },
      resetProgress: l({ progress: (t) => null, loaded: (t) => 0 }),
      resetContext: l((t) => D),
      addFile: l({
        file: (t, { file: e }) => e,
        bucketId: (t, { bucketId: e }) => e,
        id: (t, { id: e }) => e
      })
    },
    services: {
      uploadFile: (t, e) => (r) => {
        const s = e.file || t.file, o = new E();
        o.append("file[]", s);
        let a = 0;
        return y(e.url, o, {
          fileId: e.id || t.id,
          bucketId: e.bucketId || t.bucketId,
          accessToken: e.accessToken,
          adminSecret: e.adminSecret,
          name: e.name || s.name,
          onUploadProgress: (n) => {
            const d = n.total ? Math.round(n.loaded * s.size / n.total) : 0, u = d - a;
            a = d, r({
              type: "UPLOAD_PROGRESS",
              progress: n.total ? Math.round(d * 100 / n.total) : 0,
              loaded: d,
              additions: u
            });
          }
        }).then(({ fileMetadata: n, error: d }) => {
          if (d && r({ type: "UPLOAD_ERROR", error: d }), n && !("processedFiles" in n)) {
            const { id: u, bucketId: p } = n;
            r({ type: "UPLOAD_DONE", id: u, bucketId: p });
          }
          if (n && "processedFiles" in n) {
            const { id: u, bucketId: p } = n.processedFiles[0];
            r({ type: "UPLOAD_DONE", id: u, bucketId: p });
          }
        }), () => {
        };
      }
    }
  }
), { pure: P, sendParent: g } = k, H = () => I(
  {
    id: "files-list",
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: !0,
    context: {
      progress: null,
      files: [],
      loaded: 0,
      total: 0
    },
    initial: "idle",
    on: {
      UPLOAD: { cond: "hasFileToDownload", actions: "addItem", target: "uploading" },
      ADD: { actions: "addItem" },
      REMOVE: { actions: "removeItem" }
    },
    states: {
      idle: {
        entry: ["resetProgress", "resetLoaded", "resetTotal"],
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      uploading: {
        entry: ["upload", "startProgress", "resetLoaded", "resetTotal"],
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress"] },
          UPLOAD_DONE: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          UPLOAD_ERROR: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          CANCEL: { actions: "cancel", target: "idle" }
        }
      },
      uploaded: {
        entry: "setUploaded",
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      error: {
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      }
    }
  },
  {
    guards: {
      hasFileToDownload: (t, e) => t.files.some((r) => r.getSnapshot().matches("idle")) || !!e.files,
      isAllUploaded: (t) => t.files.every((e) => {
        var r;
        return (r = e.getSnapshot()) == null ? void 0 : r.matches("uploaded");
      }),
      isAllUploadedOrError: (t) => t.files.every((e) => {
        const r = e.getSnapshot();
        return (r == null ? void 0 : r.matches("error")) || (r == null ? void 0 : r.matches("uploaded"));
      })
    },
    actions: {
      incrementProgress: l((t, e) => {
        const r = t.loaded + e.additions, s = Math.round(r * 100 / t.total);
        return { ...t, loaded: r, progress: s };
      }),
      setUploaded: l({
        progress: (t) => 100,
        loaded: ({ files: t }) => t.map((e) => e.getSnapshot()).filter((e) => e.matches("uploaded")).reduce((e, r) => {
          var s;
          return e + ((s = r.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetTotal: l({
        total: ({ files: t }) => t.map((e) => e.getSnapshot()).filter((e) => !e.matches("uploaded")).reduce((e, r) => {
          var s;
          return e + ((s = r.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetLoaded: l({ loaded: (t) => 0 }),
      startProgress: l({ progress: (t) => 0 }),
      resetProgress: l({ progress: (t) => null }),
      addItem: l((t, { files: e, bucketId: r }) => {
        const s = e ? Array.isArray(e) ? e : "item" in e ? Array.from(e) : [e] : [], o = t.total + s.reduce((n, d) => n + d.size, 0), a = Math.round(t.loaded * 100 / o);
        return {
          files: [
            ...t.files,
            ...s.map(
              (n) => M(
                b().withConfig({
                  actions: {
                    sendProgress: g((d, { additions: u }) => ({
                      type: "UPLOAD_PROGRESS",
                      additions: u
                    })),
                    sendDone: g("UPLOAD_DONE"),
                    sendError: g("UPLOAD_ERROR"),
                    sendDestroy: g("REMOVE")
                  }
                }).withContext({ ...D, file: n, bucketId: r }),
                { sync: !0 }
              )
            )
          ],
          total: o,
          loaded: t.loaded,
          progress: a
        };
      }),
      removeItem: l({
        files: (t) => t.files.filter((e) => {
          var s, o;
          const r = (s = e.getSnapshot()) == null ? void 0 : s.matches("stopped");
          return r && ((o = e.stop) == null || o.call(e)), !r;
        })
      }),
      clearList: P(
        (t) => t.files.map((e) => A({ type: "DESTROY" }, { to: e.id }))
      ),
      upload: P((t, e) => t.files.map((r) => A(e, { to: r.id }))),
      cancel: P(
        (t) => t.files.map((e) => A({ type: "CANCEL" }, { to: e.id }))
      )
    }
  }
), z = async (t, e) => new Promise((r) => {
  e.send({
    type: "UPLOAD",
    ...t
  }), e.subscribe((s) => {
    var o;
    s.matches("error") ? r({
      error: s.context.error,
      isError: !0,
      isUploaded: !1
    }) : s.matches("uploaded") && r({
      error: null,
      isError: !1,
      isUploaded: !0,
      id: s.context.id,
      bucketId: s.context.id,
      name: (o = s.context.file) == null ? void 0 : o.name
    });
  });
}), G = async (t, e) => new Promise((r) => {
  e.send({
    type: "UPLOAD",
    ...t,
    files: t.files
  }), e.onTransition((s) => {
    s.matches("error") ? r({
      errors: s.context.files.filter((o) => {
        var a;
        return (a = o.getSnapshot()) == null ? void 0 : a.context.error;
      }),
      isError: !0,
      files: []
    }) : s.matches("uploaded") && r({ errors: [], isError: !1, files: s.context.files });
  });
});
export {
  x as HasuraStorageApi,
  j as HasuraStorageClient,
  D as INITIAL_FILE_CONTEXT,
  F as appendImageTransformationParameters,
  b as createFileUploadMachine,
  H as createMultipleFilesUploadMachine,
  z as uploadFilePromise,
  G as uploadMultipleFilesPromise
};
//# sourceMappingURL=index.esm.js.map
