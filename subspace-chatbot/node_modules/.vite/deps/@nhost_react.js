import {
  InterpreterStatus,
  State,
  actions_exports,
  api,
  assign,
  createMachine,
  interpret,
  require_browser,
  require_browser2,
  require_fetch_browser,
  send,
  spawn,
  toObserver
} from "./chunk-C5IEOSZL.js";
import {
  require_react
} from "./chunk-QJTFJ6OV.js";
import {
  __commonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is(x5, y4) {
        return x5 === y4 && (0 !== x5 || 1 / x5 === 1 / y4) || x5 !== x5 && y4 !== y4;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        didWarnOld18Alpha || void 0 === React3.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState2({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect2(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value, getSnapshot]
        );
        useEffect3(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is, useState2 = React3.useState, useEffect3 = React3.useEffect, useLayoutEffect2 = React3.useLayoutEffect, useDebugValue = React3.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React3.useSyncExternalStore ? React3.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is(x5, y4) {
        return x5 === y4 && (0 !== x5 || 1 / x5 === 1 / y4) || x5 !== x5 && y4 !== y4;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React3 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = shim.useSyncExternalStore, useRef4 = React3.useRef, useEffect3 = React3.useEffect, useMemo = React3.useMemo, useDebugValue = React3.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual) {
        var instRef = useRef4(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual]
        );
        var value = useSyncExternalStore(subscribe2, instRef[0], instRef[1]);
        useEffect3(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@nhost/react/node_modules/jwt-decode/build/esm/index.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m2, p4) => {
    let code = p4.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output.length % 4) {
    case 0:
      break;
    case 2:
      output += "==";
      break;
    case 3:
      output += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output);
  } catch (err) {
    return atob(output);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
  }
}

// node_modules/@nhost/react/node_modules/@nhost/hasura-auth-js/dist/index.esm.js
var import_fetch_ponyfill = __toESM(require_fetch_browser());
var x = "nhostRefreshToken";
var U = "nhostRefreshTokenId";
var O = "nhostRefreshTokenExpiresAt";
var we = 3;
var Q = 60;
var X = 5;
var ie = 0;
var oe = 1;
var v = 10;
var D = 20;
var b = class extends Error {
  constructor(e) {
    super(e.message), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), e instanceof Error ? (this.name = e.name, this.error = {
      error: e.name,
      status: oe,
      message: e.message
    }) : (this.name = e.error, this.error = e);
  }
};
var R = {
  status: v,
  error: "invalid-email",
  message: "Email is incorrectly formatted"
};
var ke = {
  status: v,
  error: "invalid-mfa-type",
  message: "MFA type is invalid"
};
var ye = {
  status: v,
  error: "invalid-mfa-code",
  message: "MFA code is invalid"
};
var Y = {
  status: v,
  error: "invalid-password",
  message: "Password is incorrectly formatted"
};
var Z = {
  status: v,
  error: "invalid-phone-number",
  message: "Phone number is incorrectly formatted"
};
var Ie = {
  status: v,
  error: "invalid-mfa-ticket",
  message: "MFA ticket is invalid"
};
var Se = {
  status: v,
  error: "no-mfa-ticket",
  message: "No MFA ticket has been provided"
};
var Ae = {
  status: v,
  error: "no-refresh-token",
  message: "No refresh token has been provided"
};
var Re = {
  status: D,
  error: "refresher-already-running",
  message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
};
var k = {
  status: D,
  error: "already-signed-in",
  message: "User is already signed in"
};
var _e = {
  status: D,
  error: "unauthenticated-user",
  message: "User is not authenticated"
};
var ve = {
  status: D,
  error: "unverified-user",
  message: "Email needs verification"
};
var Pe = {
  status: v,
  error: "invalid-refresh-token",
  message: "Invalid or expired refresh token"
};
var Oe = {
  status: oe,
  error: "invalid-sign-in-method",
  message: "Invalid sign-in method"
};
var $ = {
  user: null,
  mfa: null,
  accessToken: {
    value: null,
    expiresAt: null,
    expiresInSeconds: 15
  },
  refreshTimer: {
    startedAt: null,
    attempts: 0,
    lastAttempt: null
  },
  refreshToken: {
    value: null
  },
  importTokenAttempts: 0,
  errors: {}
};
function be(s) {
  return new TextEncoder().encode(s);
}
function P(s) {
  const e = new Uint8Array(s);
  let r = "";
  for (const t of e)
    r += String.fromCharCode(t);
  return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function q(s) {
  const e = s.replace(/-/g, "+").replace(/_/g, "/"), r = (4 - e.length % 4) % 4, n = e.padEnd(e.length + r, "="), t = atob(n), i = new ArrayBuffer(t.length), u = new Uint8Array(i);
  for (let f4 = 0; f4 < t.length; f4++)
    u[f4] = t.charCodeAt(f4);
  return i;
}
function ae() {
  return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == "function";
}
function ce(s) {
  const { id: e } = s;
  return {
    ...s,
    id: q(e),
    transports: s.transports
  };
}
function ue(s) {
  return s === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(s);
}
var p = class extends Error {
  constructor({ message: e, code: r, cause: n, name: t }) {
    super(e, { cause: n }), this.name = t != null ? t : n.name, this.code = r;
  }
};
function Ne({ error: s, options: e }) {
  var n, t;
  const { publicKey: r } = e;
  if (!r)
    throw Error("options was missing required publicKey property");
  if (s.name === "AbortError") {
    if (e.signal instanceof AbortSignal)
      return new p({
        message: "Registration ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: s
      });
  } else if (s.name === "ConstraintError") {
    if (((n = r.authenticatorSelection) == null ? void 0 : n.requireResidentKey) === true)
      return new p({
        message: "Discoverable credentials were required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
        cause: s
      });
    if (((t = r.authenticatorSelection) == null ? void 0 : t.userVerification) === "required")
      return new p({
        message: "User verification was required but no available authenticator supported it",
        code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
        cause: s
      });
  } else {
    if (s.name === "InvalidStateError")
      return new p({
        message: "The authenticator was previously registered",
        code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
        cause: s
      });
    if (s.name === "NotAllowedError")
      return new p({
        message: s.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: s
      });
    if (s.name === "NotSupportedError")
      return r.pubKeyCredParams.filter((u) => u.type === "public-key").length === 0 ? new p({
        message: 'No entry in pubKeyCredParams was of type "public-key"',
        code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
        cause: s
      }) : new p({
        message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
        code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
        cause: s
      });
    if (s.name === "SecurityError") {
      const i = window.location.hostname;
      if (ue(i)) {
        if (r.rp.id !== i)
          return new p({
            message: `The RP ID "${r.rp.id}" is invalid for this domain`,
            code: "ERROR_INVALID_RP_ID",
            cause: s
          });
      } else return new p({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: s
      });
    } else if (s.name === "TypeError") {
      if (r.user.id.byteLength < 1 || r.user.id.byteLength > 64)
        return new p({
          message: "User ID was not between 1 and 64 characters",
          code: "ERROR_INVALID_USER_ID_LENGTH",
          cause: s
        });
    } else if (s.name === "UnknownError")
      return new p({
        message: "The authenticator was unable to process the specified options, or could not create a new credential",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: s
      });
  }
  return s;
}
var xe = class {
  createNewAbortSignal() {
    if (this.controller) {
      const r = new Error("Cancelling existing WebAuthn API call for new one");
      r.name = "AbortError", this.controller.abort(r);
    }
    const e = new AbortController();
    return this.controller = e, e.signal;
  }
  cancelCeremony() {
    if (this.controller) {
      const e = new Error("Manually cancelling existing WebAuthn API call");
      e.name = "AbortError", this.controller.abort(e), this.controller = void 0;
    }
  }
};
var le = new xe();
var Ce = ["cross-platform", "platform"];
function de(s) {
  if (s && !(Ce.indexOf(s) < 0))
    return s;
}
async function fe(s) {
  var a2;
  if (!ae())
    throw new Error("WebAuthn is not supported in this browser");
  const r = { publicKey: {
    ...s,
    challenge: q(s.challenge),
    user: {
      ...s.user,
      id: be(s.user.id)
    },
    excludeCredentials: (a2 = s.excludeCredentials) == null ? void 0 : a2.map(ce)
  } };
  r.signal = le.createNewAbortSignal();
  let n;
  try {
    n = await navigator.credentials.create(r);
  } catch (o) {
    throw Ne({ error: o, options: r });
  }
  if (!n)
    throw new Error("Registration was not completed");
  const { id: t, rawId: i, response: u, type: f4 } = n;
  let d;
  typeof u.getTransports == "function" && (d = u.getTransports());
  let h;
  if (typeof u.getPublicKeyAlgorithm == "function")
    try {
      h = u.getPublicKeyAlgorithm();
    } catch (o) {
      W("getPublicKeyAlgorithm()", o);
    }
  let E3;
  if (typeof u.getPublicKey == "function")
    try {
      const o = u.getPublicKey();
      o !== null && (E3 = P(o));
    } catch (o) {
      W("getPublicKey()", o);
    }
  let T3;
  if (typeof u.getAuthenticatorData == "function")
    try {
      T3 = P(u.getAuthenticatorData());
    } catch (o) {
      W("getAuthenticatorData()", o);
    }
  return {
    id: t,
    rawId: P(i),
    response: {
      attestationObject: P(u.attestationObject),
      clientDataJSON: P(u.clientDataJSON),
      transports: d,
      publicKeyAlgorithm: h,
      publicKey: E3,
      authenticatorData: T3
    },
    type: f4,
    clientExtensionResults: n.getClientExtensionResults(),
    authenticatorAttachment: de(n.authenticatorAttachment)
  };
}
function W(s, e) {
  console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${s}. You should report this error to them.
`, e);
}
function De(s) {
  return new TextDecoder("utf-8").decode(s);
}
function Ue() {
  const s = window.PublicKeyCredential;
  return s.isConditionalMediationAvailable === void 0 ? new Promise((e) => e(false)) : s.isConditionalMediationAvailable();
}
function Me({ error: s, options: e }) {
  const { publicKey: r } = e;
  if (!r)
    throw Error("options was missing required publicKey property");
  if (s.name === "AbortError") {
    if (e.signal instanceof AbortSignal)
      return new p({
        message: "Authentication ceremony was sent an abort signal",
        code: "ERROR_CEREMONY_ABORTED",
        cause: s
      });
  } else {
    if (s.name === "NotAllowedError")
      return new p({
        message: s.message,
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: s
      });
    if (s.name === "SecurityError") {
      const n = window.location.hostname;
      if (ue(n)) {
        if (r.rpId !== n)
          return new p({
            message: `The RP ID "${r.rpId}" is invalid for this domain`,
            code: "ERROR_INVALID_RP_ID",
            cause: s
          });
      } else return new p({
        message: `${window.location.hostname} is an invalid domain`,
        code: "ERROR_INVALID_DOMAIN",
        cause: s
      });
    } else if (s.name === "UnknownError")
      return new p({
        message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
        code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
        cause: s
      });
  }
  return s;
}
async function j(s, e = false) {
  var T3, a2;
  if (!ae())
    throw new Error("WebAuthn is not supported in this browser");
  let r;
  ((T3 = s.allowCredentials) == null ? void 0 : T3.length) !== 0 && (r = (a2 = s.allowCredentials) == null ? void 0 : a2.map(ce));
  const n = {
    ...s,
    challenge: q(s.challenge),
    allowCredentials: r
  }, t = {};
  if (e) {
    if (!await Ue())
      throw Error("Browser does not support WebAuthn autofill");
    if (document.querySelectorAll("input[autocomplete$='webauthn']").length < 1)
      throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');
    t.mediation = "conditional", n.allowCredentials = [];
  }
  t.publicKey = n, t.signal = le.createNewAbortSignal();
  let i;
  try {
    i = await navigator.credentials.get(t);
  } catch (o) {
    throw Me({ error: o, options: t });
  }
  if (!i)
    throw new Error("Authentication was not completed");
  const { id: u, rawId: f4, response: d, type: h } = i;
  let E3;
  return d.userHandle && (E3 = De(d.userHandle)), {
    id: u,
    rawId: P(f4),
    response: {
      authenticatorData: P(d.authenticatorData),
      clientDataJSON: P(d.clientDataJSON),
      signature: P(d.signature),
      userHandle: E3
    },
    type: h,
    clientExtensionResults: i.getClientExtensionResults(),
    authenticatorAttachment: de(i.authenticatorAttachment)
  };
}
var G = typeof window != "undefined";
var V = /* @__PURE__ */ new Map();
var Ke = (s) => {
  var e;
  return G && typeof localStorage != "undefined" ? localStorage.getItem(s) : (e = V.get(s)) != null ? e : null;
};
var Ve = (s, e) => {
  G && typeof localStorage != "undefined" ? e ? localStorage.setItem(s, e) : localStorage.removeItem(s) : e ? V.set(s, e) : V.has(s) && V.delete(s);
};
var Le = (s, e) => {
  if (s === "localStorage" || s === "web")
    return Ke;
  if (s === "cookie")
    return (r) => {
      var n;
      return G && (n = api.get(r)) != null ? n : null;
    };
  if (!e)
    throw Error(
      `clientStorageType is set to '${s}' but no clientStorage has been given`
    );
  if (s === "react-native")
    return (r) => {
      var n;
      return (n = e.getItem) == null ? void 0 : n.call(e, r);
    };
  if (s === "capacitor")
    return (r) => {
      var n;
      return (n = e.get) == null ? void 0 : n.call(e, { key: r });
    };
  if (s === "expo-secure-storage")
    return (r) => {
      var n;
      return (n = e.getItemAsync) == null ? void 0 : n.call(e, r);
    };
  if (s === "custom") {
    if (e.getItem && e.removeItem)
      return e.getItem;
    if (e.getItemAsync)
      return e.getItemAsync;
    throw Error(
      `clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`
    );
  }
  throw Error(`Unknown storage type: ${s}`);
};
var Ge = (s, e) => {
  if (s === "localStorage" || s === "web")
    return Ve;
  if (s === "cookie")
    return (r, n) => {
      G && (n ? api.set(r, n, { expires: 30, sameSite: "lax", httpOnly: false }) : api.remove(r));
    };
  if (!e)
    throw Error(
      `clientStorageType is set to '${s}' but no clienStorage has been given`
    );
  if (s === "react-native")
    return (r, n) => {
      var t, i;
      return n ? (t = e.setItem) == null ? void 0 : t.call(e, r, n) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
    };
  if (s === "capacitor")
    return (r, n) => {
      var t, i;
      return n ? (t = e.set) == null ? void 0 : t.call(e, { key: r, value: n }) : (i = e.remove) == null ? void 0 : i.call(e, { key: r });
    };
  if (s === "expo-secure-storage")
    return async (r, n) => {
      var t, i;
      return n ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, n) : (i = e.deleteItemAsync) == null ? void 0 : i.call(e, r);
    };
  if (s === "custom") {
    if (!e.removeItem)
      throw Error(
        "clientStorageType is set to 'custom' but clientStorage is missing a removeItem property"
      );
    if (e.setItem)
      return (r, n) => {
        var t, i;
        return n ? (t = e.setItem) == null ? void 0 : t.call(e, r, n) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
      };
    if (e.setItemAsync)
      return async (r, n) => {
        var t, i;
        return n ? (t = e.setItemAsync) == null ? void 0 : t.call(e, r, n) : (i = e.removeItem) == null ? void 0 : i.call(e, r);
      };
    throw Error(
      "clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property"
    );
  }
  throw Error(`Unknown storage type: ${s}`);
};
var M = (s) => !s || !s.accessToken.value || !s.accessToken.expiresAt || !s.user ? null : {
  accessToken: s.accessToken.value,
  accessTokenExpiresIn: (s.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
  refreshToken: s.refreshToken.value,
  user: s.user
};
var A = ({
  accessToken: s,
  refreshToken: e,
  isError: r,
  user: n,
  error: t
}) => r ? {
  session: null,
  error: t
} : n && s ? {
  // TODO either return the refresh token or remove it from the session type
  session: { accessToken: s, accessTokenExpiresIn: 0, refreshToken: e, user: n },
  error: null
} : { session: null, error: null };
var L = () => typeof window != "undefined" && typeof window.location != "undefined";
var he = globalThis.fetch;
typeof EdgeRuntime != "string" && (he = (0, import_fetch_ponyfill.default)().fetch);
var me = async (s, e, {
  token: r,
  body: n,
  extraHeaders: t
} = {}) => {
  const i = {
    "Content-Type": "application/json",
    Accept: "*/*"
  };
  r && (i.Authorization = `Bearer ${r}`);
  const u = { ...i, ...t }, f4 = {
    method: e,
    headers: u
  };
  n && (f4.body = JSON.stringify(n));
  try {
    const d = await he(s, f4);
    if (!d.ok) {
      const h = await d.json();
      return Promise.reject({ error: h });
    }
    try {
      return { data: await d.json(), error: null };
    } catch {
      return console.warn(`Unexpected response: can't parse the response of the server at ${s}`), { data: "OK", error: null };
    }
  } catch {
    const h = {
      message: "Network Error",
      status: ie,
      error: "network"
    };
    return Promise.reject({ error: h });
  }
};
var I = async (s, e, r, n) => me(s, "POST", { token: r, body: e, extraHeaders: n });
var $e = (s, e) => me(s, "GET", { token: e });
var F = (s, e) => {
  const r = e && Object.entries(e).map(([n, t]) => {
    const i = Array.isArray(t) ? t.join(",") : typeof t == "object" ? JSON.stringify(t) : t;
    return `${n}=${encodeURIComponent(i)}`;
  }).join("&");
  return r ? `${s}?${r}` : s;
};
var S = (s, e) => {
  if (!(e != null && e.redirectTo))
    return e;
  const { redirectTo: r, ...n } = e;
  if (!s)
    return r.startsWith("/") ? n : e;
  const t = new URL(s), i = Object.fromEntries(new URLSearchParams(t.search)), u = new URL(r.startsWith("/") ? t.origin + r : r), f4 = new URLSearchParams(u.search);
  let d = Object.fromEntries(f4);
  r.startsWith("/") && (d = { ...i, ...d });
  let h = t.pathname;
  return u.pathname.length > 1 && (h += u.pathname.slice(1)), {
    ...n,
    redirectTo: F(u.origin + h, d)
  };
};
function K(s, e) {
  var t;
  if (!e) {
    if (typeof window == "undefined")
      return;
    e = ((t = window.location) == null ? void 0 : t.href) || "";
  }
  s = s.replace(/[\[\]]/g, "\\$&");
  const r = new RegExp("[?&#]" + s + "(=([^&#]*)|&|#|$)"), n = r.exec(e);
  return n ? n[2] ? decodeURIComponent(n[2].replace(/\+/g, " ")) : "" : null;
}
function J(s) {
  var r;
  if (typeof window == "undefined")
    return;
  const e = window == null ? void 0 : window.location;
  if (e && e) {
    const n = new URLSearchParams(e.search), t = new URLSearchParams((r = e.hash) == null ? void 0 : r.slice(1));
    n.delete(s), t.delete(s);
    let i = window.location.pathname;
    Array.from(n).length && (i += `?${n.toString()}`), Array.from(t).length && (i += `#${t.toString()}`), window.history.pushState({}, "", i);
  }
}
var _ = (s) => !!s && typeof s == "string" && !!String(s).toLowerCase().match(
  /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
);
var B = (s) => !!s && typeof s == "string" && s.length >= we;
var ee = (s) => !!s && typeof s == "string";
var We = (s) => s && typeof s == "string" && s.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);
var He = ({
  backendUrl: s,
  clientUrl: e,
  broadcastKey: r,
  clientStorageType: n = "web",
  clientStorage: t,
  refreshIntervalTime: i,
  autoRefreshToken: u = true,
  autoSignIn: f4 = true
}) => {
  const d = Le(n, t), h = Ge(n, t), E3 = async (a2, o, c2, l) => (await I(`${s}${a2}`, o, c2, l)).data;
  let T3 = null;
  if (typeof window != "undefined" && r)
    try {
      T3 = new BroadcastChannel(r);
    } catch {
    }
  return createMachine(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      context: $,
      predictableActionArguments: true,
      id: "nhost",
      type: "parallel",
      states: {
        authentication: {
          initial: "starting",
          on: {
            SESSION_UPDATE: [
              {
                cond: "hasSession",
                actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                target: ".signedIn"
              }
            ]
          },
          states: {
            starting: {
              tags: ["loading"],
              always: { cond: "isSignedIn", target: "signedIn" },
              invoke: {
                id: "importRefreshToken",
                src: "importRefreshToken",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "signedIn"
                  },
                  {
                    target: "signedOut"
                  }
                ],
                onError: [
                  {
                    cond: "shouldRetryImportToken",
                    actions: "incrementTokenImportAttempts",
                    target: "retryTokenImport"
                  },
                  { actions: ["saveAuthenticationError"], target: "signedOut" }
                ]
              }
            },
            retryTokenImport: {
              tags: ["loading"],
              after: {
                RETRY_IMPORT_TOKEN_DELAY: "starting"
              }
            },
            signedOut: {
              initial: "noErrors",
              entry: "reportSignedOut",
              states: {
                noErrors: {},
                success: {},
                needsSmsOtp: {},
                needsMfa: {},
                failed: {},
                signingOut: {
                  entry: ["clearContextExceptTokens"],
                  exit: ["destroyAccessToken", "destroyRefreshToken", "reportTokenChanged"],
                  invoke: {
                    src: "signout",
                    id: "signingOut",
                    onDone: {
                      target: "success"
                    },
                    onError: {
                      target: "failed",
                      actions: ["saveAuthenticationError"]
                    }
                  }
                }
              },
              on: {
                SIGNIN_PASSWORD: "authenticating.password",
                SIGNIN_ANONYMOUS: "authenticating.anonymous",
                SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
                SIGNIN_SECURITY_KEY: "authenticating.securityKey",
                SIGNIN_MFA_TOTP: "authenticating.mfa.totp",
                SIGNIN_PAT: "authenticating.pat",
                SIGNIN_ID_TOKEN: "authenticating.idToken"
              }
            },
            authenticating: {
              entry: "resetErrors",
              states: {
                password: {
                  invoke: {
                    src: "signInPassword",
                    id: "authenticateUserWithPassword",
                    onDone: [
                      {
                        cond: "hasMfaTicket",
                        actions: ["saveMfaTicket"],
                        target: "#nhost.authentication.signedOut.needsMfa"
                      },
                      {
                        actions: ["saveSession", "reportTokenChanged"],
                        target: "#nhost.authentication.signedIn"
                      }
                    ],
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                },
                pat: {
                  invoke: {
                    src: "signInPAT",
                    id: "authenticateWithPAT",
                    onDone: {
                      actions: ["savePATSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                idToken: {
                  invoke: {
                    src: "signInIdToken",
                    id: "authenticateWithIdToken",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                anonymous: {
                  invoke: {
                    src: "signInAnonymous",
                    id: "authenticateAnonymously",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                mfa: {
                  states: {
                    totp: {
                      invoke: {
                        src: "signInMfaTotp",
                        id: "signInMfaTotp",
                        onDone: {
                          actions: ["saveSession", "reportTokenChanged"],
                          target: "#nhost.authentication.signedIn"
                        },
                        onError: {
                          actions: ["saveAuthenticationError"],
                          target: "#nhost.authentication.signedOut.failed"
                        }
                      }
                    }
                  }
                },
                securityKeyEmail: {
                  invoke: {
                    src: "signInSecurityKeyEmail",
                    id: "authenticateUserWithSecurityKey",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                },
                securityKey: {
                  invoke: {
                    src: "signInSecurityKey",
                    id: "authenticateUserWithSecurityKey",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                }
              }
            },
            signedIn: {
              type: "parallel",
              entry: ["reportSignedIn", "cleanUrl", "broadcastToken", "resetErrors"],
              on: {
                SIGNOUT: "signedOut.signingOut"
              },
              states: {
                refreshTimer: {
                  id: "timer",
                  initial: "idle",
                  states: {
                    disabled: { type: "final" },
                    stopped: {
                      always: {
                        cond: "noToken",
                        target: "idle"
                      }
                    },
                    idle: {
                      always: [
                        { cond: "isAutoRefreshDisabled", target: "disabled" },
                        { cond: "isRefreshTokenPAT", target: "disabled" },
                        { cond: "hasRefreshToken", target: "running" }
                      ]
                    },
                    running: {
                      initial: "pending",
                      entry: "resetTimer",
                      states: {
                        pending: {
                          after: {
                            1e3: {
                              internal: false,
                              target: "pending"
                            }
                          },
                          always: {
                            cond: "refreshTimerShouldRefresh",
                            target: "refreshing"
                          }
                        },
                        refreshing: {
                          invoke: {
                            src: "refreshToken",
                            id: "refreshToken",
                            onDone: {
                              actions: [
                                "saveSession",
                                "resetTimer",
                                "reportTokenChanged",
                                "broadcastToken"
                              ],
                              target: "pending"
                            },
                            onError: [
                              {
                                cond: "isUnauthorizedError",
                                target: "#nhost.authentication.signedOut"
                              },
                              { actions: "saveRefreshAttempt", target: "pending" }
                            ]
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        token: {
          initial: "idle",
          states: {
            idle: {
              on: {
                TRY_TOKEN: "running"
              },
              initial: "noErrors",
              states: { noErrors: {}, error: {} }
            },
            running: {
              invoke: {
                src: "refreshToken",
                id: "authenticateWithToken",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged", "broadcastToken"],
                  target: ["#nhost.authentication.signedIn", "idle.noErrors"]
                },
                onError: [
                  { cond: "isSignedIn", target: "idle.error" },
                  {
                    actions: "saveAuthenticationError",
                    target: ["#nhost.authentication.signedOut.failed", "idle.error"]
                  }
                ]
              }
            }
          }
        },
        registration: {
          initial: "incomplete",
          on: {
            SIGNED_IN: [{ cond: "isAnonymous", target: ".incomplete" }, ".complete"]
          },
          states: {
            incomplete: {
              on: {
                SIGNUP_EMAIL_PASSWORD: "emailPassword",
                SIGNUP_SECURITY_KEY: "securityKey",
                PASSWORDLESS_EMAIL: "passwordlessEmail",
                PASSWORDLESS_SMS: "passwordlessSms",
                PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp",
                SIGNIN_EMAIL_OTP: "signInEmailOTP",
                VERIFY_EMAIL_OTP: "verifyEmailOTP"
              },
              initial: "noErrors",
              states: {
                noErrors: {},
                needsEmailVerification: {},
                needsOtp: {},
                failed: {}
              }
            },
            emailPassword: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpEmailPassword",
                id: "signUpEmailPassword",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            securityKey: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpSecurityKey",
                id: "signUpSecurityKey",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            passwordlessEmail: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessEmail",
                id: "passwordlessEmail",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSms: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSms",
                id: "passwordlessSms",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsOtp"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSmsOtp: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSmsOtp",
                id: "passwordlessSmsOtp",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            signInEmailOTP: {
              entry: ["resetErrors"],
              invoke: {
                src: "signInEmailOTP",
                id: "signInEmailOTP",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsOtp"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            verifyEmailOTP: {
              entry: ["resetErrors"],
              invoke: {
                src: "verifyEmailOTP",
                id: "verifyEmailOTP",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            complete: {
              on: {
                SIGNED_OUT: "incomplete"
              }
            }
          }
        }
      }
    },
    {
      actions: {
        reportSignedIn: send("SIGNED_IN"),
        reportSignedOut: send("SIGNED_OUT"),
        reportTokenChanged: send("TOKEN_CHANGED"),
        incrementTokenImportAttempts: assign({
          importTokenAttempts: ({ importTokenAttempts: a2 }) => a2 + 1
        }),
        clearContext: assign(() => (h(O, null), h(x, null), h(U, null), {
          ...$
        })),
        clearContextExceptTokens: assign(({ accessToken: a2, refreshToken: o }) => ({
          ...$,
          accessToken: a2,
          refreshToken: o
        })),
        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine
        saveSession: assign({
          user: (a2, { data: o }) => {
            var c2;
            return ((c2 = o == null ? void 0 : o.session) == null ? void 0 : c2.user) || null;
          },
          accessToken: (a2, { data: o }) => {
            if (o.session) {
              const { accessTokenExpiresIn: c2, accessToken: l } = o.session, m2 = new Date(Date.now() + c2 * 1e3);
              return h(O, m2.toISOString()), {
                value: l,
                expiresAt: m2,
                expiresInSeconds: c2
              };
            }
            return h(O, null), {
              value: null,
              expiresAt: null,
              expiresInSeconds: null
            };
          },
          refreshToken: (a2, { data: o }) => {
            var m2, y4;
            const c2 = ((m2 = o.session) == null ? void 0 : m2.refreshToken) || null, l = ((y4 = o.session) == null ? void 0 : y4.refreshTokenId) || null;
            return c2 && h(x, c2), l && h(U, l), { value: c2 };
          }
        }),
        savePATSession: assign({
          user: (a2, { data: o }) => {
            var c2;
            return ((c2 = o == null ? void 0 : o.session) == null ? void 0 : c2.user) || null;
          },
          accessToken: (a2, { data: o }) => {
            if (o.session) {
              const { accessTokenExpiresIn: c2, accessToken: l } = o.session, m2 = new Date(Date.now() + c2 * 1e3);
              return h(O, m2.toISOString()), {
                value: l,
                expiresAt: m2,
                expiresInSeconds: c2
              };
            }
            return h(O, null), {
              value: null,
              expiresAt: null,
              expiresInSeconds: null
            };
          },
          refreshToken: (a2, { data: o }) => {
            var m2, y4;
            const c2 = ((m2 = o.session) == null ? void 0 : m2.refreshToken) || null, l = ((y4 = o.session) == null ? void 0 : y4.refreshTokenId) || null;
            return c2 && h(x, c2), l && h(U, l), { value: c2, isPAT: true };
          }
        }),
        saveMfaTicket: assign({
          mfa: (a2, o) => {
            var c2;
            return (c2 = o.data) == null ? void 0 : c2.mfa;
          }
        }),
        resetTimer: assign({
          refreshTimer: (a2) => ({
            startedAt: /* @__PURE__ */ new Date(),
            attempts: 0,
            lastAttempt: null
          })
        }),
        saveRefreshAttempt: assign({
          refreshTimer: (a2, o) => ({
            startedAt: a2.refreshTimer.startedAt,
            attempts: a2.refreshTimer.attempts + 1,
            lastAttempt: /* @__PURE__ */ new Date()
          })
        }),
        // * Authentication errors
        saveAuthenticationError: assign({
          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
          errors: ({ errors: a2 }, { data: { error: o } }) => ({
            ...a2,
            authentication: o
          })
        }),
        resetErrors: assign({
          errors: (a2) => ({}),
          importTokenAttempts: (a2) => 0
        }),
        saveRegistrationError: assign({
          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
          errors: ({ errors: a2 }, { data: { error: o } }) => ({ ...a2, registration: o })
        }),
        destroyRefreshToken: assign({
          refreshToken: (a2) => (h(x, null), h(U, null), { value: null })
        }),
        destroyAccessToken: assign({
          accessToken: (a2) => (h(O, null), {
            value: null,
            expiresAt: null,
            expiresInSeconds: null
          })
        }),
        // * Clean the browser url when `autoSignIn` is activated
        cleanUrl: () => {
          f4 && K("refreshToken") && (J("refreshToken"), J("type"));
        },
        // * Broadcast the session to other tabs when `autoSignIn` is activated
        broadcastToken: (a2) => {
          if (f4 && r && T3)
            try {
              T3.postMessage({
                type: "broadcast_session",
                payload: {
                  token: a2.refreshToken.value,
                  accessToken: a2.accessToken.value,
                  user: a2.user,
                  expiresAt: a2.accessToken.expiresAt ? a2.accessToken.expiresAt.toISOString() : null,
                  expiresInSeconds: a2.accessToken.expiresInSeconds
                }
              });
            } catch {
            }
        }
      },
      guards: {
        isAnonymous: (a2, o) => {
          var c2;
          return !!((c2 = a2.user) != null && c2.isAnonymous);
        },
        isSignedIn: (a2) => !!a2.user && !!a2.accessToken.value,
        noToken: (a2) => !a2.refreshToken.value,
        isRefreshTokenPAT: (a2) => {
          var o;
          return !!((o = a2.refreshToken) != null && o.isPAT);
        },
        hasRefreshToken: (a2) => !!a2.refreshToken.value,
        isAutoRefreshDisabled: () => !u,
        refreshTimerShouldRefresh: (a2) => {
          const { expiresAt: o } = a2.accessToken;
          if (!o)
            return false;
          if (a2.refreshTimer.lastAttempt)
            return a2.refreshTimer.attempts > X ? false : Date.now() - a2.refreshTimer.lastAttempt.getTime() > Math.pow(2, a2.refreshTimer.attempts - 1) * 5e3;
          if (o.getTime() < Date.now() || i && Date.now() - a2.refreshTimer.startedAt.getTime() > i * 1e3)
            return true;
          if (!a2.accessToken.expiresInSeconds)
            return false;
          const l = o.getTime() - Date.now();
          return l <= Q * 1e3 / 2 || l <= Q * 1e3 && Math.random() < 0.1;
        },
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        /** Should retry to import the token on network error or any internal server error.
         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.
         */
        shouldRetryImportToken: (a2, o) => a2.importTokenAttempts < X && (o.data.error.status === ie || o.data.error.status >= 500),
        // * Authentication errors
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        unverified: (a2, { data: { error: o } }) => o.status === 401 && // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)
        (o.message === "Email is not verified" || o.error === "unverified-user"),
        // * Event guards
        hasSession: (a2, o) => {
          var c2;
          return !!((c2 = o.data) != null && c2.session);
        },
        hasMfaTicket: (a2, o) => {
          var c2;
          return !!((c2 = o.data) != null && c2.mfa);
        },
        isUnauthorizedError: (a2, { data: { error: o } }) => o.status === 401
      },
      services: {
        signInPassword: (a2, { email: o, password: c2 }) => _(o) ? B(c2) ? E3("/signin/email-password", {
          email: o,
          password: c2
        }) : Promise.reject({ error: Y }) : Promise.reject({ error: R }),
        signInPAT: (a2, { pat: o }) => E3("/signin/pat", {
          personalAccessToken: o
        }),
        signInIdToken: (a2, { provider: o, idToken: c2, nonce: l }) => E3("/signin/idtoken", {
          provider: o,
          idToken: c2,
          ...l && { nonce: l }
        }),
        passwordlessSms: (a2, { phoneNumber: o, options: c2 }) => {
          var l;
          return ee(o) ? (l = a2.user) != null && l.isAnonymous ? (console.warn(
            "Deanonymisation from a phone number is not yet implemented in hasura-auth"
          ), E3(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "sms",
              phoneNumber: o,
              options: S(e, c2)
            },
            a2.accessToken.value
          )) : E3("/signin/passwordless/sms", {
            phoneNumber: o,
            options: S(e, c2)
          }) : Promise.reject({ error: Z });
        },
        passwordlessSmsOtp: (a2, { phoneNumber: o, otp: c2 }) => ee(o) ? E3("/signin/passwordless/sms/otp", {
          phoneNumber: o,
          otp: c2
        }) : Promise.reject({ error: Z }),
        signInEmailOTP: (a2, { email: o, options: c2 }) => _(o) ? E3("/signin/otp/email", {
          email: o,
          options: S(e, c2)
        }) : Promise.reject({ error: R }),
        verifyEmailOTP: (a2, { email: o, otp: c2 }) => _(o) ? E3("/signin/otp/email/verify", {
          email: o,
          otp: c2
        }) : Promise.reject({ error: R }),
        passwordlessEmail: (a2, { email: o, options: c2 }) => {
          var l;
          return _(o) ? (l = a2.user) != null && l.isAnonymous ? E3(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "email",
              email: o,
              options: S(e, c2)
            },
            a2.accessToken.value
          ) : E3("/signin/passwordless/email", {
            email: o,
            options: S(e, c2)
          }) : Promise.reject({ error: R });
        },
        signInAnonymous: (a2) => E3("/signin/anonymous"),
        signInMfaTotp: (a2, o) => {
          var l;
          const c2 = o.ticket || ((l = a2.mfa) == null ? void 0 : l.ticket);
          return c2 ? We(c2) ? E3("/signin/mfa/totp", {
            ticket: c2,
            otp: o.otp
          }) : Promise.reject({ error: Ie }) : Promise.reject({ error: Se });
        },
        signInSecurityKeyEmail: async (a2, { email: o }) => {
          if (!_(o))
            throw new b(R);
          const c2 = await E3(
            "/signin/webauthn",
            { email: o }
          );
          let l;
          try {
            l = await j(c2);
          } catch (m2) {
            throw new b(m2);
          }
          return E3("/signin/webauthn/verify", { email: o, credential: l });
        },
        refreshToken: async (a2, o) => {
          const c2 = o.type === "TRY_TOKEN" ? o.token : a2.refreshToken.value;
          return { session: await E3("/token", {
            refreshToken: c2
          }), error: null };
        },
        signInSecurityKey: async () => {
          try {
            const a2 = await E3(
              "/signin/webauthn",
              {}
            );
            let o;
            try {
              o = await j(a2);
            } catch (c2) {
              throw new b(c2);
            }
            return E3("/signin/webauthn/verify", { credential: o });
          } catch (a2) {
            throw new b(a2);
          }
        },
        signout: async (a2, o) => {
          const c2 = await E3(
            "/signout",
            {
              refreshToken: a2.refreshToken.value,
              all: !!o.all
            },
            o.all ? a2.accessToken.value : void 0
          );
          if (r && T3)
            try {
              T3.postMessage({ type: "signout" });
            } catch {
            }
          return c2;
        },
        signUpEmailPassword: async (a2, { email: o, password: c2, options: l, requestOptions: m2 }) => {
          var y4;
          return _(o) ? B(c2) ? (y4 = a2.user) != null && y4.isAnonymous ? E3(
            "/user/deanonymize",
            {
              signInMethod: "email-password",
              email: o,
              password: c2,
              options: S(e, l)
            },
            a2.accessToken.value,
            m2 == null ? void 0 : m2.headers
          ) : E3(
            "/signup/email-password",
            {
              email: o,
              password: c2,
              options: S(e, l)
            },
            null,
            m2 == null ? void 0 : m2.headers
          ) : Promise.reject({ error: Y }) : Promise.reject({ error: R });
        },
        signUpSecurityKey: async (a2, { email: o, options: c2, requestOptions: l }) => {
          if (!_(o))
            return Promise.reject({ error: R });
          const m2 = c2 == null ? void 0 : c2.nickname;
          m2 && delete c2.nickname;
          const y4 = await E3(
            "/signup/webauthn",
            { email: o, options: c2 },
            null,
            l == null ? void 0 : l.headers
          );
          let z2;
          try {
            z2 = await fe(y4);
          } catch (ge2) {
            throw new b(ge2);
          }
          return E3("/signup/webauthn/verify", {
            credential: z2,
            options: {
              redirectTo: c2 == null ? void 0 : c2.redirectTo,
              nickname: m2,
              displayName: c2 == null ? void 0 : c2.displayName,
              ...(c2 == null ? void 0 : c2.metadata) && { metadata: c2 == null ? void 0 : c2.metadata }
            }
          });
        },
        importRefreshToken: async (a2) => {
          if (a2.user && a2.refreshToken.value && a2.accessToken.value && a2.accessToken.expiresAt)
            return {
              session: {
                accessToken: a2.accessToken.value,
                accessTokenExpiresIn: a2.accessToken.expiresAt.getTime() - Date.now(),
                refreshToken: a2.refreshToken.value,
                user: a2.user
              },
              error: null
            };
          let o = null;
          if (f4) {
            const l = K("refreshToken") || null;
            if (l)
              try {
                return { session: await E3("/token", {
                  refreshToken: l
                }), error: null };
              } catch (m2) {
                o = m2.error;
              }
            else {
              const m2 = K("error"), y4 = K("errorDescription");
              if (m2 && y4 !== "social user already exists")
                return Promise.reject({
                  session: null,
                  error: {
                    status: v,
                    error: m2,
                    message: y4 || m2
                  }
                });
            }
          }
          const c2 = await d(x);
          if (c2)
            try {
              return { session: await E3("/token", {
                refreshToken: c2
              }), error: null };
            } catch (l) {
              o = l.error;
            }
          return o ? Promise.reject({ error: o, session: null }) : { error: null, session: null };
        }
      },
      delays: {
        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts: a2 }) => Math.pow(2, a2 - 1) * 5e3
      }
    }
  );
};
var Ye = ({ backendUrl: s, clientUrl: e, interpreter: r }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "changeEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: assign({ error: (n) => R }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (n, { data: { error: t } }) => t
      }),
      reportError: send((n) => ({ type: "ERROR", error: n.error })),
      // TODO change email in the main machine (context.user.email)
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (n, { email: t }) => !_(t)
    },
    services: {
      requestChange: async (n, { email: t, options: i }) => (await I(
        `${s}/user/email/change`,
        { newEmail: t, options: S(e, i) },
        r == null ? void 0 : r.getSnapshot().context.accessToken.value
      )).data
    }
  }
);
var je = ({ backendUrl: s, interpreter: e }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidPassword",
              actions: "saveInvalidPasswordError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidPasswordError: assign({ error: (r) => Y }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (r, { data: { error: n } }) => n
      }),
      reportError: send((r) => ({ type: "ERROR", error: r.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidPassword: (r, { password: n }) => !B(n)
    },
    services: {
      requestChange: (r, { password: n, ticket: t }) => I(
        `${s}/user/password`,
        { newPassword: n, ticket: t },
        e == null ? void 0 : e.getSnapshot().context.accessToken.value
      )
    }
  }
);
var kr = ({ backendUrl: s, interpreter: e }) => createMachine(
  {
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "enableMfa",
    initial: "idle",
    context: { error: null, imageUrl: null, secret: null },
    states: {
      idle: {
        initial: "initial",
        on: {
          GENERATE: "generating",
          DISABLE: "disabling"
        },
        states: {
          initial: {},
          error: {},
          disabled: {}
        }
      },
      generating: {
        invoke: {
          src: "generate",
          id: "generate",
          onDone: { target: "generated", actions: ["reportGeneratedSuccess", "saveGeneration"] },
          onError: { actions: ["saveError", "reportGeneratedError"], target: "idle.error" }
        }
      },
      generated: {
        initial: "idle",
        states: {
          idle: {
            initial: "idle",
            on: {
              ACTIVATE: [
                {
                  cond: "invalidMfaType",
                  actions: "saveInvalidMfaTypeError",
                  target: ".error"
                },
                {
                  cond: "invalidMfaCode",
                  actions: "saveInvalidMfaCodeError",
                  target: ".error"
                },
                {
                  target: "activating"
                }
              ],
              DISABLE: "#enableMfa.disabling"
            },
            states: { idle: {}, error: {} }
          },
          activating: {
            invoke: {
              src: "activate",
              id: "activate",
              onDone: { target: "activated", actions: "reportSuccess" },
              onError: { actions: ["saveError", "reportError"], target: "idle.error" }
            }
          },
          activated: { type: "final" }
        }
      },
      disabling: {
        invoke: {
          src: "disable",
          id: "disable",
          onDone: { target: "idle.disabled", actions: "reportSuccess" },
          onError: { actions: ["saveError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidMfaTypeError: assign({ error: (r) => ke }),
      saveInvalidMfaCodeError: assign({ error: (r) => ye }),
      saveError: assign({
        error: (r, { data: { error: n } }) => n
      }),
      saveGeneration: assign({
        imageUrl: (r, { data: { imageUrl: n } }) => n,
        secret: (r, { data: { totpSecret: n } }) => n
      }),
      reportError: send((r, n) => ({ type: "ERROR", error: r.error })),
      reportSuccess: send("SUCCESS"),
      reportGeneratedSuccess: send("GENERATED"),
      reportGeneratedError: send((r) => ({ type: "GENERATED_ERROR", error: r.error }))
    },
    guards: {
      invalidMfaCode: (r, { code: n }) => !n,
      invalidMfaType: (r, { activeMfaType: n }) => !n || n !== "totp"
    },
    services: {
      generate: async (r) => {
        const { data: n } = await $e(
          `${s}/mfa/totp/generate`,
          e == null ? void 0 : e.getSnapshot().context.accessToken.value
        );
        return n;
      },
      activate: (r, { code: n, activeMfaType: t }) => I(
        `${s}/user/mfa`,
        { code: n, activeMfaType: t },
        e == null ? void 0 : e.getSnapshot().context.accessToken.value
      ),
      disable: (r, { code: n }) => I(
        `${s}/user/mfa`,
        { code: n, activeMfaType: "" },
        e == null ? void 0 : e.getSnapshot().context.accessToken.value
      )
    }
  }
);
var Fe = ({ backendUrl: s, clientUrl: e }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: assign({ error: (r) => R }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (r, { data: { error: n } }) => n
      }),
      reportError: send((r) => ({ type: "ERROR", error: r.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (r, { email: n }) => !_(n)
    },
    services: {
      requestChange: (r, { email: n, options: t }) => I(`${s}/user/password/reset`, {
        email: n,
        options: S(e, t)
      })
    }
  }
);
var Be = ({ backendUrl: s, clientUrl: e }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "sendVerificationEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "request",
          id: "request",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: assign({ error: (r) => R }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (r, { data: { error: n } }) => n
      }),
      reportError: send((r) => ({ type: "ERROR", error: r.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (r, { email: n }) => !_(n)
    },
    services: {
      request: async (r, { email: n, options: t }) => (await I(
        `${s}/user/email/send-verification-email`,
        { email: n, options: S(e, t) }
      )).data
    }
  }
);
var Ee = class {
  constructor({
    clientStorageType: e = "web",
    autoSignIn: r = true,
    autoRefreshToken: n = true,
    start: t = true,
    backendUrl: i,
    clientUrl: u,
    broadcastKey: f4,
    devTools: d,
    ...h
  }) {
    var E3;
    if (this._started = false, this._subscriptionsQueue = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Set(), this.backendUrl = i, this.clientUrl = u, this._machine = He({
      ...h,
      backendUrl: i,
      clientUrl: u,
      broadcastKey: f4,
      clientStorageType: e,
      autoSignIn: r,
      autoRefreshToken: n
    }), t && this.start({ devTools: d }), typeof window != "undefined" && f4)
      try {
        this._channel = new BroadcastChannel(f4), r && ((E3 = this._channel) == null || E3.addEventListener("message", (T3) => {
          var c2;
          const { type: a2, payload: o } = T3.data;
          if (a2 === "broadcast_session") {
            const l = (c2 = this.interpreter) == null ? void 0 : c2.getSnapshot().context, m2 = l == null ? void 0 : l.refreshToken.value;
            this.interpreter && o.token && o.token !== m2 && this.interpreter.send("SESSION_UPDATE", {
              data: {
                session: {
                  user: o.user,
                  accessToken: o.accessToken,
                  refreshToken: o.token,
                  accessTokenExpiresIn: o.expiresInSeconds
                }
              }
            });
          }
        })), this._channel.addEventListener("message", (T3) => {
          const { type: a2 } = T3.data;
          a2 === "signout" && this.interpreter && this.interpreter.send("SIGNOUT");
        });
      } catch {
      }
  }
  start({
    devTools: e = false,
    initialSession: r,
    interpreter: n
  } = {}) {
    var u, f4;
    const t = {
      ...this.machine.context,
      accessToken: {
        ...this.machine.context.accessToken
      },
      refreshToken: {
        ...this.machine.context.refreshToken
      }
    };
    r && (t.user = r.user, t.refreshToken.value = (u = r.refreshToken) != null ? u : null, t.accessToken.value = (f4 = r.accessToken) != null ? f4 : null, t.accessToken.expiresAt = new Date(
      Date.now() + r.accessTokenExpiresIn * 1e3
    ));
    const i = this.machine.withContext(t);
    this._interpreter || (this._interpreter = n || interpret(i, { devTools: e })), (!this._started || typeof window == "undefined") && (this._interpreter.initialized && (this._interpreter.stop(), this._subscriptions.forEach((d) => d())), this._interpreter.start(i.initialState), this._subscriptionsQueue.forEach((d) => d(this))), this._started = true;
  }
  get machine() {
    return this._machine;
  }
  get interpreter() {
    return this._interpreter;
  }
  get started() {
    return this._started;
  }
  subscribe(e) {
    if (this.started) {
      const r = e(this);
      return this._subscriptions.add(r), r;
    } else
      return this._subscriptionsQueue.add(e), () => {
        console.log(
          "onTokenChanged was added before the interpreter started. Cannot unsubscribe listener."
        );
      };
  }
};
var ze = async ({ backendUrl: s, interpreter: e }, r) => {
  try {
    const { data: n } = await I(
      `${s}/user/webauthn/add`,
      {},
      e == null ? void 0 : e.getSnapshot().context.accessToken.value
    );
    let t;
    try {
      t = await fe(n);
    } catch (u) {
      throw new b(u);
    }
    const { data: i } = await I(
      `${s}/user/webauthn/verify`,
      { credential: t, nickname: r },
      e == null ? void 0 : e.getSnapshot().context.accessToken.value
    );
    return { key: i, isError: false, error: null, isSuccess: true };
  } catch (n) {
    const { error: t } = n;
    return { isError: true, error: t, isSuccess: false };
  }
};
var Qe = async (s, e, r) => new Promise((n) => {
  s.send("REQUEST", {
    email: e,
    options: r
  }), s.onTransition((t) => {
    t.matches({ idle: "error" }) ? n({ error: t.context.error, isError: true, needsEmailVerification: false }) : t.matches({ idle: "success" }) && n({ error: null, isError: false, needsEmailVerification: true });
  });
});
var Xe = async (s, e, r) => new Promise((n) => {
  s.send("REQUEST", {
    password: e,
    ticket: r
  }), s.onTransition((t) => {
    t.matches({ idle: "error" }) ? n({ error: t.context.error, isError: true, isSuccess: false }) : t.matches({ idle: "success" }) && n({ error: null, isError: false, isSuccess: true });
  });
});
var Ir = (s) => new Promise((e) => {
  s.send("GENERATE"), s.onTransition((r) => {
    r.matches("generated") ? e({
      error: null,
      isError: false,
      isGenerated: true,
      qrCodeDataUrl: r.context.imageUrl || "",
      totpSecret: r.context.secret
    }) : r.matches({ idle: "error" }) && e({
      error: r.context.error || null,
      isError: true,
      isGenerated: false,
      qrCodeDataUrl: "",
      totpSecret: r.context.secret
    });
  });
});
var Sr = (s, e) => new Promise((r) => {
  s.send("ACTIVATE", {
    activeMfaType: "totp",
    code: e
  }), s.onTransition((n) => {
    n.matches({ generated: "activated" }) ? r({ error: null, isActivated: true, isError: false }) : n.matches({ generated: { idle: "error" } }) && r({ error: n.context.error, isActivated: false, isError: true });
  });
});
var Ar = (s, e) => new Promise((r) => {
  s.send("DISABLE", { code: e }), s.onTransition((n) => {
    n.matches({ idle: "disabled" }) ? r({ error: null, isDisabled: true, isError: false }) : n.matches({ idle: "error" }) && r({ error: n.context.error, isDisabled: false, isError: true });
  });
});
var Ze = async (s, e, r) => new Promise((n) => {
  s.send("REQUEST", {
    email: e,
    options: r
  }), s.onTransition((t) => {
    t.matches({ idle: "error" }) ? n({ error: t.context.error, isError: true, isSent: false }) : t.matches({ idle: "success" }) && n({ error: null, isError: false, isSent: true });
  });
});
var Je = (s, e, r) => new Promise((n) => {
  s.send("REQUEST", {
    email: e,
    options: r
  }), s.onTransition((t) => {
    t.matches({ idle: "error" }) ? n({ error: t.context.error, isError: true, isSent: false }) : t.matches({ idle: "success" }) && n({ error: null, isError: false, isSent: true });
  });
});
var er = (s) => new Promise((e) => {
  const { changed: r } = s.send("SIGNIN_ANONYMOUS");
  r || e({
    isSuccess: false,
    isError: true,
    error: k,
    user: null,
    accessToken: null,
    refreshToken: null
  }), s.onTransition((n) => {
    n.matches({ authentication: "signedIn" }) && e({
      isSuccess: true,
      isError: false,
      error: null,
      user: n.context.user,
      accessToken: n.context.accessToken.value,
      refreshToken: n.context.refreshToken.value
    }), n.matches({ authentication: { signedOut: "failed" } }) && e({
      isSuccess: false,
      isError: true,
      error: n.context.errors.authentication || null,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  });
});
var rr = (s, e, r) => new Promise((n) => {
  const { changed: t, context: i } = s.send("SIGNIN_PASSWORD", {
    email: e,
    password: r
  });
  if (!t)
    return n({
      accessToken: i.accessToken.value,
      refreshToken: i.refreshToken.value,
      error: k,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: i.user
    });
  s.onTransition((u) => {
    u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? n({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      needsMfaOtp: false,
      mfa: null,
      user: null
    }) : u.matches({ authentication: { signedOut: "needsMfa" } }) ? n({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: true,
      mfa: u.context.mfa,
      user: null
    }) : u.matches({ authentication: { signedOut: "failed" } }) ? n({
      accessToken: null,
      refreshToken: null,
      error: u.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: null
    }) : u.matches({ authentication: "signedIn" }) && n({
      accessToken: u.context.accessToken.value,
      refreshToken: u.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: u.context.user
    });
  });
});
var re = (s, e, r) => new Promise((n) => {
  const { changed: t } = s.send("PASSWORDLESS_EMAIL", {
    email: e,
    options: r
  });
  if (!t)
    return n({
      error: k,
      isError: true,
      isSuccess: false
    });
  s.onTransition((i) => {
    i.matches("registration.incomplete.failed") ? n({
      error: i.context.errors.registration || null,
      isError: true,
      isSuccess: false
    }) : i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) && n({ error: null, isError: false, isSuccess: true });
  });
});
var nr = (s, e) => new Promise((r) => {
  const { changed: n, context: t } = s.send({ type: "SIGNIN_SECURITY_KEY_EMAIL", email: e });
  if (!n)
    return r({
      accessToken: t.accessToken.value,
      refreshToken: t.refreshToken.value,
      error: k,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: t.user
    });
  s.onTransition((i) => {
    i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? r({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : i.matches({ authentication: { signedOut: "failed" } }) ? r({
      accessToken: null,
      refreshToken: null,
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : i.matches({ authentication: "signedIn" }) && r({
      accessToken: i.context.accessToken.value,
      refreshToken: i.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: i.context.user
    });
  });
});
function ne(s) {
  return {
    error: s.message || "Something went wrong!",
    status: s.status || 1,
    message: s.message || "Something went wrong!"
  };
}
var sr = async (s, e) => {
  var u, f4;
  const r = (u = s.interpreter) == null ? void 0 : u.getSnapshot(), n = r == null ? void 0 : r.context.accessToken.value;
  let t;
  try {
    t = (await I(
      `${s.backendUrl}/elevate/webauthn`,
      {
        email: e
      },
      n
    )).data;
  } catch (d) {
    return {
      error: ne(d),
      isError: true,
      isSuccess: false,
      elevated: false
    };
  }
  let i;
  try {
    i = await j(t);
  } catch (d) {
    return {
      error: ne(d),
      isError: true,
      isSuccess: false,
      elevated: false
    };
  }
  try {
    const {
      data: { session: d },
      error: h
    } = await I(
      `${s.backendUrl}/elevate/webauthn/verify`,
      {
        email: e,
        credential: i
      },
      n
    );
    return d && !h ? ((f4 = s.interpreter) == null || f4.send({
      type: "SESSION_UPDATE",
      data: {
        session: d
      }
    }), {
      error: null,
      isError: false,
      isSuccess: true,
      elevated: true
    }) : {
      error: h,
      isError: true,
      isSuccess: false,
      elevated: false
    };
  } catch (d) {
    const { error: h } = d;
    return {
      error: h,
      isError: true,
      isSuccess: false,
      elevated: false
    };
  }
};
var tr = (s, e, r) => new Promise((n) => {
  const { changed: t, context: i } = s.send("SIGNIN_MFA_TOTP", {
    otp: e,
    ticket: r
  });
  if (!t)
    return n({
      accessToken: i.accessToken.value,
      refreshToken: i.refreshToken.value,
      error: k,
      isError: true,
      isSuccess: false,
      user: i.user
    });
  s.onTransition((u) => {
    u.matches({ authentication: { signedOut: "failed" } }) ? n({
      accessToken: null,
      refreshToken: null,
      error: u.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      user: null
    }) : u.matches({ authentication: "signedIn" }) && n({
      accessToken: u.context.accessToken.value,
      refreshToken: u.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      user: u.context.user
    });
  });
});
var ir = (s, e) => new Promise((r) => {
  const { changed: n } = s.send("SIGNIN_PAT", { pat: e });
  n || r({
    isSuccess: false,
    isError: true,
    error: k,
    user: null,
    accessToken: null,
    refreshToken: null
  }), s.onTransition((t) => {
    if (t.matches({ authentication: { signedOut: "failed" } }))
      return r({
        accessToken: null,
        refreshToken: null,
        user: null,
        error: t.context.errors.authentication || null,
        isError: true,
        isSuccess: false
      });
    if (t.matches({ authentication: "signedIn" }))
      return r({
        accessToken: t.context.accessToken.value,
        refreshToken: t.context.refreshToken.value,
        user: t.context.user,
        error: null,
        isError: false,
        isSuccess: true
      });
  });
});
var se = (s, e, r) => new Promise((n) => {
  const { changed: t } = s.send("PASSWORDLESS_SMS", { phoneNumber: e, options: r });
  if (!t)
    return n({
      error: k,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  s.onTransition((i) => {
    i.matches("registration.incomplete.needsOtp") ? n({
      error: null,
      isError: false,
      isSuccess: false,
      needsOtp: true
    }) : i.matches("registration.incomplete.failed") && n({
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  });
});
var or = (s, e, r) => new Promise((n) => {
  const { changed: t } = s.send({ type: "PASSWORDLESS_SMS_OTP", phoneNumber: e, otp: r });
  if (!t)
    return n({
      error: k,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  s.onTransition((i) => {
    i.matches({ authentication: "signedIn" }) ? n({
      error: null,
      isError: false,
      isSuccess: true,
      user: i.context.user,
      accessToken: i.context.accessToken.value,
      refreshToken: i.context.refreshToken.value
    }) : i.matches({ registration: { incomplete: "failed" } }) && n({
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  });
});
var ar = async (s, e) => new Promise((r) => {
  const { event: n } = s.send("SIGNOUT", { all: e });
  if (n.type !== "SIGNED_OUT")
    return r({ isSuccess: false, isError: true, error: _e });
  s.onTransition((t) => {
    t.matches({ authentication: { signedOut: "success" } }) ? r({ isSuccess: true, isError: false, error: null }) : t.matches("authentication.signedOut.failed") && r({ isSuccess: false, isError: true, error: t.context.errors.signout || null });
  });
});
var te = (s, e, r, n, t) => new Promise((i) => {
  const { changed: u, context: f4 } = s.send("SIGNUP_EMAIL_PASSWORD", {
    email: e,
    password: r,
    options: n,
    requestOptions: t
  });
  if (!u)
    return i({
      error: k,
      accessToken: f4.accessToken.value,
      refreshToken: f4.refreshToken.value,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: f4.user
    });
  s.onTransition((d) => {
    d.matches("registration.incomplete.failed") ? i({
      accessToken: null,
      refreshToken: null,
      error: d.context.errors.registration || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : d.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? i({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : d.matches({ authentication: "signedIn", registration: "complete" }) && i({
      accessToken: d.context.accessToken.value,
      refreshToken: d.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: d.context.user
    });
  });
});
var cr = (s, e, r, n) => new Promise((t) => {
  const { changed: i, context: u } = s.send("SIGNUP_SECURITY_KEY", {
    email: e,
    options: r,
    requestOptions: n
  });
  if (!i)
    return t({
      error: k,
      accessToken: u.accessToken.value,
      refreshToken: u.refreshToken.value,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: u.user
    });
  s.onTransition((f4) => {
    f4.matches("registration.incomplete.failed") ? t({
      accessToken: null,
      refreshToken: null,
      error: f4.context.errors.registration || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : f4.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? t({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : f4.matches({ authentication: "signedIn", registration: "complete" }) && t({
      accessToken: f4.context.accessToken.value,
      refreshToken: f4.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: f4.context.user
    });
  });
});
var ur = (s, e, r) => new Promise((n) => {
  const { changed: t } = s.send("SIGNIN_EMAIL_OTP", { email: e, options: r });
  if (!t)
    return n({
      error: k,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  s.onTransition((i) => {
    i.matches("registration.incomplete.needsOtp") ? n({
      error: null,
      isError: false,
      isSuccess: true,
      needsOtp: true
    }) : i.matches("registration.incomplete.failed") && n({
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  });
});
var lr = (s, e, r) => new Promise((n) => {
  const { changed: t } = s.send({ type: "VERIFY_EMAIL_OTP", email: e, otp: r });
  if (!t)
    return n({
      error: k,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  s.onTransition((i) => {
    i.matches({ authentication: "signedIn" }) ? n({
      error: null,
      isError: false,
      isSuccess: true,
      user: i.context.user,
      accessToken: i.context.accessToken.value,
      refreshToken: i.context.refreshToken.value
    }) : i.matches({ registration: { incomplete: "failed" } }) && n({
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  });
});
var dr = (s, { provider: e, idToken: r, nonce: n }) => new Promise((t) => {
  const { changed: i } = s.send("SIGNIN_ID_TOKEN", {
    provider: e,
    idToken: r,
    ...n && { nonce: n }
  });
  i || t({
    isSuccess: false,
    isError: true,
    error: k,
    user: null,
    accessToken: null,
    refreshToken: null
  }), s.onTransition((u) => {
    if (u.matches({ authentication: { signedOut: "failed" } }))
      return t({
        accessToken: null,
        refreshToken: null,
        user: null,
        error: u.context.errors.authentication || null,
        isError: true,
        isSuccess: false
      });
    if (u.matches({ authentication: "signedIn" }))
      return t({
        accessToken: u.context.accessToken.value,
        refreshToken: u.context.refreshToken.value,
        user: u.context.user,
        error: null,
        isError: false,
        isSuccess: true
      });
  });
});
var fr = async ({ backendUrl: s, interpreter: e }, { provider: r, idToken: n, nonce: t }) => {
  try {
    return await I(
      `${s}/link/idtoken`,
      { provider: r, idToken: n, ...t && { nonce: t } },
      e == null ? void 0 : e.getSnapshot().context.accessToken.value
    ), {
      isError: false,
      error: null,
      isSuccess: true
    };
  } catch (i) {
    const { error: u } = i;
    return { isError: true, error: u, isSuccess: false };
  }
};
var hr = (s) => new Promise((e) => {
  const { changed: r, context: n } = s.send({ type: "SIGNIN_SECURITY_KEY" });
  if (!r)
    return e({
      accessToken: n.accessToken.value,
      refreshToken: n.refreshToken.value,
      error: k,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: n.user
    });
  s.onTransition((t) => {
    t.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? e({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : t.matches({ authentication: { signedOut: "failed" } }) ? e({
      accessToken: null,
      refreshToken: null,
      error: t.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : t.matches({ authentication: "signedIn" }) && e({
      accessToken: t.context.accessToken.value,
      refreshToken: t.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: t.context.user
    });
  });
});
var mr = async ({ backendUrl: s, interpreter: e }, { expiresAt: r, metadata: n }) => {
  try {
    const { data: t } = await I(
      `${s}/pat`,
      { expiresAt: r.toISOString(), metadata: n },
      e == null ? void 0 : e.getSnapshot().context.accessToken.value
    );
    return {
      data: t ? {
        id: t.id || null,
        personalAccessToken: t.personalAccessToken || null
      } : null,
      isError: false,
      error: null,
      isSuccess: true
    };
  } catch (t) {
    const { error: i } = t;
    return { isError: true, error: i, isSuccess: false, data: null };
  }
};
var Rr = class {
  constructor({
    url: e,
    broadcastKey: r,
    autoRefreshToken: n = true,
    autoSignIn: t = true,
    clientStorage: i,
    clientStorageType: u,
    refreshIntervalTime: f4,
    start: d = true
  }) {
    var h;
    this.url = e, this._client = new Ee({
      backendUrl: e,
      clientUrl: typeof window != "undefined" && ((h = window.location) == null ? void 0 : h.origin) || "",
      broadcastKey: r,
      autoRefreshToken: n,
      autoSignIn: t,
      start: d,
      clientStorage: i,
      clientStorageType: u,
      refreshIntervalTime: f4
    });
  }
  /**
   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.
   *
   * @example
   * ### Sign up with an email and password
   * ```ts
   * nhost.auth.signUp({
   *   email: 'joe@example.com',
   *   password: 'secret-password'
   * })
   * ```
   *
   * @example
   * ### Sign up with a security key
   * ```ts
   * nhost.auth.signUp({
   *   email: 'joe@example.com',
   *   securityKey: true
   * })
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up
   */
  async signUp(e, r) {
    const n = await this.waitUntilReady();
    if ("securityKey" in e) {
      const { email: f4, options: d } = e;
      return A(
        await cr(n, f4, d, r)
      );
    }
    const { email: t, password: i, options: u } = e;
    return A(
      await te(n, t, i, u, r)
    );
  }
  /**
   * Use `nhost.auth.connectProvider` to connect a social authentication provider to an existing user account
   *
   * @example
   * ### Connect an authentication provider to an existing user account
   * ```ts
   * nhost.auth.connectProvider({
   *   provider: 'github
   *   options: {
   *    redirectTo: window.location.href
   *   }
   * })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/connect-provider
   */
  async connectProvider(e) {
    const n = (await this.waitUntilReady()).getSnapshot().context.accessToken.value, { provider: t, options: i } = e, u = F(
      `${this._client.backendUrl}/signin/provider/${t}`,
      S(this._client.clientUrl, {
        ...i,
        connect: n
      })
    );
    return L() && (window.location.href = u), { providerUrl: u };
  }
  /**
   * Use `nhost.auth.signInIdToken` to sign in a user with the provider's account using an ID token
   *
   * @example
   * ### Sign in a user with an id token
   * ```ts
   * nhost.auth.signInIdToken({
   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.
   *   idToken: '...', // The ID token issued by the provider.
   *   nonce: '...', // Optional: The nonce used during token generation.
   * });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-idtoken
   */
  async signInIdToken(e) {
    const r = await this.waitUntilReady(), n = await dr(r, e);
    return { ...A(n), mfa: null };
  }
  /**
   * Use `nhost.auth.linkIdToken` to link a user account with the provider's account using an ID token
   *
   * @example
   * ### Link a user account with the provider's account using an id token
   * ```ts
   * nhost.auth.linkIdToken({
   *   provider: 'google', // The provider name, e.g., 'google', 'apple', etc.
   *   idToken: '...', // The ID token issued by the provider.
   *   nonce: '...', // Optional: The nonce used during token generation.
   * })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/link-idtoken
   */
  async linkIdToken(e) {
    return fr(this._client, e);
  }
  /**
   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.
   *
   * @example
   * ### Sign in a user using email and password
   * ```ts
   * nhost.auth.signIn({
   *   email: 'joe@example.com',
   *   password: 'secret-password'
   * })
   * ```
   *
   * @example
   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)
   * ```ts
   * nhost.auth.signIn({ provider: 'google' })
   * ```
   *
   * @example
   * ### Sign in a user using passwordless email (Magic Link)
   * ```ts
   * nhost.auth.signIn({ email: 'joe@example.com' })
   * ```
   *
   * @example
   * ### Sign in a user using passwordless SMS
   * ```ts
   * // [step 1/2] Passwordless sign in using SMS
   * nhost.auth.signIn({ phoneNumber: '+11233213123' })
   *
   * // [step 2/2] Finish passwordless sign in using SMS (OTP)
   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })
   * ```
   *
   * @example
   * ### Sign in anonymously
   * ```ts
   * // Sign in anonymously
   * nhost.auth.signIn()
   *
   * // Later in the application, the user can complete their registration
   * nhost.auth.signUp({
   *   email: 'joe@example.com',
   *   password: 'secret-password'
   * })
   * ```
   *
   * @example
   * ### Sign in with a security key
   * ```ts
   * nhost.auth.signIn({
   *   email: 'joe@example.com',
   *   securityKey: true
   * })
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in
   */
  async signIn(e) {
    const r = await this.waitUntilReady();
    if (!e) {
      const n = await er(r);
      return { ...A(n), mfa: null };
    }
    if ("provider" in e) {
      const { provider: n, options: t } = e, i = F(
        `${this._client.backendUrl}/signin/provider/${n}`,
        S(this._client.clientUrl, t)
      );
      return L() && (window.location.href = i), { providerUrl: i, provider: n, session: null, mfa: null, error: null };
    }
    if ("email" in e && "password" in e) {
      const n = await rr(r, e.email, e.password);
      return n.needsEmailVerification ? { session: null, mfa: null, error: ve } : n.needsMfaOtp ? {
        session: null,
        mfa: n.mfa,
        error: null
      } : { ...A(n), mfa: null };
    }
    if ("email" in e && "securityKey" in e) {
      if (e.securityKey !== true)
        throw Error("securityKey must be true");
      const n = await nr(r, e.email);
      return { ...A(n), mfa: null };
    }
    if ("email" in e) {
      const { email: n, options: t } = e, { error: i } = await re(r, n, t);
      return {
        session: null,
        mfa: null,
        error: i
      };
    }
    if ("phoneNumber" in e && "otp" in e) {
      const n = await or(r, e.phoneNumber, e.otp);
      return { ...A(n), mfa: null };
    }
    if ("phoneNumber" in e) {
      const { error: n } = await se(
        r,
        e.phoneNumber,
        e.options
      );
      return { error: n, mfa: null, session: null };
    }
    if ("otp" in e) {
      const n = await tr(r, e.otp, e.ticket);
      return { ...A(n), mfa: null };
    }
    return { error: Oe, mfa: null, session: null };
  }
  /**
   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).
   *
   * @example
   * ```ts
   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat
   *
   * @param personalAccessToken - The personal access token to sign in with
   */
  async signInPAT(e) {
    const r = await this.waitUntilReady(), n = await ir(r, e);
    return A(n);
  }
  /**
   * Use `nhost.auth.signInEmailOTP` to sign in with an email one-time password (OTP).
   *
   * @example
   * ```ts
   * nhost.auth.signInEmailOTP('user@example.com')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-email-otp
   *
   * @param email - The email address to send the OTP to
   */
  async signInEmailOTP(e, r) {
    const n = await this.waitUntilReady(), { error: t } = await ur(n, e, r);
    return {
      error: t,
      session: null,
      mfa: null
    };
  }
  /**
   * Use `nhost.auth.verifyEmailOTP` to verify an email one-time password (OTP) and complete the sign-in process
   *
   * @example
   * ```ts
   * nhost.auth.verifyEmailOTP('user@example.com', '123456')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/verify-email-otp
   *
   * @param email - The email address to verify the OTP for
   * @param otp - The one-time password sent to the email address
   */
  async verifyEmailOTP(e, r) {
    const n = await this.waitUntilReady(), t = await lr(n, e, r);
    return { ...A(t), mfa: null };
  }
  /**
   * Use `nhost.auth.signInSecurityKey` to sign in a user with a security key using the WebAuthn API
   *
   * @example
   * ```ts
   * nhost.auth.signInSecurityKey()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-security-key
   */
  async signInSecurityKey() {
    const e = await this.waitUntilReady(), r = await hr(e);
    return { ...A(r), mfa: null };
  }
  /**
   * Use `nhost.auth.signOut` to sign out the user.
   *
   * @example
   * ### Sign out the user from current device
   * ```ts
   * nhost.auth.signOut()
   * ```
   *
   * @example
   * ### Sign out the user from all devices
   * ```ts
   * nhost.auth.signOut({all: true})
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out
   */
  async signOut(e) {
    const r = await this.waitUntilReady(), { error: n } = await ar(r, e == null ? void 0 : e.all);
    return { error: n };
  }
  /**
   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.
   *
   * @example
   * ```ts
   * nhost.auth.resetPassword({email: 'joe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password
   */
  async resetPassword({ email: e, options: r }) {
    const n = interpret(Fe(this._client)).start(), { error: t } = await Ze(n, e, r);
    return { error: t };
  }
  /**
   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.
   *
   * @example
   * ```ts
   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/change-password
   */
  async changePassword({
    newPassword: e,
    ticket: r
  }) {
    const n = interpret(je(this._client)).start(), { error: t } = await Xe(n, e, r);
    return { error: t };
  }
  /**
   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.
   *
   * @example
   * ```ts
   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email
   */
  async sendVerificationEmail({
    email: e,
    options: r
  }) {
    const n = interpret(Be(this._client)).start(), { error: t } = await Je(n, e, r);
    return { error: t };
  }
  /**
   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.
   *
   * @example
   * ```ts
   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/change-email
   */
  async changeEmail({ newEmail: e, options: r }) {
    const n = interpret(Ye(this._client)).start(), { error: t } = await Qe(n, e, r);
    return { error: t };
  }
  /**
   * Use `nhost.auth.deanonymize` to deanonymize a user.
   *
   * @example
   * ```ts
   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize
   */
  async deanonymize(e) {
    const r = await this.waitUntilReady();
    if (e.signInMethod === "passwordless") {
      if (e.connection === "email") {
        const { error: n } = await re(
          r,
          e.email,
          e.options
        );
        return { error: n };
      }
      if (e.connection === "sms") {
        const { error: n } = await se(
          r,
          e.phoneNumber,
          e.options
        );
        return { error: n };
      }
    }
    if (e.signInMethod === "email-password") {
      const { error: n } = await te(
        r,
        e.email,
        e.password,
        e.options
      );
      return { error: n };
    }
    throw Error("Unknown deanonymization method");
  }
  /**
   * Use `nhost.auth.addSecurityKey` to add a security key to the user, using the WebAuthn API.
   * @param nickname optional human-readable nickname for the security key
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key
   */
  async addSecurityKey(e) {
    const { error: r, key: n } = await ze(this._client, e);
    return { error: r, key: n };
  }
  /**
   * Use `nhost.auth.elevateEmailSecurityKey` to get a temporary elevated auth permissions to run sensitive operations.
   * @param email user email
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/elevate-email-security-key
   */
  async elevateEmailSecurityKey(e) {
    if (!e)
      throw Error("A user email is required");
    return { ...await sr(this._client, e), mfa: null };
  }
  /**
   * Use `nhost.auth.createPAT` to create a personal access token for the user.
   *
   * @param expiresAt Expiration date for the token
   * @param metadata Optional metadata to store with the token
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat
   */
  async createPAT(e, r) {
    return mr(this._client, { expiresAt: e, metadata: r });
  }
  /**
   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.
   *
   *
   * @example
   * ```ts
   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed
   */
  onTokenChanged(e) {
    return this._client.subscribe(() => {
      var n;
      const r = (n = this._client.interpreter) == null ? void 0 : n.onTransition(({ event: t, context: i }) => {
        t.type === "TOKEN_CHANGED" && e(M(i));
      });
      return () => r == null ? void 0 : r.stop();
    });
  }
  /**
   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.
   *
   * @example
   * ```ts
   * nhost.auth.onAuthStateChanged((event, session) => {
   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)
   * });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed
   */
  onAuthStateChanged(e) {
    return this._client.subscribe(() => {
      var n;
      const r = (n = this._client.interpreter) == null ? void 0 : n.onTransition(({ event: t, context: i }) => {
        (t.type === "SIGNED_IN" || t.type === "SIGNED_OUT") && e(t.type, M(i));
      });
      return () => r == null ? void 0 : r.stop();
    });
  }
  /**
   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.
   *
   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:
   * 1. The user is not authenticated
   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.
   *
   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.
   *
   * @example
   * ```ts
   * const isAuthenticated = nhost.auth.isAuthenticated();
   *
   * if (isAuthenticated) {
   *   console.log('User is authenticated');
   * }
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated
   */
  isAuthenticated() {
    var e;
    return !!((e = this._client.interpreter) != null && e.getSnapshot().matches({ authentication: "signedIn" }));
  }
  /**
   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.
   *
   * The promise won't resolve until the authentication status is known.
   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.
   *
   * @example
   * ```ts
   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();
   *
   * if (isAuthenticated) {
   *   console.log('User is authenticated');
   * }
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async
   */
  async isAuthenticatedAsync() {
    return (await this.waitUntilReady()).getSnapshot().matches({ authentication: "signedIn" });
  }
  /**
   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.
   *
   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not
   * because some internal authentication network requests have not been resolved yet.
   *
   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).
   *
   * @example
   * ```ts
   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();
   *
   * if (isLoading) {
   *   console.log('Loading...')
   * }
   *
   * if (isAuthenticated) {
   *   console.log('User is authenticated');
   * }
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status
   */
  getAuthenticationStatus() {
    var r;
    const e = ((r = this.client.interpreter) == null ? void 0 : r.getSnapshot().context.importTokenAttempts) || 0;
    return this.isReady() ? { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts: e } : {
      isAuthenticated: false,
      isLoading: true,
      connectionAttempts: e
    };
  }
  /**
   * Use `nhost.auth.getAccessToken` to get the access token of the user.
   *
   * @example
   * ```ts
   * const accessToken = nhost.auth.getAccessToken();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token
   */
  getAccessToken() {
    var e, r;
    return (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot().context.accessToken.value) != null ? r : void 0;
  }
  /**
   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.
   *
   * @example
   * ```ts
   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token
   */
  getDecodedAccessToken() {
    const e = this.getAccessToken();
    return e ? jwtDecode(e) : null;
  }
  /**
   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.
   *
   * @example
   * ```ts
   * const hasuraClaims = nhost.auth.getHasuraClaims();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims
   */
  getHasuraClaims() {
    var e;
    return ((e = this.getDecodedAccessToken()) == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
  }
  /**
   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.
   *
   * @example
   * ```ts
   * // if `x-hasura-company-id` exists as a custom claim
   * const companyId = nhost.auth.getHasuraClaim('company-id')
   * ```
   *
   * @param name Name of the variable. You don't have to specify `x-hasura-`.
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim
   */
  getHasuraClaim(e) {
    var r;
    return ((r = this.getHasuraClaims()) == null ? void 0 : r[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
  }
  /**
   *
   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.
   *
   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.
   *
   * @example
   * ```ts
   * // Refresh the session with the the current internal refresh token.
   * nhost.auth.refreshSession();
   *
   * // Refresh the session with an external refresh token.
   * nhost.auth.refreshSession(refreshToken);
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session
   */
  async refreshSession(e) {
    try {
      const r = await this.waitUntilReady();
      return new Promise((n) => {
        const t = e || r.getSnapshot().context.refreshToken.value;
        if (!t)
          return n({ session: null, error: Ae });
        const { changed: i } = r.send("TRY_TOKEN", { token: t });
        if (!i)
          return n({ session: null, error: Re });
        r.onTransition((u) => {
          u.matches({ token: { idle: "error" } }) ? n({
            session: null,
            // * TODO get the error from xstate once it is implemented
            error: Pe
          }) : u.event.type === "TOKEN_CHANGED" && n({ session: M(u.context), error: null });
        });
      });
    } catch (r) {
      return { session: null, error: r.message };
    }
  }
  /**
   *
   * Use `nhost.auth.getSession()` to get the session of the user.
   *
   * @example
   * ```ts
   * const session = nhost.auth.getSession();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-session
   */
  getSession() {
    var e, r;
    return M((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context);
  }
  /**
   * Initialize the auth client with an existing session
   *
   * @example
   * ### Initialize with an existing Nhost session
   * ```ts
   * await nhost.auth.initWithSession({ session: initialSession })
   * ```
   *
   * @param session - The Nhost session object to initialize the client with
   * @docs https://docs.nhost.io/reference/javascript/auth/init-with-session
   */
  async initWithSession({ session: e }) {
    this.client.start({ initialSession: e }), await this.waitUntilReady();
  }
  /**
   *
   * Use `nhost.auth.getUser()` to get the signed-in user.
   *
   * @example
   * ```ts
   * const user = nhost.auth.getUser();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-user
   */
  getUser() {
    var e, r, n;
    return ((n = (r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) == null ? void 0 : r.context) == null ? void 0 : n.user) || null;
  }
  /**
   * Make sure the state machine is set, and wait for it to be ready
   * @returns
   */
  waitUntilReady() {
    const r = this._client.interpreter;
    if (!r)
      throw Error("Auth interpreter not set");
    return r.getSnapshot().hasTag("loading") ? new Promise((n, t) => {
      let i = setTimeout(
        () => t("The state machine is not yet ready after 15 seconds."),
        15e3
      );
      r.onTransition((u) => {
        if (!u.hasTag("loading"))
          return clearTimeout(i), n(r);
      });
    }) : Promise.resolve(r);
  }
  isReady() {
    var e, r;
    return !((r = (e = this._client.interpreter) == null ? void 0 : e.getSnapshot()) != null && r.hasTag("loading"));
  }
  get client() {
    return this._client;
  }
};

// node_modules/@nhost/react/node_modules/@nhost/hasura-storage-js/dist/index.esm.js
var import_fetch_ponyfill2 = __toESM(require_fetch_browser());
var import_form_data = __toESM(require_browser());
var C = Object.defineProperty;
var $2 = (t, e, r) => e in t ? C(t, e, { enumerable: true, configurable: true, writable: true, value: r }) : t[e] = r;
var f = (t, e, r) => $2(t, typeof e != "symbol" ? e + "" : e, r);
var k2 = globalThis.fetch;
var E = async (t, e, {
  accessToken: r,
  name: s,
  fileId: a2,
  bucketId: i,
  adminSecret: o,
  onUploadProgress: d,
  headers: l = {}
} = {}) => {
  var L3;
  const h = {
    ...l
  };
  i && e.append("bucket-id", i), o && (h["x-hasura-admin-secret"] = o), r && (h.Authorization = `Bearer ${r}`);
  const T3 = `${t}/files`;
  if (typeof XMLHttpRequest == "undefined")
    try {
      e instanceof import_form_data.default && (k2 = (0, import_fetch_ponyfill2.default)().fetch);
      const u = await k2(T3, {
        method: "POST",
        headers: h,
        body: e
        // * https://github.com/form-data/form-data/issues/513
      }), n = await u.json();
      return u.ok ? { fileMetadata: n, error: null } : { error: {
        status: u.status,
        message: ((L3 = n == null ? void 0 : n.error) == null ? void 0 : L3.message) || u.statusText,
        // * errors from hasura-storage are not codified
        error: u.statusText
      }, fileMetadata: null };
    } catch (u) {
      return { error: {
        status: 0,
        message: u.message,
        error: u.message
      }, fileMetadata: null };
    }
  return new Promise((u) => {
    let n = new XMLHttpRequest();
    n.responseType = "json", n.onload = () => {
      var p4, g2, S3, F2, R2, _3, x5, I3;
      if (n.status < 200 || n.status >= 300) {
        const b2 = {
          error: (R2 = (F2 = (g2 = (p4 = n.response) == null ? void 0 : p4.error) == null ? void 0 : g2.message) != null ? F2 : (S3 = n.response) == null ? void 0 : S3.error) != null ? R2 : n.response,
          message: (I3 = (x5 = (_3 = n.response) == null ? void 0 : _3.error) == null ? void 0 : x5.message) != null ? I3 : n.response,
          status: n.status
        };
        return u({
          fileMetadata: null,
          error: b2
        });
      }
      return u({ fileMetadata: n.response, error: null });
    }, n.onerror = () => {
      const p4 = {
        error: n.statusText,
        message: n.statusText,
        status: n.status
      };
      return u({
        fileMetadata: null,
        error: p4
      });
    }, d && n.upload.addEventListener("progress", d, false), n.open("POST", T3, true), Object.entries(h).forEach(([p4, g2]) => {
      n.setRequestHeader(p4, g2);
    }), n.send(e);
  });
};
function D2(t, e) {
  if (!e || Object.keys(e).length === 0)
    return t;
  const r = new URL(t), s = Object.entries(e).reduce(
    (a2, [i, o]) => ({ ...a2, [i.charAt(0)]: o }),
    {}
  );
  return Object.entries(s).forEach(([a2, i]) => {
    i && r.searchParams.set(a2, i);
  }), r.toString();
}
var m;
typeof m == "undefined" && (m = (0, import_fetch_ponyfill2.default)().fetch);
var z = class {
  constructor({ url: e }) {
    f(this, "url");
    f(this, "accessToken");
    f(this, "adminSecret");
    f(this, "headers", {});
    this.url = e;
  }
  async uploadFormData({
    formData: e,
    bucketId: r,
    headers: s
  }) {
    const { error: a2, fileMetadata: i } = await E(this.url, e, {
      bucketId: r,
      headers: {
        ...this.headers,
        // global nhost storage client headers to be sent with all `uploadFormData` calls
        ...s
        // extra headers to be sent with a specific call
      },
      accessToken: this.accessToken,
      adminSecret: this.adminSecret
    });
    return a2 ? { fileMetadata: null, error: a2 } : i && !("processedFiles" in i) ? {
      fileMetadata: {
        processedFiles: [i]
      },
      error: null
    } : { fileMetadata: i, error: null };
  }
  async uploadFile({
    file: e,
    bucketId: r,
    id: s,
    name: a2,
    headers: i
  }) {
    const o = typeof window == "undefined" ? new import_form_data.default() : new FormData();
    o.append("file[]", e), o.append("metadata[]", JSON.stringify({ id: s, name: a2 }));
    const { error: d, fileMetadata: l } = await E(this.url, o, {
      accessToken: this.accessToken,
      adminSecret: this.adminSecret,
      bucketId: r,
      fileId: s,
      name: a2,
      headers: {
        ...this.headers,
        // global nhost storage client headers to be sent with all `uploadFile` calls
        ...i
        // extra headers to be sent with a specific call
      }
    });
    return d ? { fileMetadata: null, error: d } : l && "processedFiles" in l ? {
      fileMetadata: l.processedFiles[0],
      error: null
    } : { fileMetadata: l, error: null };
  }
  async downloadFile(e) {
    try {
      const { fileId: r, headers: s, ...a2 } = e, i = D2(
        `${this.url}/files/${r}`,
        a2
      ), o = await m(i, {
        method: "GET",
        headers: {
          ...this.generateAuthHeaders(),
          ...this.headers,
          // global nhost storage client headers to be sent with all `downloadFile` calls
          ...s
          // extra headers to be sent with a specific call
        }
      });
      if (!o.ok)
        throw new Error(await o.text());
      return { file: await o.blob(), error: null };
    } catch (r) {
      return { file: null, error: r };
    }
  }
  async getPresignedUrl(e) {
    try {
      const { fileId: r, headers: s } = e, a2 = await m(`${this.url}/files/${r}/presignedurl`, {
        method: "GET",
        headers: {
          ...this.generateAuthHeaders(),
          ...this.headers,
          // global nhost storage client headers to be sent with all `getPresignedUrl` calls
          ...s
          // extra headers to be sent with a specific call
        }
      });
      if (!a2.ok)
        throw new Error(await a2.text());
      return { presignedUrl: await a2.json(), error: null };
    } catch (r) {
      return { presignedUrl: null, error: r };
    }
  }
  async delete(e) {
    try {
      const { fileId: r, headers: s } = e, a2 = await m(`${this.url}/files/${r}`, {
        method: "DELETE",
        headers: {
          ...this.generateAuthHeaders(),
          ...this.headers,
          // global nhost storage client headers to be sent with all `delete` calls
          ...s
          // extra headers to be sent with a specific call
        }
      });
      if (!a2.ok)
        throw new Error(await a2.text());
      return { error: null };
    } catch (r) {
      return { error: r };
    }
  }
  /**
   * Set the access token to use for authentication.
   *
   * @param accessToken Access token
   * @returns Hasura Storage API instance
   */
  setAccessToken(e) {
    return this.accessToken = e, this;
  }
  /**
   * Set the admin secret to use for authentication.
   *
   * @param adminSecret Hasura admin secret
   * @returns Hasura Storage API instance
   */
  setAdminSecret(e) {
    return this.adminSecret = e, this;
  }
  /**
   * Get global headers sent with all requests.
   *
   * @returns Record<string, string>
   */
  getHeaders() {
    return this.headers;
  }
  /**
   * Set global headers to be sent with all requests.
   *
   * @param headers a key value pair headers object
   * @returns Hasura Storage API instance
   */
  setHeaders(e) {
    return e ? (this.headers = {
      ...this.headers,
      ...e
    }, this) : this;
  }
  /**
   * Remove global headers sent with all requests, except for the role header to preserve
   * the role set by 'setRole' method.
   *
   * @returns {HasuraStorageApi} - Hasura Storage API instance.
   */
  unsetHeaders() {
    const e = this.headers["x-hasura-role"];
    return this.headers = e ? { "x-hasura-role": e } : {}, this;
  }
  generateAuthHeaders() {
    if (!(!this.adminSecret && !this.accessToken))
      return this.adminSecret ? {
        "x-hasura-admin-secret": this.adminSecret
      } : {
        Authorization: `Bearer ${this.accessToken}`
      };
  }
};
var W2 = class {
  constructor({ url: e, adminSecret: r }) {
    f(this, "url");
    f(this, "api");
    this.url = e, this.api = new z({ url: e }), this.setAdminSecret(r);
  }
  async upload(e) {
    return "file" in e ? this.api.uploadFile(e) : this.api.uploadFormData(e);
  }
  /**
   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url
   */
  getPublicUrl(e) {
    const { fileId: r, ...s } = e;
    return D2(
      `${this.url}/files/${r}`,
      s
    );
  }
  /**
   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })
   *
   * if (error) {
   *   throw error;
   * }
   *
   * console.log('url: ', presignedUrl.url)
   * console.log('expiration: ', presignedUrl.expiration)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url
   */
  async getPresignedUrl(e) {
    const { fileId: r, headers: s, ...a2 } = e, { presignedUrl: i, error: o } = await this.api.getPresignedUrl(e);
    if (o)
      return { presignedUrl: null, error: o };
    if (!i)
      return { presignedUrl: null, error: new Error("Invalid file id") };
    const d = D2(
      i.url,
      a2
    );
    return {
      presignedUrl: {
        ...i,
        url: d
      },
      error: null
    };
  }
  /**
   * Use `nhost.storage.download` to download a file. To download a file the user must have permission to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const { file, error} = await nhost.storage.download({ fileId: '<File-ID>' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/download
   */
  async download(e) {
    const { file: r, error: s } = await this.api.downloadFile(e);
    return s ? { file: null, error: s } : r ? {
      file: r,
      error: null
    } : { file: null, error: new Error("File does not exist") };
  }
  /**
   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.
   *
   * @example
   * ```ts
   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/delete
   */
  async delete(e) {
    const { error: r } = await this.api.delete(e);
    return r ? { error: r } : { error: null };
  }
  /**
   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.storage.setAccessToken('some-access-token')
   * ```
   *
   * @param accessToken Access token
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token
   */
  setAccessToken(e) {
    return this.api.setAccessToken(e), this;
  }
  /**
   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in "admin mode".
   *
   * @example
   * ```ts
   * nhost.storage.setAdminSecret('some-admin-secret')
   * ```
   *
   * @param adminSecret Hasura admin secret
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret
   */
  setAdminSecret(e) {
    return this.api.setAdminSecret(e), this;
  }
  /**
   * Use `nhost.storage.getHeaders` to get global headers sent with all storage requests.
   *
   * @example
   * ```ts
   * nhost.storage.getHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-headers
   */
  getHeaders() {
    return this.api.getHeaders();
  }
  /**
   * Use `nhost.storage.setHeaders` to set global headers to be sent for all subsequent storage requests.
   *
   * @example
   * ```ts
   * nhost.storage.setHeaders({
   *  'x-hasura-role': 'admin'
   * })
   * ```
   *
   * @param headers key value headers object
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-headers
   */
  setHeaders(e) {
    return this.api.setHeaders(e), this;
  }
  /**
   * Use `nhost.storage.unsetHeaders` to remove the global headers sent for all subsequent storage requests.
   *
   * @example
   * ```ts
   * nhost.storage.unsetHeaders()
   * ```
   *
   * @param headers key value headers object
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/unset-headers
   */
  unsetHeaders() {
    return this.api.unsetHeaders(), this;
  }
};
var O2;
typeof O2 == "undefined" && (O2 = import_form_data.default);
var U2 = {
  progress: null,
  loaded: 0,
  error: null,
  bucketId: void 0,
  file: void 0,
  id: void 0
};
var G2 = () => createMachine(
  {
    predictableActionArguments: true,
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    context: { ...U2 },
    initial: "idle",
    on: {
      DESTROY: { actions: "sendDestroy", target: "stopped" }
    },
    states: {
      idle: {
        on: {
          ADD: { actions: "addFile" },
          UPLOAD: { cond: "hasFile", target: "uploading" }
        }
      },
      uploading: {
        entry: "resetProgress",
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress", "sendProgress"] },
          UPLOAD_DONE: "uploaded",
          UPLOAD_ERROR: "error",
          CANCEL: "idle"
        },
        invoke: { src: "uploadFile" }
      },
      uploaded: {
        entry: ["setFileMetadata", "sendDone"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      error: {
        entry: ["setError", "sendError"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      stopped: { type: "final" }
    }
  },
  {
    guards: {
      hasFile: (t, e) => !!t.file || !!e.file
    },
    actions: {
      incrementProgress: assign({
        loaded: (t, { loaded: e }) => e,
        progress: (t, { progress: e }) => e
      }),
      setFileMetadata: assign({
        id: (t, { id: e }) => e,
        bucketId: (t, { bucketId: e }) => e,
        progress: (t) => 100
      }),
      setError: assign({ error: (t, { error: e }) => e }),
      sendProgress: () => {
      },
      sendError: () => {
      },
      sendDestroy: () => {
      },
      sendDone: () => {
      },
      resetProgress: assign({ progress: (t) => null, loaded: (t) => 0 }),
      resetContext: assign((t) => U2),
      addFile: assign({
        file: (t, { file: e }) => e,
        bucketId: (t, { bucketId: e }) => e,
        id: (t, { id: e }) => e
      })
    },
    services: {
      uploadFile: (t, e) => (r) => {
        const s = e.file || t.file, a2 = new O2();
        a2.append("file[]", s);
        let i = 0;
        return E(e.url, a2, {
          fileId: e.id || t.id,
          bucketId: e.bucketId || t.bucketId,
          accessToken: e.accessToken,
          adminSecret: e.adminSecret,
          name: e.name || s.name,
          onUploadProgress: (o) => {
            const d = o.total ? Math.round(o.loaded * s.size / o.total) : 0, l = d - i;
            i = d, r({
              type: "UPLOAD_PROGRESS",
              progress: o.total ? Math.round(d * 100 / o.total) : 0,
              loaded: d,
              additions: l
            });
          }
        }).then(({ fileMetadata: o, error: d }) => {
          if (d && r({ type: "UPLOAD_ERROR", error: d }), o && !("processedFiles" in o)) {
            const { id: l, bucketId: h } = o;
            r({ type: "UPLOAD_DONE", id: l, bucketId: h });
          }
          if (o && "processedFiles" in o) {
            const { id: l, bucketId: h } = o.processedFiles[0];
            r({ type: "UPLOAD_DONE", id: l, bucketId: h });
          }
        }), () => {
        };
      }
    }
  }
);
var { pure: y, sendParent: A2 } = actions_exports;
var Y2 = () => createMachine(
  {
    id: "files-list",
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    context: {
      progress: null,
      files: [],
      loaded: 0,
      total: 0
    },
    initial: "idle",
    on: {
      UPLOAD: { cond: "hasFileToDownload", actions: "addItem", target: "uploading" },
      ADD: { actions: "addItem" },
      REMOVE: { actions: "removeItem" }
    },
    states: {
      idle: {
        entry: ["resetProgress", "resetLoaded", "resetTotal"],
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      uploading: {
        entry: ["upload", "startProgress", "resetLoaded", "resetTotal"],
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress"] },
          UPLOAD_DONE: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          UPLOAD_ERROR: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          CANCEL: { actions: "cancel", target: "idle" }
        }
      },
      uploaded: {
        entry: "setUploaded",
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      error: {
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      }
    }
  },
  {
    guards: {
      hasFileToDownload: (t, e) => t.files.some((r) => r.getSnapshot().matches("idle")) || !!e.files,
      isAllUploaded: (t) => t.files.every((e) => {
        var r;
        return (r = e.getSnapshot()) == null ? void 0 : r.matches("uploaded");
      }),
      isAllUploadedOrError: (t) => t.files.every((e) => {
        const r = e.getSnapshot();
        return (r == null ? void 0 : r.matches("error")) || (r == null ? void 0 : r.matches("uploaded"));
      })
    },
    actions: {
      incrementProgress: assign((t, e) => {
        const r = t.loaded + e.additions, s = Math.round(r * 100 / t.total);
        return { ...t, loaded: r, progress: s };
      }),
      setUploaded: assign({
        progress: (t) => 100,
        loaded: ({ files: t }) => t.map((e) => e.getSnapshot()).filter((e) => e.matches("uploaded")).reduce((e, r) => {
          var s;
          return e + ((s = r.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetTotal: assign({
        total: ({ files: t }) => t.map((e) => e.getSnapshot()).filter((e) => !e.matches("uploaded")).reduce((e, r) => {
          var s;
          return e + ((s = r.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetLoaded: assign({ loaded: (t) => 0 }),
      startProgress: assign({ progress: (t) => 0 }),
      resetProgress: assign({ progress: (t) => null }),
      addItem: assign((t, { files: e, bucketId: r }) => {
        const s = e ? Array.isArray(e) ? e : "item" in e ? Array.from(e) : [e] : [], a2 = t.total + s.reduce((o, d) => o + d.size, 0), i = Math.round(t.loaded * 100 / a2);
        return {
          files: [
            ...t.files,
            ...s.map(
              (o) => spawn(
                G2().withConfig({
                  actions: {
                    sendProgress: A2((d, { additions: l }) => ({
                      type: "UPLOAD_PROGRESS",
                      additions: l
                    })),
                    sendDone: A2("UPLOAD_DONE"),
                    sendError: A2("UPLOAD_ERROR"),
                    sendDestroy: A2("REMOVE")
                  }
                }).withContext({ ...U2, file: o, bucketId: r }),
                { sync: true }
              )
            )
          ],
          total: a2,
          loaded: t.loaded,
          progress: i
        };
      }),
      removeItem: assign({
        files: (t) => t.files.filter((e) => {
          var s, a2;
          const r = (s = e.getSnapshot()) == null ? void 0 : s.matches("stopped");
          return r && ((a2 = e.stop) == null || a2.call(e)), !r;
        })
      }),
      clearList: y(
        (t) => t.files.map((e) => send({ type: "DESTROY" }, { to: e.id }))
      ),
      upload: y((t, e) => t.files.map((r) => send(e, { to: r.id }))),
      cancel: y(
        (t) => t.files.map((e) => send({ type: "CANCEL" }, { to: e.id }))
      )
    }
  }
);
var J2 = async (t, e) => new Promise((r) => {
  e.send({
    type: "UPLOAD",
    ...t
  }), e.subscribe((s) => {
    var a2;
    s.matches("error") ? r({
      error: s.context.error,
      isError: true,
      isUploaded: false
    }) : s.matches("uploaded") && r({
      error: null,
      isError: false,
      isUploaded: true,
      id: s.context.id,
      bucketId: s.context.id,
      name: (a2 = s.context.file) == null ? void 0 : a2.name
    });
  });
});
var K2 = async (t, e) => new Promise((r) => {
  e.send({
    type: "UPLOAD",
    ...t,
    files: t.files
  }), e.onTransition((s) => {
    s.matches("error") ? r({
      errors: s.context.files.filter((a2) => {
        var i;
        return (i = a2.getSnapshot()) == null ? void 0 : i.context.error;
      }),
      isError: true,
      files: []
    }) : s.matches("uploaded") && r({ errors: [], isError: false, files: s.context.files });
  });
});

// node_modules/@nhost/react/node_modules/@nhost/nhost-js/dist/index.esm.js
var import_isomorphic_unfetch2 = __toESM(require_browser2());

// node_modules/@nhost/react/node_modules/@nhost/graphql-js/dist/index.esm.js
var import_isomorphic_unfetch = __toESM(require_browser2());

// node_modules/@nhost/react/node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 8,
  patch: 1,
  preReleaseTag: null
});

// node_modules/@nhost/react/node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/@nhost/react/node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/@nhost/react/node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_3, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/@nhost/react/node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/@nhost/react/node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/@nhost/react/node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/@nhost/react/node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/@nhost/react/node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/@nhost/react/node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/@nhost/react/node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/@nhost/react/node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/@nhost/react/node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken = readNextToken(this, token.end);
          token.next = nextToken;
          nextToken.prev = token;
          token = nextToken;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape.value;
      position += escape.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/instanceOf.mjs
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  globalThis.process && globalThis.process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/@nhost/react/node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/@nhost/react/node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x5) => `"${x5}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x5) {
  return x5;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn(map[key], key);
  }
  return result;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a2, b2) => {
    const distanceDiff = optionsByDistance[a2] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a2, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a2 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a2.length < b2.length) {
      const tmp = a2;
      a2 = b2;
      b2 = tmp;
    }
    const aLength = a2.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j2 = 0; j2 <= bLength; j2++) {
      rows[0][j2] = j2;
    }
    for (let i = 1; i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j2 = 1; j2 <= bLength; j2++) {
        const cost = a2[i - 1] === b2[j2 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j2] + 1,
          // delete
          currentRow[j2 - 1] + 1,
          // insert
          upRow[j2 - 1] + cost
          // substitute
        );
        if (i > 1 && j2 > 1 && a2[i - 1] === b2[j2 - 2] && a2[i - 2] === b2[j2 - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j2 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j2] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/@nhost/react/node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/@nhost/react/node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index2 = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index2++;
    const isLeaving = index2 === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index2 = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index2 : keys[index2];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index: index2,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index2 = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/@nhost/react/node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x5) => x5).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/@nhost/react/node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/@nhost/react/node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name.length; ++i) {
    if (!isNameContinue(name.charCodeAt(i))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/@nhost/react/node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config.values);
    this._valueLookup = new Map(
      this._values.map((enumValue) => [enumValue.value, enumValue])
    );
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name) {
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/@nhost/react/node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/@nhost/react/node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/@nhost/react/node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);

// node_modules/@nhost/react/node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/@nhost/react/node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/@nhost/react/node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => (
        /* c8 ignore next */
        "description" in type ? type.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/@nhost/react/node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/@nhost/react/node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x5) => x5.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _22, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i]
      );
      for (let j2 = i + 1; j2 < fragmentNames.length; j2++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i],
          fragmentNames[j2]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j2 = i + 1; j2 < fields.length; j2++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i],
            fields[j2]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a2, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a2 < b2 ? [a2, b2] : [b2, a2];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a2, b2, areMutuallyExclusive) {
    const [key1, key2] = a2 < b2 ? [a2, b2] : [b2, a2];
    const map = this._data.get(key1);
    if (map === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/@nhost/react/node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/@nhost/react/node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/@nhost/react/node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/@nhost/react/node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/@nhost/react/node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/@nhost/react/node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/@nhost/react/node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/@nhost/react/node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type) => type.name
);

// node_modules/@nhost/react/node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/@nhost/react/node_modules/@nhost/graphql-js/dist/index.esm.js
function g(r, e, s) {
  return r.document ? r : {
    document: r,
    variables: e,
    config: s
  };
}
function c(r) {
  var n;
  let e;
  const s = r.definitions.filter(
    (t) => t.kind === "OperationDefinition"
  );
  return s.length === 1 && (e = (n = s[0].name) == null ? void 0 : n.value), e;
}
function y2(r) {
  if (typeof r == "string") {
    let s;
    try {
      const n = parse(r);
      s = c(n);
    } catch {
    }
    return { query: r, operationName: s };
  }
  const e = c(r);
  return { query: print(r), operationName: e };
}
var x2 = class {
  constructor(e) {
    this.headers = {}, this.isAccessTokenValidOrNull = () => {
      if (!this.accessToken)
        return true;
      try {
        const t = jwtDecode(this.accessToken);
        return t.exp != null && t.exp * 1e3 > Date.now();
      } catch (t) {
        return console.error("Error decoding token:", t), false;
      }
    }, this.awaitForValidAccessTokenOrNull = async () => {
      if (this.isAccessTokenValidOrNull())
        return true;
      const t = () => this.isAccessTokenValidOrNull() ? Promise.resolve(true) : new Promise((i) => {
        setTimeout(() => t().then(i), 100);
      });
      return t();
    };
    const { url: s, adminSecret: n } = e;
    this._url = s, this.accessToken = null, this.adminSecret = n;
  }
  async request(e, ...s) {
    const [n, t] = s, i = g(e, n, t), { headers: l, ...h } = t || {}, { query: d, operationName: p4 } = y2(i.document);
    typeof process != "undefined" && !process.env.TEST_MODE && await this.awaitForValidAccessTokenOrNull();
    try {
      const a2 = await (0, import_isomorphic_unfetch.default)(this.httpUrl, {
        method: "POST",
        body: JSON.stringify({
          operationName: p4,
          query: d,
          variables: n
        }),
        headers: {
          "Content-Type": "application/json",
          ...this.generateAccessTokenHeaders(),
          ...this.headers,
          // graphql client headers to be sent with all `request` calls
          ...l
          // extra headers to be sent with a specific call
        },
        ...h
      });
      if (!a2.ok)
        return {
          data: null,
          error: {
            error: a2.statusText,
            message: a2.statusText,
            status: a2.status
          }
        };
      const { data: o, errors: u } = await a2.json();
      return u ? {
        data: null,
        error: u
      } : typeof o != "object" || Array.isArray(o) || o === null ? {
        data: null,
        error: {
          error: "invalid-response",
          message: "incorrect response data from GraphQL server",
          status: 0
        }
      } : { data: o, error: null };
    } catch (a2) {
      const o = a2;
      return {
        data: null,
        error: {
          message: o.message,
          status: o.name === "AbortError" ? 0 : 500,
          error: o.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  /**
   * Use `nhost.graphql.httpUrl` to get the GraphQL HTTP URL.
   * @example
   * ```ts
   * const url = nhost.graphql.httpUrl;
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/get-http-url
   */
  get httpUrl() {
    return this._url;
  }
  /**
   * Use `nhost.graphql.wsUrl` to get the GraphQL WebSocket URL.
   * @example
   * ```ts
   * const url = nhost.graphql.wsUrl;
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/get-ws-url
   */
  get wsUrl() {
    return this._url.replace(/^(http)(s?):\/\//, "ws$2://");
  }
  /**
   * Use `nhost.graphql.url` to get the GraphQL URL.
   * @deprecated Use `nhost.graphql.httpUrl` and `nhost.graphql.wsUrl` instead.
   */
  get url() {
    return this._url;
  }
  /**
   * Use `nhost.graphql.getUrl()` to get the GraphQL URL.
   * @deprecated Use `nhost.graphql.httpUrl` and `nhost.graphql.wsUrl` instead.
   */
  getUrl() {
    return this._url;
  }
  /**
   * Use `nhost.graphql.setAccessToken` to a set an access token to be used in subsequent graphql requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.graphql.setAccessToken('some-access-token')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/set-access-token
   */
  setAccessToken(e) {
    if (!e) {
      this.accessToken = null;
      return;
    }
    this.accessToken = e;
  }
  /**
   * Use `nhost.graphql.getHeaders` to get the global headers sent with all graphql requests
   *
   * @example
   * ```ts
   * nhost.graphql.getHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/get-headers
   */
  getHeaders() {
    return this.headers;
  }
  /**
   * Use `nhost.graphql.setHeaders` to set global headers to be sent in all subsequent graphql requests
   *
   * @example
   * ```ts
   * nhost.graphql.setHeaders({
   *  'x-hasura-role': 'admin'
   * })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/set-headers
   */
  setHeaders(e) {
    e && (this.headers = {
      ...this.headers,
      ...e
    });
  }
  /**
   * Use `nhost.graphql.unsetHeaders` to remove global headers sent with all requests, except for the role header to preserve
   * the role set by 'setRole' method.
   *
   * @example
   * ```ts
   * nhost.graphql.unsetHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/unset-headers
   */
  unsetHeaders() {
    const e = this.headers["x-hasura-role"];
    this.headers = e ? { "x-hasura-role": e } : {};
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
};

// node_modules/@nhost/react/node_modules/@nhost/nhost-js/dist/index.esm.js
var p2 = Object.defineProperty;
var T = (e, t, s) => t in e ? p2(e, t, { enumerable: true, configurable: true, writable: true, value: s }) : e[t] = s;
var a = (e, t, s) => T(e, typeof t != "symbol" ? t + "" : t, s);
var A3 = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function f3(e, t) {
  const { subdomain: s, region: o } = e;
  if (!s)
    throw new Error("A `subdomain` must be set.");
  const c2 = s.match(A3);
  if (c2 != null && c2.groups) {
    const { protocol: l, host: i, port: h } = c2.groups, r = x3(t);
    return r || (i === "localhost" ? (console.warn(
      'The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'
    ), `${l || "http"}://localhost:${h || 1337}/v1/${t}`) : h ? `${l || "https"}://local.${t}.local.nhost.run:${h}/v1` : `${l || "https"}://local.${t}.local.nhost.run/v1`);
  }
  if (!o)
    throw new Error('`region` must be set when using a `subdomain` other than "local".');
  return `https://${s}.${t}.${o}.nhost.run/v1`;
}
function S2() {
  return typeof window != "undefined";
}
function H() {
  return typeof process != "undefined" && process.env;
}
function x3(e) {
  return S2() || !H() ? null : process.env[`NHOST_${e.toUpperCase()}_URL`];
}
function U3(e, t) {
  const o = t.startsWith("/") ? t : `/${t}`;
  return e + o;
}
function $3(e) {
  const t = "subdomain" in e ? f3(e, "auth") : e.authUrl, { subdomain: s, region: o } = e;
  if (!t)
    throw new Error("Please provide `subdomain` or `authUrl`.");
  return new Rr({
    url: t,
    broadcastKey: `${s}${o != null ? o : "local"}`,
    ...e
  });
}
function v2(e) {
  const t = "subdomain" in e ? f3(e, "functions") : e.functionsUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `functionsUrl`.");
  return new C2({ url: t, ...e });
}
var C2 = class {
  constructor(t) {
    a(this, "url");
    a(this, "accessToken");
    a(this, "adminSecret");
    a(this, "headers", {});
    const { url: s, adminSecret: o } = t;
    this.url = s, this.accessToken = null, this.adminSecret = o;
  }
  /**
   * Use `nhost.functions.call` to call (sending a POST request to) a serverless function. Use generic
   * types to specify the expected response data, request body and error message.
   *
   * @example
   * ### Without generic types
   * ```ts
   * await nhost.functions.call('send-welcome-email', { email: 'joe@example.com', name: 'Joe Doe' })
   * ```
   *
   * @example
   * ### Using generic types
   * ```ts
   * type Data = {
   *   message: string
   * }
   *
   * type Body = {
   *   email: string
   *   name: string
   * }
   *
   * type ErrorMessage = {
   *   details: string
   * }
   *
   * // The function will only accept a body of type `Body`
   * const { res, error } = await nhost.functions.call<Data, Body, ErrorMessage>(
   *   'send-welcome-email',
   *   { email: 'joe@example.com', name: 'Joe Doe' }
   * )
   *
   * // Now the response data is typed as `Data`
   * console.log(res?.data.message)
   *
   * // Now the error message is typed as `ErrorMessage`
   * console.log(error?.message.details)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/call
   */
  async call(t, s, o) {
    var i, h;
    const c2 = {
      "Content-Type": "application/json",
      ...this.generateAccessTokenHeaders(),
      ...o == null ? void 0 : o.headers,
      ...this.headers
      // nhost functions client headers to be sent with all calls
    }, l = U3(this.url, t);
    try {
      const r = await (0, import_isomorphic_unfetch2.default)(l, {
        body: s ? JSON.stringify(s) : null,
        headers: c2,
        method: "POST"
      });
      if (!r.ok) {
        let u;
        return (i = r.headers.get("content-type")) != null && i.includes("application/json") ? u = await r.json() : u = await r.text(), {
          res: null,
          error: {
            message: u,
            error: r.statusText,
            status: r.status
          }
        };
      }
      let n;
      return (h = r.headers.get("content-type")) != null && h.includes("application/json") ? n = await r.json() : n = await r.text(), {
        res: { data: n, status: r.status, statusText: r.statusText },
        error: null
      };
    } catch (r) {
      const n = r;
      return {
        res: null,
        error: {
          message: n.message,
          status: n.name === "AbortError" ? 0 : 500,
          error: n.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  /**
   * Use `nhost.functions.setAccessToken` to a set an access token to be used in subsequent functions requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.functions.setAccessToken('some-access-token')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-access-token
   */
  setAccessToken(t) {
    if (!t) {
      this.accessToken = null;
      return;
    }
    this.accessToken = t;
  }
  /**
   * Use `nhost.functions.getHeaders` to get the global headers sent with all functions requests.
   *
   * @example
   * ```ts
   * nhost.functions.getHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/get-headers
   */
  getHeaders() {
    return this.headers;
  }
  /**
   * Use `nhost.functions.setHeaders` to a set global headers to be sent in all subsequent functions requests.
   *
   * @example
   * ```ts
   * nhost.functions.setHeaders({
   *  'x-hasura-role': 'admin'
   * })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-headers
   */
  setHeaders(t) {
    t && (this.headers = {
      ...this.headers,
      ...t
    });
  }
  /**
   * Use `nhost.functions.unsetHeaders` to a unset global headers sent with all functions requests.
   *
   * @example
   * ```ts
   * nhost.functions.unsetHeaders()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/unset-headers
   */
  unsetHeaders() {
    const t = this.headers["x-hasura-role"];
    this.headers = t ? { "x-hasura-role": t } : {};
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
};
function _2(e) {
  const t = "subdomain" in e ? f3(e, "graphql") : e.graphqlUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `graphqlUrl`.");
  return new x2({ url: t, ...e });
}
function q2(e) {
  const t = "subdomain" in e ? f3(e, "storage") : e.storageUrl;
  if (!t)
    throw new Error("Please provide `subdomain` or `storageUrl`.");
  return new W2({ url: t, ...e });
}
var E2 = class {
  /**
   *
   * @example
   * ```ts
   * // Create a new Nhost client from subdomain and region.
   * const nhost = new NhostClient({ subdomain, region });
   * ```
   *
   *
   * ```ts
   * // Create a new Nhost client from individual service URLs (custom domains, self-hosting, etc).
   * const nhost = new NhostClient({
   *   authUrl: "my-auth-service-url",
   *   storageUrl: "my-storage-service-url",
   *   graphqlUrl: "my-graphql-service-url",
   *   functionsUrl: "my-functions-service-url",
   * });
   * ```
   *
   *
   * ```ts
   * // Create a new Nhost client for local development.
   * const nhost = new NhostClient({ subdomain: "local" });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript
   */
  constructor({
    refreshIntervalTime: t,
    clientStorage: s,
    clientStorageType: o,
    autoRefreshToken: c2,
    autoSignIn: l,
    adminSecret: i,
    devTools: h,
    start: r = true,
    ...n
  }) {
    a(this, "auth");
    a(this, "storage");
    a(this, "functions");
    a(this, "graphql");
    a(this, "_adminSecret");
    a(this, "devTools");
    this.auth = $3({
      refreshIntervalTime: t,
      clientStorage: s,
      clientStorageType: o,
      autoRefreshToken: c2,
      autoSignIn: l,
      start: r,
      ...n
    }), this.storage = q2({ adminSecret: i, ...n }), this.functions = v2({ adminSecret: i, ...n }), this.graphql = _2({ adminSecret: i, ...n }), this.auth.onAuthStateChanged((u, d) => {
      if (u === "SIGNED_OUT") {
        this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0);
        return;
      }
      const g2 = d == null ? void 0 : d.accessToken;
      this.storage.setAccessToken(g2), this.functions.setAccessToken(g2), this.graphql.setAccessToken(g2);
    }), this.auth.onTokenChanged((u) => {
      const d = u == null ? void 0 : u.accessToken;
      this.storage.setAccessToken(d), this.functions.setAccessToken(d), this.graphql.setAccessToken(d);
    }), this._adminSecret = i, this.devTools = h;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(t) {
    this._adminSecret = t, this.storage.setAdminSecret(t);
  }
  /**
   * Use `nhost.setRole` to set the user role for all subsequent GraphQL, storage, and functions calls.
   * Underneath, this method sets the `x-hasura-role` header on the graphql, storage,
   * and functions clients.
   *
   * ```ts
   * nhost.graphql.setHeaders({ 'x-hasura-role': role })
   * nhost.storage.setHeaders({ 'x-hasura-role': role })
   * nhost.functions.setHeaders({ 'x-hasura-role': role })
   * ```
   *
   * Note: Exercise caution when mixing the use of `setRole` along with `setHeaders` when setting the
   * `x-hasura-role` header, as the last call will override any previous ones.
   *
   * @example
   * ```ts
   * nhost.setRole('admin')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/set-role
   */
  setRole(t) {
    this.graphql.setHeaders({ "x-hasura-role": t }), this.storage.setHeaders({ "x-hasura-role": t }), this.functions.setHeaders({ "x-hasura-role": t });
  }
  /**
   * Use `nhost.unsetRole` to unset the user role for all subsequent graphql, storage and functions calls.
   * Underneath, this method removes the `x-hasura-role` header from the graphql, storage and functions clients.
   *
   * Note: Exercise caution when mixing the use of `unsetRole` along with `setHeaders` when setting the
   * `x-hasura-role` header, as the last call will override any previous ones.
   *
   * @example
   * ```ts
   * nhost.unsetRole()
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/unset-role
   */
  unsetRole() {
    this.graphql.setHeaders((({ "x-hasura-role": t, ...s }) => s)(this.graphql.getHeaders())), this.storage.setHeaders((({ "x-hasura-role": t, ...s }) => s)(this.storage.getHeaders())), this.functions.setHeaders(
      (({ "x-hasura-role": t, ...s }) => s)(this.functions.getHeaders())
    );
  }
};

// node_modules/@nhost/react/dist/index.esm.js
var import_react6 = __toESM(require_react());

// node_modules/@xstate/react/es/useMachine.js
var import_react3 = __toESM(require_react());
var import_with_selector = __toESM(require_with_selector());

// node_modules/@xstate/react/es/useInterpret.js
var import_react2 = __toESM(require_react());

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());
var index = import_react.useLayoutEffect;

// node_modules/@xstate/react/es/useConstant.js
var React = __toESM(require_react());
function useConstant(fn) {
  var ref = React.useRef();
  if (!ref.current) {
    ref.current = { v: fn() };
  }
  return ref.current.v;
}

// node_modules/@xstate/react/es/useInterpret.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p4 in s) if (Object.prototype.hasOwnProperty.call(s, p4))
        t[p4] = s[p4];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p4 in s) if (Object.prototype.hasOwnProperty.call(s, p4) && e.indexOf(p4) < 0)
    t[p4] = s[p4];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p4 = Object.getOwnPropertySymbols(s); i < p4.length; i++) {
      if (e.indexOf(p4[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p4[i]))
        t[p4[i]] = s[p4[i]];
    }
  return t;
};
var __read = function(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar2 = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar2;
};
function useIdleInterpreter(getMachine, options) {
  var machine = useConstant(function() {
    return typeof getMachine === "function" ? getMachine() : getMachine;
  });
  if (typeof getMachine !== "function") {
    var _a = __read((0, import_react2.useState)(machine), 1), initialMachine = _a[0];
    if (getMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var context = options.context, guards = options.guards, actions = options.actions, activities = options.activities, services = options.services, delays = options.delays, rehydratedState = options.state, interpreterOptions = __rest(options, ["context", "guards", "actions", "activities", "services", "delays", "state"]);
  var service = useConstant(function() {
    var machineConfig = {
      context,
      guards,
      actions,
      activities,
      services,
      delays
    };
    var machineWithConfig = machine.withConfig(machineConfig, function() {
      return __assign(__assign({}, machine.context), context);
    });
    return interpret(machineWithConfig, interpreterOptions);
  });
  index(function() {
    Object.assign(service.machine.options.actions, actions);
    Object.assign(service.machine.options.guards, guards);
    Object.assign(service.machine.options.activities, activities);
    Object.assign(service.machine.options.services, services);
    Object.assign(service.machine.options.delays, delays);
  }, [actions, guards, activities, services, delays]);
  return service;
}
function useInterpret(getMachine) {
  var _a = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    _a[_i - 1] = arguments[_i];
  }
  var _b = __read(_a, 2), _c = _b[0], options = _c === void 0 ? {} : _c, observerOrListener = _b[1];
  var service = useIdleInterpreter(getMachine, options);
  (0, import_react2.useEffect)(function() {
    if (!observerOrListener) {
      return;
    }
    var sub = service.subscribe(toObserver(observerOrListener));
    return function() {
      sub.unsubscribe();
    };
  }, [observerOrListener]);
  (0, import_react2.useEffect)(function() {
    var rehydratedState = options.state;
    service.start(rehydratedState ? State.create(rehydratedState) : void 0);
    return function() {
      service.stop();
      service.status = InterpreterStatus.NotStarted;
    };
  }, []);
  return service;
}

// node_modules/@xstate/react/es/utils.js
function getServiceSnapshot(service) {
  return service.status !== 0 ? service.getSnapshot() : service.machine.initialState;
}
function isService(actor) {
  return "state" in actor && "machine" in actor;
}

// node_modules/@xstate/react/es/useActor.js
var import_react4 = __toESM(require_react());
var import_with_selector2 = __toESM(require_with_selector());
function isActorWithState(actorRef) {
  return "state" in actorRef;
}

// node_modules/@xstate/react/es/useSelector.js
var import_react5 = __toESM(require_react());
var import_with_selector3 = __toESM(require_with_selector());
var defaultCompare = function(a2, b2) {
  return a2 === b2;
};
var defaultGetSnapshot = function(a2, initialStateCacheRef) {
  if (isService(a2)) {
    if (a2.status === 0 && initialStateCacheRef.current) {
      return initialStateCacheRef.current;
    }
    var snapshot = getServiceSnapshot(a2);
    initialStateCacheRef.current = a2.status === 0 ? snapshot : null;
    return snapshot;
  }
  return isActorWithState(a2) ? a2.state : void 0;
};
function useSelector(actor, selector, compare, getSnapshot) {
  if (compare === void 0) {
    compare = defaultCompare;
  }
  var initialStateCacheRef = (0, import_react5.useRef)(null);
  var subscribe2 = (0, import_react5.useCallback)(function(handleStoreChange) {
    var unsubscribe = actor.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [actor]);
  var boundGetSnapshot = (0, import_react5.useCallback)(function() {
    if (getSnapshot) {
      return getSnapshot(actor);
    }
    return defaultGetSnapshot(actor, initialStateCacheRef);
  }, [actor, getSnapshot]);
  var selectedSnapshot = (0, import_with_selector3.useSyncExternalStoreWithSelector)(subscribe2, boundGetSnapshot, boundGetSnapshot, selector, compare);
  return selectedSnapshot;
}

// node_modules/@xstate/react/es/createActorContext.js
var React2 = __toESM(require_react());

// node_modules/@nhost/react/dist/index.esm.js
var ve2 = E2;
var we2 = class extends ve2 {
  constructor(t) {
    super({ ...t, start: false });
  }
};
var I2 = (0, import_react6.createContext)({});
var xe2 = ({
  nhost: e,
  initial: t,
  ...r
}) => {
  const i = useInterpret(e.auth.client.machine, { devTools: e.devTools });
  e.auth.client.start({ interpreter: i, initialSession: t, devTools: e.devTools });
  const d = (0, import_react6.useRef)(true);
  return (0, import_react6.useEffect)(() => {
    d.current ? d.current = false : t && i.send("SESSION_UPDATE", { data: { session: t } });
  }, [t, i]), import_react6.default.createElement(I2.Provider, { value: e }, r.children);
};
var Ae2 = xe2;
var p3 = () => {
  var r;
  const t = (r = (0, import_react6.useContext)(I2).auth) == null ? void 0 : r.client.interpreter;
  if (!t)
    throw Error("Could not find the Nhost auth client. Did you wrap your app in <NhostProvider />?");
  return t;
};
var A4 = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => ({
      isAuthenticated: t.matches({ authentication: "signedIn" }),
      isLoading: t.hasTag("loading"),
      error: t.context.errors.authentication || null,
      isError: t.matches({ authentication: { signedOut: "failed" } }),
      connectionAttempts: t.context.importTokenAttempts
    }),
    (t, r) => t.isAuthenticated === r.isAuthenticated && t.isLoading === r.isLoading && t.connectionAttempts === r.connectionAttempts
  );
};
function Ue2({ children: e }) {
  const { isAuthenticated: t } = A4();
  return t ? (0, import_react6.createElement)(import_react6.Fragment, null, e) : null;
}
function Le2({ children: e }) {
  const { isAuthenticated: t } = A4();
  return t ? null : (0, import_react6.createElement)(import_react6.Fragment, null, e);
}
var U4 = () => {
  const e = p3();
  return useSelector(e, (t) => t.context.accessToken.value);
};
var v3 = () => (0, import_react6.useContext)(I2);
var Ce2 = () => {
  const e = v3(), [t, r] = (0, import_react6.useState)(null), i = !t, d = !!t, [l, h] = (0, import_react6.useState)(false);
  return { add: async (a2) => {
    h(true);
    const s = await ze(e.auth.client, a2), { error: o } = s;
    return o && r(o), h(false), s;
  }, isLoading: l, isSuccess: i, isError: d, error: t };
};
var Me2 = () => {
  const e = p3(), [t, r] = (0, import_react6.useState)(
    !!e.status && e.getSnapshot().matches({ authentication: "signedIn" })
  );
  return (0, import_react6.useEffect)(() => e.subscribe((d) => {
    const l = d.matches({ authentication: "signedIn" });
    r(l);
  }).unsubscribe, [e]), t;
};
function Ne2(e) {
  const t = v3(), r = (0, import_react6.useMemo)(() => Ye(t.auth.client), [t]), i = useInterpret(r), d = useSelector(i, (s) => s.matches("requesting")), l = useSelector(i, (s) => s.context.error), h = useSelector(i, (s) => s.matches("idle.error")), m2 = useSelector(i, (s) => s.matches("idle.success"));
  return { changeEmail: (0, import_react6.useCallback)(
    async (s, o = e) => Qe(i, s, o),
    [i, e]
  ), isLoading: d, needsEmailVerification: m2, isError: h, error: l };
}
var Re2 = () => {
  const e = v3(), t = (0, import_react6.useMemo)(() => je(e.auth.client), [e]), r = useInterpret(t), i = useSelector(r, (a2) => a2.matches({ idle: "error" })), d = useSelector(r, (a2) => a2.matches({ idle: "success" })), l = useSelector(r, (a2) => a2.context.error), h = useSelector(r, (a2) => a2.matches("requesting"));
  return { changePassword: (a2) => Xe(r, a2), isLoading: h, isSuccess: d, isError: i, error: l };
};
var Ke2 = () => {
  const e = v3(), t = (0, import_react6.useMemo)(() => kr(e.auth.client), [e]), r = useInterpret(t), i = useSelector(
    r,
    (f4) => f4.matches({ idle: "error" }) || f4.matches({ generated: { idle: "error" } })
  ), d = useSelector(r, (f4) => f4.matches("generating")), l = useSelector(r, (f4) => f4.matches("generated")), h = useSelector(r, (f4) => f4.matches({ generated: "activating" })), m2 = useSelector(r, (f4) => f4.matches({ generated: "activated" })), a2 = useSelector(r, (f4) => f4.matches("disabling")), s = useSelector(r, (f4) => f4.context.error), o = useSelector(r, (f4) => f4.context.imageUrl || ""), c2 = useSelector(r, (f4) => f4.context.secret || "");
  return {
    generateQrCode: () => Ir(r),
    isGenerating: d,
    qrCodeDataUrl: o,
    isGenerated: l,
    activateMfa: (f4) => Sr(r, f4),
    isActivating: h,
    isActivated: m2,
    isDisabling: a2,
    isError: i,
    error: s,
    disableMfa: (f4) => Ar(r, f4),
    totpSecret: c2
  };
};
var Se2 = () => {
  const e = U4();
  return e ? jwtDecode(e) : null;
};
var Pe2 = (e) => {
  const t = v3(), r = (g2) => {
    e.send({
      type: "ADD",
      file: g2.file,
      bucketId: g2.bucketId || E3
    });
  }, i = (g2) => J2(
    {
      url: t.storage.url,
      accessToken: t.auth.getAccessToken(),
      adminSecret: t.adminSecret,
      ...g2
    },
    e
  ), d = () => {
    e.send("CANCEL");
  }, l = () => {
    e.send("DESTROY");
  }, h = useSelector(e, (g2) => g2.matches("uploading")), m2 = useSelector(e, (g2) => g2.matches("uploaded")), a2 = useSelector(e, (g2) => g2.matches("error")), s = useSelector(e, (g2) => g2.context.error || null), o = useSelector(e, (g2) => g2.context.progress), c2 = useSelector(e, (g2) => g2.context.id), E3 = useSelector(e, (g2) => g2.context.bucketId), u = useSelector(e, (g2) => {
    var f4;
    return (f4 = g2.context.file) == null ? void 0 : f4.name;
  });
  return {
    add: r,
    upload: i,
    cancel: d,
    destroy: l,
    isUploaded: m2,
    isUploading: h,
    isError: a2,
    error: s,
    progress: o,
    id: c2,
    bucketId: E3,
    name: u
  };
};
var Ve2 = () => {
  const e = useInterpret(G2);
  return Pe2(e);
};
var L2 = () => {
  const e = Se2();
  return (e == null ? void 0 : e["https://hasura.io/jwt/claims"]) || null;
};
var De2 = (e) => {
  const t = L2();
  return (t == null ? void 0 : t[e.startsWith("x-hasura-") ? e : `x-hasura-${e}`]) || null;
};
var Fe2 = () => {
  const e = v3(), [t, r] = (0, import_react6.useState)([]), i = useInterpret(Y2, {}, (u) => {
    u.event.type === "UPLOAD_ERROR" ? r(u.context.files.filter((g2) => {
      var f4;
      return (f4 = g2.getSnapshot()) == null ? void 0 : f4.context.error;
    })) : (u.matches("uploaded") || u.event.type === "CLEAR") && t.length > 0 && r([]);
  }), d = (u) => {
    i.send({ type: "ADD", ...u });
  }, l = (u) => K2(
    {
      url: e.storage.url,
      accessToken: e.auth.getAccessToken(),
      adminSecret: e.adminSecret,
      ...u
    },
    i
  ), h = () => {
    i.send("CANCEL");
  }, m2 = () => {
    i.send("CLEAR");
  }, a2 = useSelector(i, (u) => u.matches("uploading")), s = useSelector(i, (u) => u.matches("uploaded")), o = useSelector(i, (u) => u.matches("error")), c2 = useSelector(i, (u) => u.context.progress), E3 = useSelector(i, (u) => u.context.files);
  return {
    upload: l,
    add: d,
    clear: m2,
    cancel: h,
    progress: c2,
    isUploaded: s,
    isUploading: a2,
    files: E3,
    isError: o,
    errors: t
  };
};
var _e2 = (e) => {
  const [t, r] = (0, import_react6.useState)(true), i = U4();
  (0, import_react6.useEffect)(() => {
    r(false);
  }, []);
  const d = (0, import_react6.useContext)(I2);
  return new Proxy({}, {
    get(l, h) {
      let m2 = `${d.auth.client.backendUrl}/signin/provider/${h}`;
      const a2 = e != null && e.connect ? { connect: i } : {};
      return F(
        m2,
        S(t ? void 0 : d.auth.client.clientUrl, {
          ...e,
          ...a2
        })
      );
    }
  });
};
var qe = (e) => {
  const t = v3(), r = (0, import_react6.useMemo)(() => Fe(t.auth.client), [t]), i = useInterpret(r), d = useSelector(i, (s) => s.matches("requesting")), l = useSelector(i, (s) => s.context.error), h = useSelector(i, (s) => s.matches("idle.error")), m2 = useSelector(i, (s) => s.matches("idle.success"));
  return { resetPassword: (s, o = e) => Ze(i, s, o), isLoading: d, isSent: m2, isError: h, error: l };
};
var He2 = (e) => {
  const t = v3(), r = (0, import_react6.useMemo)(() => Be(t.auth.client), [t]), i = useInterpret(r), d = useSelector(i, (s) => s.matches({ idle: "error" })), l = useSelector(i, (s) => s.matches({ idle: "success" })), h = useSelector(i, (s) => s.context.error), m2 = useSelector(i, (s) => s.matches("requesting"));
  return { sendEmail: (s, o = e) => Je(i, s, o), isLoading: m2, isSent: l, isError: d, error: h };
};
var Qe2 = () => {
  const e = p3(), t = () => er(e), r = useSelector(
    e,
    (a2) => a2.context.errors.authentication || null,
    (a2, s) => (a2 == null ? void 0 : a2.error) === (s == null ? void 0 : s.error)
  ), i = useSelector(
    e,
    (a2) => a2.matches({ authentication: { authenticating: "anonymous" } })
  ), d = useSelector(
    e,
    (a2) => a2.matches({
      authentication: "signedIn"
    })
  ), l = useSelector(
    e,
    (a2) => a2.matches({ authentication: { signedOut: "failed" } })
  ), h = useSelector(
    e,
    (a2) => a2.context.user,
    (a2, s) => (a2 == null ? void 0 : a2.id) === (s == null ? void 0 : s.id)
  );
  return { accessToken: useSelector(e, (a2) => a2.context.accessToken.value), error: r, isError: l, isLoading: i, isSuccess: d, signInAnonymous: t, user: h };
};
var $e2 = () => {
  const e = p3(), t = (u, g2) => rr(e, u, g2), r = (u) => tr(e, u), i = useSelector(
    e,
    (u) => u.context.user,
    (u, g2) => (u == null ? void 0 : u.id) === (g2 == null ? void 0 : g2.id)
  ), d = useSelector(e, (u) => u.context.accessToken.value), l = useSelector(e, (u) => u.context.refreshToken.value), h = useSelector(
    e,
    (u) => u.context.errors.authentication || null,
    (u, g2) => (u == null ? void 0 : u.error) === (g2 == null ? void 0 : g2.error)
  ), m2 = useSelector(
    e,
    (u) => u.matches({
      authentication: "signedIn"
    })
  ), a2 = useSelector(
    e,
    (u) => u.matches({ authentication: { authenticating: "password" } }),
    (u, g2) => u === g2
  ), s = useSelector(
    e,
    (u) => u.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (u, g2) => u === g2
  ), o = useSelector(e, (u) => u.context.mfa !== null), c2 = useSelector(
    e,
    (u) => u.matches({ authentication: { signedOut: "failed" } }),
    (u, g2) => u === g2
  ), E3 = useSelector(e, (u) => u.context.mfa);
  return {
    accessToken: d,
    refreshToken: l,
    error: h,
    isError: c2,
    isLoading: a2,
    isSuccess: m2,
    needsEmailVerification: s,
    needsMfaOtp: o,
    mfa: E3,
    sendMfaOtp: r,
    signInEmailPassword: t,
    user: i
  };
};
function je2(e) {
  const t = p3(), r = (m2, a2 = e) => re(t, m2, a2), i = useSelector(
    t,
    (m2) => m2.context.errors.registration || null,
    (m2, a2) => (m2 == null ? void 0 : m2.error) === (a2 == null ? void 0 : a2.error)
  ), d = useSelector(t, (m2) => m2.matches("registration.passwordlessEmail")), l = useSelector(
    t,
    (m2) => m2.matches("registration.incomplete.needsEmailVerification")
  ), h = useSelector(t, (m2) => m2.matches("registration.incomplete.failed"));
  return { signInEmailPasswordless: r, isLoading: d, isSuccess: l, isError: h, error: i };
}
var Ge2 = () => {
  const e = p3(), t = (o) => nr(e, o), r = useSelector(
    e,
    (o) => o.context.user,
    (o, c2) => (o == null ? void 0 : o.id) === (c2 == null ? void 0 : c2.id)
  ), i = useSelector(e, (o) => o.context.accessToken.value), d = useSelector(e, (o) => o.context.refreshToken.value), l = useSelector(
    e,
    (o) => o.context.errors.authentication || null,
    (o, c2) => (o == null ? void 0 : o.error) === (c2 == null ? void 0 : c2.error)
  ), h = useSelector(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), m2 = useSelector(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c2) => o === c2
  ), a2 = useSelector(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c2) => o === c2
  ), s = useSelector(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c2) => o === c2
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: s,
    isLoading: m2,
    isSuccess: h,
    needsEmailVerification: a2,
    signInEmailSecurityKey: t,
    user: r
  };
};
var Te = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => t.context.user,
    (t, r) => (t && JSON.stringify(t)) === (r && JSON.stringify(r))
  );
};
var Je2 = () => {
  const e = Te(), t = v3(), r = L2(), i = e ? (r == null ? void 0 : r["x-hasura-auth-elevated"]) === (e == null ? void 0 : e.id) : false, [d, l] = (0, import_react6.useState)(!!i), h = (m2) => sr(t.auth.client, m2);
  return (0, import_react6.useEffect)(() => {
    l(!!i);
  }, [i]), {
    elevated: d,
    elevateEmailSecurityKey: h
  };
};
var Ye2 = () => {
  const e = p3(), t = (s) => ir(e, s), r = useSelector(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(e, (s) => s.context.accessToken.value), d = useSelector(e, (s) => s.context.refreshToken.value), l = useSelector(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), h = useSelector(e, (s) => s.matches({ authentication: "signedIn" })), m2 = useSelector(
    e,
    (s) => s.matches({ authentication: { authenticating: "password" } }),
    (s, o) => s === o
  ), a2 = useSelector(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: a2,
    isLoading: m2,
    isSuccess: h,
    signInPAT: t,
    user: r
  };
};
function We2(e) {
  const t = p3(), [r, i] = (0, import_react6.useState)(""), d = (c2, E3 = e) => (i(c2), se(t, c2, E3)), l = async (...c2) => {
    if (c2.length === 2) {
      const [u, g2] = c2;
      return or(t, u, g2);
    }
    const [E3] = c2;
    return or(t, r, E3);
  }, h = useSelector(
    t,
    (c2) => c2.context.errors.registration || null,
    (c2, E3) => (c2 == null ? void 0 : c2.error) === (E3 == null ? void 0 : E3.error)
  ), m2 = useSelector(
    t,
    (c2) => c2.matches("registration.passwordlessSms") || c2.matches("registration.passwordlessSmsOtp")
  ), a2 = useSelector(t, (c2) => c2.matches("authentication.signedIn")), s = useSelector(
    t,
    (c2) => c2.matches("registration.incomplete.needsOtp")
  ), o = useSelector(t, (c2) => c2.matches("registration.incomplete.failed"));
  return { signInSmsPasswordless: d, sendOtp: l, isLoading: m2, isSuccess: a2, needsOtp: s, isError: o, error: h };
}
var ze2 = (e = false) => {
  const t = p3(), r = (l) => ar(t, typeof l == "boolean" ? l : e), i = useSelector(
    t,
    (l) => l.matches({ authentication: { signedOut: "success" } }),
    (l, h) => l === h
  ), d = useSelector(
    t,
    (l) => l.context.errors.signout || null,
    (l, h) => (l == null ? void 0 : l.error) === (h == null ? void 0 : h.error)
  );
  return { signOut: r, isSuccess: i, error: d };
};
var Be2 = (e) => {
  const t = p3(), r = useSelector(t, (c2) => !!c2.context.errors.registration), i = useSelector(
    t,
    (c2) => c2.context.errors.registration || null,
    (c2, E3) => (c2 == null ? void 0 : c2.error) === (E3 == null ? void 0 : E3.error)
  ), d = useSelector(t, (c2) => c2.matches("registration.emailPassword")), l = useSelector(
    t,
    (c2) => c2.matches("registration.incomplete.needsEmailVerification")
  ), h = useSelector(
    t,
    (c2) => c2.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m2 = (c2, E3, u = e, g2) => te(t, c2, E3, u, g2), a2 = useSelector(
    t,
    (c2) => c2.context.user,
    (c2, E3) => (c2 == null ? void 0 : c2.id) === (E3 == null ? void 0 : E3.id)
  ), s = useSelector(t, (c2) => c2.context.accessToken.value), o = useSelector(t, (c2) => c2.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: r,
    isLoading: d,
    isSuccess: h,
    needsEmailVerification: l,
    signUpEmailPassword: m2,
    user: a2
  };
};
var Xe2 = (e) => {
  const t = p3(), r = useSelector(t, (c2) => !!c2.context.errors.registration), i = useSelector(
    t,
    (c2) => c2.context.errors.registration || null,
    (c2, E3) => (c2 == null ? void 0 : c2.error) === (E3 == null ? void 0 : E3.error)
  ), d = useSelector(t, (c2) => c2.matches("registration.securityKey")), l = useSelector(
    t,
    (c2) => c2.matches("registration.incomplete.needsEmailVerification")
  ), h = useSelector(
    t,
    (c2) => c2.matches({
      authentication: "signedIn",
      registration: "complete"
    })
  ), m2 = (c2, E3 = e, u) => cr(t, c2, E3, u), a2 = useSelector(
    t,
    (c2) => c2.context.user,
    (c2, E3) => (c2 == null ? void 0 : c2.id) === (E3 == null ? void 0 : E3.id)
  ), s = useSelector(t, (c2) => c2.context.accessToken.value), o = useSelector(t, (c2) => c2.context.refreshToken.value);
  return {
    accessToken: s,
    refreshToken: o,
    error: i,
    isError: r,
    isLoading: d,
    isSuccess: h,
    needsEmailVerification: l,
    signUpEmailSecurityKey: m2,
    user: a2
  };
};
var Ze2 = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.avatarUrl;
    },
    (t, r) => t === r
  );
};
var be2 = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.defaultRole;
    },
    (t, r) => t === r
  );
};
var et = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.displayName;
    },
    (t, r) => t === r
  );
};
var tt = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.email;
    },
    (t, r) => t === r
  );
};
var st = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.id;
    },
    (t, r) => t === r
  );
};
var nt = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.isAnonymous;
    },
    (t, r) => t === r
  );
};
var ot = () => {
  const e = p3();
  return useSelector(
    e,
    (t) => {
      var r;
      return (r = t.context.user) == null ? void 0 : r.locale;
    },
    (t, r) => t === r
  );
};
var rt = () => {
  const e = p3();
  return useSelector(e, (t) => {
    var r;
    return t.matches("authentication.signedIn") ? ((r = t.context.user) == null ? void 0 : r.roles) || [] : [];
  });
};
function ct(e) {
  const t = p3(), r = (s, o = e) => ur(t, s, o), i = async (s, o) => lr(t, s, o), d = useSelector(
    t,
    (s) => s.context.errors.registration || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), l = useSelector(
    t,
    (s) => s.matches("registration.signInEmailOTP") || s.matches("registration.verifyEmailOTP")
  ), h = useSelector(t, (s) => s.matches("authentication.signedIn")), m2 = useSelector(
    t,
    (s) => s.matches("registration.incomplete.needsOtp")
  ), a2 = useSelector(t, (s) => s.matches("registration.incomplete.failed"));
  return { signInEmailOTP: r, verifyEmailOTP: i, isLoading: l, isSuccess: h, isError: a2, error: d, needsOtp: m2 };
}
var it = () => {
  const e = p3(), t = (s, o, c2) => dr(e, {
    provider: s,
    idToken: o,
    nonce: c2
  }), r = useSelector(
    e,
    (s) => s.context.user,
    (s, o) => (s == null ? void 0 : s.id) === (o == null ? void 0 : o.id)
  ), i = useSelector(e, (s) => s.context.accessToken.value), d = useSelector(e, (s) => s.context.refreshToken.value), l = useSelector(
    e,
    (s) => s.context.errors.authentication || null,
    (s, o) => (s == null ? void 0 : s.error) === (o == null ? void 0 : o.error)
  ), h = useSelector(e, (s) => s.matches({ authentication: "signedIn" })), m2 = useSelector(
    e,
    (s) => s.matches({ authentication: { authenticating: "idToken" } }),
    (s, o) => s === o
  ), a2 = useSelector(
    e,
    (s) => s.matches({ authentication: { signedOut: "failed" } }),
    (s, o) => s === o
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: a2,
    isLoading: m2,
    isSuccess: h,
    signInIdToken: t,
    user: r
  };
};
var at = () => {
  const e = v3(), [t, r] = (0, import_react6.useState)(null), i = !t, d = !!t, [l, h] = (0, import_react6.useState)(false);
  return { linkIdToken: async ({
    provider: a2,
    idToken: s,
    nonce: o
  }) => {
    h(true);
    const c2 = await fr(e.auth.client, {
      provider: a2,
      idToken: s,
      ...o && { nonce: o }
    }), { error: E3 } = c2;
    return E3 && r(E3), h(false), c2;
  }, isLoading: l, isSuccess: i, isError: d, error: t };
};
var ut = () => {
  const e = p3(), t = () => hr(e), r = useSelector(
    e,
    (o) => o.context.user,
    (o, c2) => (o == null ? void 0 : o.id) === (c2 == null ? void 0 : c2.id)
  ), i = useSelector(e, (o) => o.context.accessToken.value), d = useSelector(e, (o) => o.context.refreshToken.value), l = useSelector(
    e,
    (o) => o.context.errors.authentication || null,
    (o, c2) => (o == null ? void 0 : o.error) === (c2 == null ? void 0 : c2.error)
  ), h = useSelector(
    e,
    (o) => o.matches({
      authentication: "signedIn"
    })
  ), m2 = useSelector(
    e,
    (o) => o.matches({ authentication: { authenticating: "securityKeyEmail" } }),
    (o, c2) => o === c2
  ), a2 = useSelector(
    e,
    (o) => o.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }),
    (o, c2) => o === c2
  ), s = useSelector(
    e,
    (o) => o.matches({ authentication: { signedOut: "failed" } }),
    (o, c2) => o === c2
  );
  return {
    accessToken: i,
    refreshToken: d,
    error: l,
    isError: s,
    isLoading: m2,
    isSuccess: h,
    needsEmailVerification: a2,
    signInSecurityKey: t,
    user: r
  };
};
export {
  x as NHOST_REFRESH_TOKEN_KEY,
  we2 as NhostClient,
  xe2 as NhostProvider,
  I2 as NhostReactContext,
  Ae2 as NhostReactProvider,
  Ue2 as SignedIn,
  Le2 as SignedOut,
  ve2 as VanillaNhostClient,
  U4 as useAccessToken,
  Ce2 as useAddSecurityKey,
  p3 as useAuthInterpreter,
  Me2 as useAuthenticated,
  A4 as useAuthenticationStatus,
  Ne2 as useChangeEmail,
  Re2 as useChangePassword,
  Ke2 as useConfigMfa,
  Se2 as useDecodedAccessToken,
  Je2 as useElevateSecurityKeyEmail,
  Ve2 as useFileUpload,
  Pe2 as useFileUploadItem,
  De2 as useHasuraClaim,
  L2 as useHasuraClaims,
  at as useLinkIdToken,
  Fe2 as useMultipleFilesUpload,
  v3 as useNhostClient,
  _e2 as useProviderLink,
  qe as useResetPassword,
  He2 as useSendVerificationEmail,
  Qe2 as useSignInAnonymous,
  ct as useSignInEmailOTP,
  $e2 as useSignInEmailPassword,
  je2 as useSignInEmailPasswordless,
  Ge2 as useSignInEmailSecurityKey,
  it as useSignInIdToken,
  Ye2 as useSignInPAT,
  ut as useSignInSecurityKey,
  We2 as useSignInSmsPasswordless,
  ze2 as useSignOut,
  Be2 as useSignUpEmailPassword,
  Xe2 as useSignUpEmailSecurityKeyEmail,
  Ze2 as useUserAvatarUrl,
  Te as useUserData,
  be2 as useUserDefaultRole,
  et as useUserDisplayName,
  tt as useUserEmail,
  st as useUserId,
  nt as useUserIsAnonymous,
  ot as useUserLocale,
  rt as useUserRoles
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@nhost_react.js.map
