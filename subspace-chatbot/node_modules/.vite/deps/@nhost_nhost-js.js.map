{
  "version": 3,
  "sources": ["../../jwt-decode/lib/atob.js", "../../jwt-decode/lib/base64_url_decode.js", "../../jwt-decode/lib/index.js", "../../@nhost/hasura-auth-js/src/constants.ts", "../../@nhost/hasura-auth-js/src/errors.ts", "../../@nhost/hasura-auth-js/src/machines/authentication/context.ts", "../../node_modules/.pnpm/@simplewebauthn+browser@6.0.0/node_modules/@simplewebauthn/browser/dist/bundle/index.js", "../../@nhost/hasura-auth-js/src/local-storage.ts", "../../@nhost/hasura-auth-js/src/utils/client-helpers.ts", "../../@nhost/hasura-auth-js/src/utils/environment.ts", "../../@nhost/hasura-auth-js/src/utils/fetch.ts", "../../@nhost/hasura-auth-js/src/utils/url.ts", "../../@nhost/hasura-auth-js/src/utils/validators.ts", "../../@nhost/hasura-auth-js/src/machines/authentication/machine.ts", "../../@nhost/hasura-auth-js/src/machines/change-email.ts", "../../@nhost/hasura-auth-js/src/machines/change-password.ts", "../../@nhost/hasura-auth-js/src/machines/enable-mfa.ts", "../../@nhost/hasura-auth-js/src/machines/reset-password.ts", "../../@nhost/hasura-auth-js/src/machines/send-verification-email.ts", "../../@nhost/hasura-auth-js/src/internal-client.ts", "../../@nhost/hasura-auth-js/src/promises/addSecurityKey.ts", "../../@nhost/hasura-auth-js/src/promises/changeEmail.ts", "../../@nhost/hasura-auth-js/src/promises/changePassword.ts", "../../@nhost/hasura-auth-js/src/promises/mfa.ts", "../../@nhost/hasura-auth-js/src/promises/resetPassword.ts", "../../@nhost/hasura-auth-js/src/promises/sendVerificationEmail.ts", "../../@nhost/hasura-auth-js/src/promises/signInAnonymous.ts", "../../@nhost/hasura-auth-js/src/promises/signInEmailPassword.ts", "../../@nhost/hasura-auth-js/src/promises/signInEmailPasswordless.ts", "../../@nhost/hasura-auth-js/src/promises/signInEmailSecurityKey.ts", "../../@nhost/hasura-auth-js/src/promises/signInMfaTotp.ts", "../../@nhost/hasura-auth-js/src/promises/signInPAT.ts", "../../@nhost/hasura-auth-js/src/promises/signInSmsPasswordless.ts", "../../@nhost/hasura-auth-js/src/promises/signInSmsPasswordlessOtp.ts", "../../@nhost/hasura-auth-js/src/promises/signOut.ts", "../../@nhost/hasura-auth-js/src/promises/signUpEmailPassword.ts", "../../@nhost/hasura-auth-js/src/promises/signUpEmailSecurityKey.ts", "../../@nhost/hasura-auth-js/src/promises/createPAT.ts", "../../@nhost/hasura-auth-js/src/hasura-auth-client.ts", "../../@nhost/hasura-storage-js/src/utils/upload.ts", "../../@nhost/hasura-storage-js/src/hasura-storage-api.ts", "../../@nhost/hasura-storage-js/src/utils/appendImageTransformationParameters/appendImageTransformationParameters.ts", "../../@nhost/hasura-storage-js/src/hasura-storage-client.ts", "../../@nhost/hasura-storage-js/src/machines/file-upload.ts", "../../@nhost/hasura-storage-js/src/machines/multiple-files-upload.ts", "../../@nhost/hasura-storage-js/src/promises/file-upload.ts", "../../@nhost/hasura-storage-js/src/promises/multiple-files-upload.ts", "../../@nhost/graphql-js/src/parse-args.ts", "../../@nhost/graphql-js/src/resolve-request-document.ts", "../../@nhost/graphql-js/src/client.ts", "../../@nhost/nhost-js/src/utils/helpers.ts", "../../@nhost/nhost-js/src/clients/auth.ts", "../../@nhost/nhost-js/src/clients/functions/index.ts", "../../@nhost/nhost-js/src/clients/graphql.ts", "../../@nhost/nhost-js/src/clients/storage.ts", "../../@nhost/nhost-js/src/clients/nhost.ts"],
  "sourcesContent": ["/**\n * The code was extracted from:\n * https://github.com/davidchambers/Base64.js\n */\n\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\nfunction InvalidCharacterError(message) {\n    this.message = message;\n}\n\nInvalidCharacterError.prototype = new Error();\nInvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n\nfunction polyfill(input) {\n    var str = String(input).replace(/=+$/, \"\");\n    if (str.length % 4 == 1) {\n        throw new InvalidCharacterError(\n            \"'atob' failed: The string to be decoded is not correctly encoded.\"\n        );\n    }\n    for (\n        // initialize result and counters\n        var bc = 0, bs, buffer, idx = 0, output = \"\";\n        // get next character\n        (buffer = str.charAt(idx++));\n        // character found in table? initialize bit storage and add its ascii value;\n        ~buffer &&\n        ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n            // and if not first of each 4 characters,\n            // convert the first 8 bits to one ascii character\n            bc++ % 4) ?\n        (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n        0\n    ) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n    }\n    return output;\n}\n\nexport default (typeof window !== \"undefined\" &&\n    window.atob &&\n    window.atob.bind(window)) ||\npolyfill;", "import atob from \"./atob\";\n\nfunction b64DecodeUnicode(str) {\n    return decodeURIComponent(\n        atob(str).replace(/(.)/g, function(m, p) {\n            var code = p.charCodeAt(0).toString(16).toUpperCase();\n            if (code.length < 2) {\n                code = \"0\" + code;\n            }\n            return \"%\" + code;\n        })\n    );\n}\n\nexport default function(str) {\n    var output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    switch (output.length % 4) {\n        case 0:\n            break;\n        case 2:\n            output += \"==\";\n            break;\n        case 3:\n            output += \"=\";\n            break;\n        default:\n            throw \"Illegal base64url string!\";\n    }\n\n    try {\n        return b64DecodeUnicode(output);\n    } catch (err) {\n        return atob(output);\n    }\n}", "\"use strict\";\n\nimport base64_url_decode from \"./base64_url_decode\";\n\nexport function InvalidTokenError(message) {\n    this.message = message;\n}\n\nInvalidTokenError.prototype = new Error();\nInvalidTokenError.prototype.name = \"InvalidTokenError\";\n\nexport default function(token, options) {\n    if (typeof token !== \"string\") {\n        throw new InvalidTokenError(\"Invalid token specified\");\n    }\n\n    options = options || {};\n    var pos = options.header === true ? 0 : 1;\n    try {\n        return JSON.parse(base64_url_decode(token.split(\".\")[pos]));\n    } catch (e) {\n        throw new InvalidTokenError(\"Invalid token specified: \" + e.message);\n    }\n}", "export const NHOST_REFRESH_TOKEN_KEY = 'nhostRefreshToken'\nexport const NHOST_REFRESH_TOKEN_ID_KEY = 'nhostRefreshTokenId'\nexport const NHOST_JWT_EXPIRES_AT_KEY = 'nhostRefreshTokenExpiresAt'\n\nexport const MIN_PASSWORD_LENGTH = 3\n\n/**\n * Minimum time in seconds between now and the JWT expiration time before the JWT is refreshed\n * For instance, if set to 60, the client will refresh the JWT one minute before it expires\n */\nexport const TOKEN_REFRESH_MARGIN_SECONDS = 60\n\nexport const REFRESH_TOKEN_MAX_ATTEMPTS = 5\n", "import { AuthErrorPayload } from './types'\n\nexport const NETWORK_ERROR_CODE = 0\nexport const OTHER_ERROR_CODE = 1\nexport const VALIDATION_ERROR_CODE = 10\nexport const STATE_ERROR_CODE = 20\n\n/**\n * @internal\n * Adds a standard error payload to any JS Error, or convert a standard error payload into a JS Error.\n * Allows xstate to use `throw` instead of `Promise.reject` to propagate errors.\n * See https://github.com/statelyai/xstate/issues/3037\n */\nexport class CodifiedError extends Error {\n  error: AuthErrorPayload\n  constructor(original: Error | AuthErrorPayload) {\n    super(original.message)\n\n    if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor)\n\n    if (original instanceof Error) {\n      this.name = original.name\n      this.error = {\n        error: original.name,\n        status: OTHER_ERROR_CODE,\n        message: original.message\n      }\n    } else {\n      this.name = original.error\n      this.error = original\n    }\n  }\n}\n\nexport type ValidationAuthErrorPayload = AuthErrorPayload & { status: typeof VALIDATION_ERROR_CODE }\n\n// TODO share with hasura-auth\nexport const INVALID_EMAIL_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-email',\n  message: 'Email is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TYPE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-type',\n  message: 'MFA type is invalid'\n}\n\nexport const INVALID_MFA_CODE_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-code',\n  message: 'MFA code is invalid'\n}\n\nexport const INVALID_PASSWORD_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-password',\n  message: 'Password is incorrectly formatted'\n}\n\nexport const INVALID_PHONE_NUMBER_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-phone-number',\n  message: 'Phone number is incorrectly formatted'\n}\n\nexport const INVALID_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-mfa-ticket',\n  message: 'MFA ticket is invalid'\n}\n\nexport const NO_MFA_TICKET_ERROR: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-mfa-ticket',\n  message: 'No MFA ticket has been provided'\n}\n\nexport const NO_REFRESH_TOKEN: ValidationAuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'no-refresh-token',\n  message: 'No refresh token has been provided'\n}\n\nexport const TOKEN_REFRESHER_RUNNING_ERROR: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'refresher-already-running',\n  message:\n    'The token refresher is already running. You must wait until is has finished before submitting a new token.'\n}\n\nexport const USER_ALREADY_SIGNED_IN: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'already-signed-in',\n  message: 'User is already signed in'\n}\n\nexport const USER_UNAUTHENTICATED: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unauthenticated-user',\n  message: 'User is not authenticated'\n}\n\nexport const USER_NOT_ANONYMOUS: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'user-not-anonymous',\n  message: 'User is not anonymous'\n}\n\nexport const EMAIL_NEEDS_VERIFICATION: AuthErrorPayload = {\n  status: STATE_ERROR_CODE,\n  error: 'unverified-user',\n  message: 'Email needs verification'\n}\n\nexport const INVALID_REFRESH_TOKEN: AuthErrorPayload = {\n  status: VALIDATION_ERROR_CODE,\n  error: 'invalid-refresh-token',\n  message: 'Invalid or expired refresh token'\n}\n\nexport const INVALID_SIGN_IN_METHOD: AuthErrorPayload = {\n  status: OTHER_ERROR_CODE,\n  error: 'invalid-sign-in-method',\n  message: 'Invalid sign-in method'\n}\n", "import { AuthErrorPayload, User } from '../../types'\n\nexport type StateErrorTypes = 'registration' | 'authentication' | 'signout'\n\nexport type AuthContext = {\n  user: User | null\n  mfa: {\n    ticket: string\n  } | null\n  accessToken: {\n    value: string | null\n    expiresAt: Date | null\n    expiresInSeconds: number | null\n  }\n  refreshTimer: {\n    startedAt: Date | null\n    attempts: number\n    lastAttempt: Date | null\n  }\n  refreshToken: {\n    value: string | null\n    isPAT?: boolean\n  }\n  /** Number of times the user tried to get an access token from a refresh token but got a network error */\n  importTokenAttempts: number\n  errors: Partial<Record<StateErrorTypes, AuthErrorPayload>>\n}\n\nexport const INITIAL_MACHINE_CONTEXT: AuthContext = {\n  user: null,\n  mfa: null,\n  accessToken: {\n    value: null,\n    expiresAt: null,\n    expiresInSeconds: 15\n  },\n  refreshTimer: {\n    startedAt: null,\n    attempts: 0,\n    lastAttempt: null\n  },\n  refreshToken: {\n    value: null\n  },\n  importTokenAttempts: 0,\n  errors: {}\n}\n", "/* [@simplewebauthn/browser@6.0.0] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return ((window === null || window === void 0 ? void 0 : window.PublicKeyCredential) !== undefined && typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor(message, name = 'WebAuthnError') {\n        super(message);\n        this.name = name;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    var _a, _b;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Registration ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            return new WebAuthnError('Discoverable credentials were required but no available authenticator supported it', 'ConstraintError');\n        }\n        else if (((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === 'required') {\n            return new WebAuthnError('User verification was required but no available authenticator supported it', 'ConstraintError');\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError('The authenticator was previously registered', 'InvalidStateError');\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError('User clicked cancel, or the registration ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter(param => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError('No entry in pubKeyCredParams was of type \"public-key\"', 'NotSupportedError');\n        }\n        return new WebAuthnError('No available authenticator supported any of the specified pubKeyCredParams algorithms', 'NotSupportedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rp.id}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError('User ID was not between 1 and 64 characters', 'TypeError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new credential', 'UnknownError');\n    }\n    return error;\n}\n\nclass WebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            this.controller.abort();\n        }\n        this.controller = new AbortController();\n        return this.controller.signal;\n    }\n    reset() {\n        this.controller = undefined;\n    }\n}\nconst webauthnAbortService = new WebAuthnAbortService();\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    const credentialJSON = {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n    if (typeof response.getTransports === 'function') {\n        credentialJSON.transports = response.getTransports();\n    }\n    return credentialJSON;\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nasync function browserSupportsWebAuthnAutofill() {\n    if (navigator.credentials.conditionalMediationSupported) {\n        return true;\n    }\n    const globalPublicKeyCredential = window.PublicKeyCredential;\n    return (globalPublicKeyCredential.isConditionalMediationAvailable !== undefined &&\n        globalPublicKeyCredential.isConditionalMediationAvailable());\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    var _a;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal === new AbortController().signal) {\n            return new WebAuthnError('Authentication ceremony was sent an abort signal', 'AbortError');\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        if ((_a = publicKey.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) {\n            return new WebAuthnError('No available authenticator recognized any of the allowed credentials', 'NotAllowedError');\n        }\n        return new WebAuthnError('User clicked cancel, or the authentication ceremony timed out', 'NotAllowedError');\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError(`${window.location.hostname} is an invalid domain`, 'SecurityError');\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError(`The RP ID \"${publicKey.rpId}\" is invalid for this domain`, 'SecurityError');\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError('The authenticator was unable to process the specified options, or could not create a new assertion signature', 'UnknownError');\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    var _a, _b;\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (((_a = requestOptionsJSON.allowCredentials) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        allowCredentials = (_b = requestOptionsJSON.allowCredentials) === null || _b === void 0 ? void 0 : _b.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete*='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with `\"webauthn\"` in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = webauthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    finally {\n        webauthnAbortService.reset();\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: credential.authenticatorAttachment,\n    };\n}\n\nasync function platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return false;\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n", "import Cookies from 'js-cookie'\n\nimport { ClientStorage, ClientStorageType, StorageGetter, StorageSetter } from './types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nconst inMemoryLocalStorage: Map<string, string | null> = new Map()\n\nconst defaultClientStorageGetter: StorageGetter = (key) => {\n  if (isBrowser && typeof localStorage !== 'undefined') return localStorage.getItem(key)\n  else return inMemoryLocalStorage.get(key) ?? null\n}\n\nconst defaultClientStorageSetter: StorageSetter = (key, value) => {\n  if (isBrowser && typeof localStorage !== 'undefined') {\n    if (value) {\n      localStorage.setItem(key, value)\n    } else {\n      localStorage.removeItem(key)\n    }\n  } else {\n    if (value) {\n      inMemoryLocalStorage.set(key, value)\n    } else if (inMemoryLocalStorage.has(key)) {\n      inMemoryLocalStorage.delete(key)\n    }\n  }\n}\n\nexport const localStorageGetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageGetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageGetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key) => {\n      if (isBrowser) {\n        return Cookies.get(key) ?? null\n      } else {\n        return null\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clientStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key) => clientStorage.getItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key) => clientStorage.get?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return (key) => clientStorage.getItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (clientStorage.getItem && clientStorage.removeItem) {\n      return clientStorage.getItem\n    }\n    if (clientStorage.getItemAsync) {\n      return clientStorage.getItemAsync\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing either \"getItem\" and \"removeItem\" properties or \"getItemAsync\" property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n\nexport const localStorageSetter = (\n  clientStorageType: ClientStorageType,\n  clientStorage?: ClientStorage\n): StorageSetter => {\n  if (clientStorageType === 'localStorage' || clientStorageType === 'web') {\n    return defaultClientStorageSetter\n  }\n  if (clientStorageType === 'cookie') {\n    return (key, value) => {\n      if (isBrowser) {\n        if (value) {\n          // TODO: Set expires based on the actual refresh token expire time\n          // For now, we're using 30 days so the cookie is not removed when the browser is closed because if `expiers` is omitted, the cookie becomes a session cookie.\n          Cookies.set(key, value, { expires: 30, sameSite: 'lax', httpOnly: false })\n        } else {\n          Cookies.remove(key)\n        }\n      }\n    }\n  }\n  if (!clientStorage) {\n    throw Error(\n      `clientStorageType is set to '${clientStorageType}' but no clienStorage has been given`\n    )\n  }\n  if (clientStorageType === 'react-native') {\n    return (key, value) =>\n      value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n  }\n  if (clientStorageType === 'capacitor') {\n    return (key, value) =>\n      value ? clientStorage.set?.({ key, value }) : clientStorage.remove?.({ key })\n  }\n  if (clientStorageType === 'expo-secure-storage') {\n    return async (key, value) =>\n      value ? clientStorage.setItemAsync?.(key, value) : clientStorage.deleteItemAsync?.(key)\n  }\n  if (clientStorageType === 'custom') {\n    if (!clientStorage.removeItem) {\n      throw Error(\n        `clientStorageType is set to 'custom' but clientStorage is missing a removeItem property`\n      )\n    }\n    if (clientStorage.setItem) {\n      return (key, value) =>\n        value ? clientStorage.setItem?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    if (clientStorage.setItemAsync) {\n      return async (key, value) =>\n        value ? clientStorage.setItemAsync?.(key, value) : clientStorage.removeItem?.(key)\n    }\n    throw Error(\n      `clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property`\n    )\n  }\n  throw Error(`Unknown storage type: ${clientStorageType}`)\n}\n", "import { AuthContext } from '../machines'\nimport { SessionActionHandlerResult } from '../promises'\nimport { NhostSession, SignUpResponse } from '../types'\n\nexport const getSession = (context?: AuthContext): NhostSession | null => {\n  if (!context || !context.accessToken.value || !context.accessToken.expiresAt || !context.user) {\n    return null\n  }\n  return {\n    accessToken: context.accessToken.value,\n    accessTokenExpiresIn: (context.accessToken.expiresAt.getTime() - Date.now()) / 1000,\n    refreshToken: context.refreshToken.value,\n    user: context.user\n  }\n}\n\nexport const getAuthenticationResult = ({\n  accessToken,\n  refreshToken,\n  isError,\n  user,\n  error\n}: SessionActionHandlerResult): SignUpResponse => {\n  if (isError) {\n    return {\n      session: null,\n      error\n    }\n  }\n  if (user && accessToken) {\n    return {\n      // TODO either return the refresh token or remove it from the session type\n      session: { accessToken, accessTokenExpiresIn: 0, refreshToken: refreshToken, user },\n      error: null\n    }\n  }\n  return { session: null, error: null }\n}\n", "export const isBrowser = () => typeof window !== 'undefined'\n", "import fetchPonyfill from 'fetch-ponyfill'\nimport { NETWORK_ERROR_CODE } from '../errors'\nimport { NullableErrorResponse } from '../types'\n\ndeclare const EdgeRuntime: any\n\ninterface FetcResponse<T> extends NullableErrorResponse {\n  data: T\n}\n\nlet fetch = globalThis.fetch\n\nif (typeof EdgeRuntime !== 'string') {\n  fetch = fetchPonyfill().fetch\n}\n\nconst fetchWrapper = async <T>(\n  url: string,\n  method: 'GET' | 'POST',\n  { token, body }: { token?: string | null; body?: any } = {}\n): Promise<FetcResponse<T>> => {\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    Accept: '*/*'\n  }\n  if (token) {\n    headers['Authorization'] = `Bearer ${token}`\n  }\n  const options: RequestInit = {\n    method,\n    headers\n  }\n  if (body) {\n    options.body = JSON.stringify(body)\n  }\n  try {\n    const result = await fetch(url, options)\n    if (!result.ok) {\n      const error = await result.json()\n      return Promise.reject<FetcResponse<T>>({ error })\n    }\n    try {\n      const data = await result.json()\n      return { data, error: null }\n    } catch {\n      console.warn(`Unexpected response: can't parse the response of the server at ${url}`)\n      return { data: 'OK' as any, error: null }\n    }\n  } catch (e) {\n    const error = {\n      message: 'Network Error',\n      status: NETWORK_ERROR_CODE,\n      error: 'network'\n    }\n    return Promise.reject<FetcResponse<T>>({ error })\n  }\n}\n\nexport const postFetch = async <T>(\n  url: string,\n  body: any,\n  token?: string | null\n): Promise<FetcResponse<T>> => fetchWrapper<T>(url, 'POST', { token, body })\n\nexport const getFetch = <T>(url: string, token?: string | null): Promise<FetcResponse<T>> =>\n  fetchWrapper<T>(url, 'GET', { token })\n", "import { RedirectOption } from '../types'\n\nexport const encodeQueryParameters = (baseUrl: string, parameters?: Record<string, unknown>) => {\n  const encodedParameters =\n    parameters &&\n    Object.entries(parameters)\n      .map(([key, value]) => {\n        const stringValue = Array.isArray(value)\n          ? value.join(',')\n          : typeof value === 'object'\n          ? JSON.stringify(value)\n          : (value as string)\n        return `${key}=${encodeURIComponent(stringValue)}`\n      })\n      .join('&')\n  if (encodedParameters) return `${baseUrl}?${encodedParameters}`\n  else return baseUrl\n}\n\n/**\n * Transform options that include a redirectTo property so the\n * redirect url is absolute, given a base clientUrl.\n * If no client url is given, any relative redirectUrl is removed while\n * the other options are sent as-is.\n * @param clientUrl base client url\n * @param options\n * @returns\n */\nexport const rewriteRedirectTo = <T extends RedirectOption>(\n  clientUrl?: string,\n  options?: T\n): (Omit<T, 'redirectTo'> & { redirectTo?: string }) | undefined => {\n  if (!options?.redirectTo) {\n    return options\n  }\n  const { redirectTo, ...otherOptions } = options\n  // * If the clientUrl is not defined, we can't rewrite the redirectTo\n  if (!clientUrl) {\n    // * If redirectTo is a relative path, we therefore pull it out of the options\n    if (redirectTo.startsWith('/')) {\n      return otherOptions\n    } else {\n      return options\n    }\n  }\n  const baseClientUrl = new URL(clientUrl)\n  const clientParams = Object.fromEntries(new URLSearchParams(baseClientUrl.search))\n  const url = new URL(redirectTo.startsWith('/') ? baseClientUrl.origin + redirectTo : redirectTo)\n  const additionalParams = new URLSearchParams(url.search)\n  let combinedParams = Object.fromEntries(additionalParams)\n\n  if (redirectTo.startsWith('/')) {\n    combinedParams = { ...clientParams, ...combinedParams }\n  }\n  let pathName = baseClientUrl.pathname\n  if (url.pathname.length > 1) {\n    pathName += url.pathname.slice(1)\n  }\n  return {\n    ...otherOptions,\n    redirectTo: encodeQueryParameters(url.origin + pathName, combinedParams)\n  }\n}\n\nexport function getParameterByName(name: string, url?: string) {\n  if (!url) {\n    if (typeof window === 'undefined') {\n      return\n    }\n    url = window.location?.href || ''\n  }\n  // eslint-disable-next-line no-useless-escape\n  name = name.replace(/[\\[\\]]/g, '\\\\$&')\n  const regex = new RegExp('[?&#]' + name + '(=([^&#]*)|&|#|$)'),\n    results = regex.exec(url)\n  if (!results) return null\n  if (!results[2]) return ''\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '))\n}\n\nexport function removeParameterFromWindow(name: string) {\n  if (typeof window === 'undefined') {\n    return\n  }\n  const location = window?.location\n  if (!location) {\n    return\n  }\n  if (location) {\n    const search = new URLSearchParams(location.search)\n    const hash = new URLSearchParams(location.hash?.slice(1))\n    search.delete(name)\n    hash.delete(name)\n    let url = window.location.pathname\n    if (Array.from(search).length) url += `?${search.toString()}`\n    if (Array.from(hash).length) url += `#${hash.toString()}`\n    window.history.pushState({}, '', url)\n  }\n}\n", "import { MIN_PASSWORD_LENGTH } from '../constants'\n\nexport const isValidEmail = (email?: string | null) =>\n  !!email &&\n  typeof email === 'string' &&\n  !!String(email)\n    .toLowerCase()\n    .match(\n      /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\n    )\n\nexport const isValidPassword = (password?: string | null) =>\n  !!password && typeof password === 'string' && password.length >= MIN_PASSWORD_LENGTH\n\n// TODO improve validation\nexport const isValidPhoneNumber = (phoneNumber?: string | null) =>\n  !!phoneNumber && typeof phoneNumber === 'string'\n\nexport const isValidTicket = (ticket?: string | null) =>\n  ticket &&\n  typeof ticket === 'string' &&\n  ticket.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i)\n", "import { startAuthentication, startRegistration } from '@simplewebauthn/browser'\nimport type {\n  AuthenticationCredentialJSON,\n  PublicKeyCredentialCreationOptionsJSON,\n  PublicKeyCredentialRequestOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { InterpreterFrom, assign, createMachine, send } from 'xstate'\nimport {\n  NHOST_JWT_EXPIRES_AT_KEY,\n  NHOST_REFRESH_TOKEN_ID_KEY,\n  NHOST_REFRESH_TOKEN_KEY,\n  REFRESH_TOKEN_MAX_ATTEMPTS,\n  TOKEN_REFRESH_MARGIN_SECONDS\n} from '../../constants'\nimport {\n  CodifiedError,\n  INVALID_EMAIL_ERROR,\n  INVALID_MFA_TICKET_ERROR,\n  INVALID_PASSWORD_ERROR,\n  INVALID_PHONE_NUMBER_ERROR,\n  NETWORK_ERROR_CODE,\n  NO_MFA_TICKET_ERROR,\n  VALIDATION_ERROR_CODE\n} from '../../errors'\nimport { localStorageGetter, localStorageSetter } from '../../local-storage'\nimport {\n  AuthErrorPayload,\n  AuthOptions,\n  DeanonymizeResponse,\n  NhostSession,\n  NhostSessionResponse,\n  PasswordlessEmailResponse,\n  PasswordlessSmsOtpResponse,\n  PasswordlessSmsResponse,\n  RefreshSessionResponse,\n  SignInAnonymousResponse,\n  SignInMfaTotpResponse,\n  SignInPATResponse,\n  SignInResponse,\n  SignOutResponse,\n  SignUpResponse\n} from '../../types'\nimport {\n  getParameterByName,\n  isValidEmail,\n  isValidPassword,\n  isValidPhoneNumber,\n  isValidTicket,\n  postFetch,\n  removeParameterFromWindow,\n  rewriteRedirectTo\n} from '../../utils'\nimport { AuthContext, INITIAL_MACHINE_CONTEXT } from './context'\nimport { AuthEvents } from './events'\n\nexport interface AuthMachineOptions extends AuthOptions {\n  backendUrl: string\n  clientUrl: string\n}\n\nexport type AuthMachine = ReturnType<typeof createAuthMachine>\nexport type AuthInterpreter = InterpreterFrom<AuthMachine>\n\ntype AuthServices = {\n  signInPassword: { data: SignInResponse }\n  passwordlessSms: { data: PasswordlessSmsResponse | DeanonymizeResponse }\n  passwordlessSmsOtp: { data: PasswordlessSmsOtpResponse }\n  passwordlessEmail: { data: PasswordlessEmailResponse | DeanonymizeResponse }\n  signInAnonymous: { data: SignInAnonymousResponse }\n  signInPAT: { data: SignInPATResponse }\n  signInMfaTotp: { data: SignInMfaTotpResponse }\n  signInSecurityKeyEmail: { data: SignInResponse }\n  refreshToken: { data: NhostSessionResponse }\n  signout: { data: SignOutResponse }\n  signUpEmailPassword: { data: SignUpResponse }\n  signUpSecurityKey: { data: SignUpResponse }\n  importRefreshToken: { data: NhostSessionResponse }\n}\n\nexport const createAuthMachine = ({\n  backendUrl,\n  clientUrl,\n  clientStorageType = 'web',\n  clientStorage,\n  refreshIntervalTime,\n  autoRefreshToken = true,\n  autoSignIn = true\n}: AuthMachineOptions) => {\n  const storageGetter = localStorageGetter(clientStorageType, clientStorage)\n  const storageSetter = localStorageSetter(clientStorageType, clientStorage)\n  const postRequest = async <T = any, D = any>(\n    url: string,\n    data?: D,\n    token?: string | null\n  ): Promise<T> => {\n    const result = await postFetch<T>(`${backendUrl}${url}`, data, token)\n\n    return result.data\n  }\n  return createMachine(\n    {\n      schema: {\n        context: {} as AuthContext,\n        events: {} as AuthEvents,\n        services: {} as AuthServices\n      },\n      tsTypes: {} as import('./machine.typegen').Typegen0,\n      context: INITIAL_MACHINE_CONTEXT,\n      predictableActionArguments: true,\n      id: 'nhost',\n      type: 'parallel',\n      states: {\n        authentication: {\n          initial: 'starting',\n          on: {\n            SESSION_UPDATE: [\n              {\n                cond: 'hasSession',\n                actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                target: '.signedIn'\n              }\n            ]\n          },\n          states: {\n            starting: {\n              tags: ['loading'],\n              always: { cond: 'isSignedIn', target: 'signedIn' },\n              invoke: {\n                id: 'importRefreshToken',\n                src: 'importRefreshToken',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: 'signedIn'\n                  },\n                  {\n                    target: 'signedOut'\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'shouldRetryImportToken',\n                    actions: 'incrementTokenImportAttempts',\n                    target: 'retryTokenImport'\n                  },\n                  { actions: ['saveAuthenticationError'], target: 'signedOut' }\n                ]\n              }\n            },\n            retryTokenImport: {\n              tags: ['loading'],\n              after: {\n                RETRY_IMPORT_TOKEN_DELAY: 'starting'\n              }\n            },\n            signedOut: {\n              initial: 'noErrors',\n              entry: 'reportSignedOut',\n              states: {\n                noErrors: {},\n                success: {},\n                needsSmsOtp: {},\n                needsMfa: {},\n                failed: {},\n                signingOut: {\n                  entry: ['clearContextExceptRefreshToken'],\n                  exit: ['destroyRefreshToken', 'reportTokenChanged'],\n                  invoke: {\n                    src: 'signout',\n                    id: 'signingOut',\n                    onDone: {\n                      target: 'success'\n                    },\n                    onError: {\n                      target: 'failed',\n                      actions: ['saveAuthenticationError']\n                    }\n                  }\n                }\n              },\n              on: {\n                SIGNIN_PASSWORD: 'authenticating.password',\n                SIGNIN_ANONYMOUS: 'authenticating.anonymous',\n                SIGNIN_SECURITY_KEY_EMAIL: 'authenticating.securityKeyEmail',\n                SIGNIN_MFA_TOTP: 'authenticating.mfa.totp',\n                SIGNIN_PAT: 'authenticating.pat'\n              }\n            },\n            authenticating: {\n              entry: 'resetErrors',\n              states: {\n                password: {\n                  invoke: {\n                    src: 'signInPassword',\n                    id: 'authenticateUserWithPassword',\n                    onDone: [\n                      {\n                        cond: 'hasMfaTicket',\n                        actions: ['saveMfaTicket'],\n                        target: '#nhost.authentication.signedOut.needsMfa'\n                      },\n                      {\n                        actions: ['saveSession', 'reportTokenChanged'],\n                        target: '#nhost.authentication.signedIn'\n                      }\n                    ],\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                },\n                pat: {\n                  invoke: {\n                    src: 'signInPAT',\n                    id: 'authenticateWithPAT',\n                    onDone: {\n                      actions: ['savePATSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                anonymous: {\n                  invoke: {\n                    src: 'signInAnonymous',\n                    id: 'authenticateAnonymously',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: {\n                      actions: 'saveAuthenticationError',\n                      target: '#nhost.authentication.signedOut.failed'\n                    }\n                  }\n                },\n                mfa: {\n                  states: {\n                    totp: {\n                      invoke: {\n                        src: 'signInMfaTotp',\n                        id: 'signInMfaTotp',\n                        onDone: {\n                          actions: ['saveSession', 'reportTokenChanged'],\n                          target: '#nhost.authentication.signedIn'\n                        },\n                        onError: {\n                          actions: ['saveAuthenticationError'],\n                          target: '#nhost.authentication.signedOut.failed'\n                        }\n                      }\n                    }\n                  }\n                },\n                securityKeyEmail: {\n                  invoke: {\n                    src: 'signInSecurityKeyEmail',\n                    id: 'authenticateUserWithSecurityKey',\n                    onDone: {\n                      actions: ['saveSession', 'reportTokenChanged'],\n                      target: '#nhost.authentication.signedIn'\n                    },\n                    onError: [\n                      {\n                        cond: 'unverified',\n                        target: [\n                          '#nhost.authentication.signedOut',\n                          '#nhost.registration.incomplete.needsEmailVerification'\n                        ]\n                      },\n                      {\n                        actions: 'saveAuthenticationError',\n                        target: '#nhost.authentication.signedOut.failed'\n                      }\n                    ]\n                  }\n                }\n              }\n            },\n            signedIn: {\n              type: 'parallel',\n              entry: ['reportSignedIn', 'cleanUrl', 'broadcastToken', 'resetErrors'],\n              on: {\n                SIGNOUT: 'signedOut.signingOut'\n              },\n              states: {\n                refreshTimer: {\n                  id: 'timer',\n                  initial: 'idle',\n                  states: {\n                    disabled: { type: 'final' },\n                    stopped: {\n                      always: {\n                        cond: 'noToken',\n                        target: 'idle'\n                      }\n                    },\n                    idle: {\n                      always: [\n                        { cond: 'isAutoRefreshDisabled', target: 'disabled' },\n                        { cond: 'isRefreshTokenPAT', target: 'disabled' },\n                        { cond: 'hasRefreshToken', target: 'running' }\n                      ]\n                    },\n                    running: {\n                      initial: 'pending',\n                      entry: 'resetTimer',\n                      states: {\n                        pending: {\n                          after: {\n                            '1000': {\n                              internal: false,\n                              target: 'pending'\n                            }\n                          },\n                          always: {\n                            cond: 'refreshTimerShouldRefresh',\n                            target: 'refreshing'\n                          }\n                        },\n                        refreshing: {\n                          invoke: {\n                            src: 'refreshToken',\n                            id: 'refreshToken',\n                            onDone: {\n                              actions: ['saveSession', 'resetTimer', 'reportTokenChanged'],\n                              target: 'pending'\n                            },\n                            onError: [{ actions: 'saveRefreshAttempt', target: 'pending' }]\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        },\n        token: {\n          initial: 'idle',\n          states: {\n            idle: {\n              on: {\n                TRY_TOKEN: 'running'\n              },\n              initial: 'noErrors',\n              states: { noErrors: {}, error: {} }\n            },\n            running: {\n              invoke: {\n                src: 'refreshToken',\n                id: 'authenticateWithToken',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: ['#nhost.authentication.signedIn', 'idle.noErrors']\n                },\n                onError: [\n                  { cond: 'isSignedIn', target: 'idle.error' },\n                  {\n                    actions: 'saveAuthenticationError',\n                    target: ['#nhost.authentication.signedOut.failed', 'idle.error']\n                  }\n                ]\n              }\n            }\n          }\n        },\n        registration: {\n          initial: 'incomplete',\n          on: {\n            SIGNED_IN: [{ cond: 'isAnonymous', target: '.incomplete' }, '.complete']\n          },\n          states: {\n            incomplete: {\n              on: {\n                SIGNUP_EMAIL_PASSWORD: 'emailPassword',\n                SIGNUP_SECURITY_KEY: 'securityKey',\n                PASSWORDLESS_EMAIL: 'passwordlessEmail',\n                PASSWORDLESS_SMS: 'passwordlessSms',\n                PASSWORDLESS_SMS_OTP: 'passwordlessSmsOtp'\n              },\n              initial: 'noErrors',\n              states: {\n                noErrors: {},\n                needsEmailVerification: {},\n                needsOtp: {},\n                failed: {}\n              }\n            },\n            emailPassword: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpEmailPassword',\n                id: 'signUpEmailPassword',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            securityKey: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'signUpSecurityKey',\n                id: 'signUpSecurityKey',\n                onDone: [\n                  {\n                    cond: 'hasSession',\n                    actions: ['saveSession', 'reportTokenChanged'],\n                    target: '#nhost.authentication.signedIn'\n                  },\n                  {\n                    actions: 'clearContext',\n                    target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                  }\n                ],\n                onError: [\n                  {\n                    cond: 'unverified',\n                    target: 'incomplete.needsEmailVerification'\n                  },\n                  {\n                    actions: 'saveRegistrationError',\n                    target: 'incomplete.failed'\n                  }\n                ]\n              }\n            },\n            passwordlessEmail: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessEmail',\n                id: 'passwordlessEmail',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsEmailVerification']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSms: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSms',\n                id: 'passwordlessSms',\n                onDone: {\n                  actions: 'clearContext',\n                  target: ['#nhost.authentication.signedOut', 'incomplete.needsOtp']\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n            passwordlessSmsOtp: {\n              entry: ['resetErrors'],\n              invoke: {\n                src: 'passwordlessSmsOtp',\n                id: 'passwordlessSmsOtp',\n                onDone: {\n                  actions: ['saveSession', 'reportTokenChanged'],\n                  target: '#nhost.authentication.signedIn'\n                },\n                onError: {\n                  actions: 'saveRegistrationError',\n                  target: 'incomplete.failed'\n                }\n              }\n            },\n\n            complete: {\n              on: {\n                SIGNED_OUT: 'incomplete'\n              }\n            }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        reportSignedIn: send('SIGNED_IN'),\n        reportSignedOut: send('SIGNED_OUT'),\n        reportTokenChanged: send('TOKEN_CHANGED'),\n        incrementTokenImportAttempts: assign({\n          importTokenAttempts: ({ importTokenAttempts }) => importTokenAttempts + 1\n        }),\n        clearContext: assign(() => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n          storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT\n          }\n        }),\n        clearContextExceptRefreshToken: assign(({ refreshToken: { value } }) => {\n          storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n          return {\n            ...INITIAL_MACHINE_CONTEXT,\n            refreshToken: { value }\n          }\n        }),\n\n        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine\n        saveSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken }\n          }\n        }),\n\n        savePATSession: assign({\n          user: (_, { data }) => data?.session?.user || null,\n          accessToken: (_, { data }) => {\n            if (data.session) {\n              const { accessTokenExpiresIn, accessToken } = data.session\n              const nextRefresh = new Date(Date.now() + accessTokenExpiresIn * 1_000)\n              storageSetter(NHOST_JWT_EXPIRES_AT_KEY, nextRefresh.toISOString())\n              return {\n                value: accessToken,\n                expiresAt: nextRefresh,\n                expiresInSeconds: accessTokenExpiresIn\n              }\n            }\n            storageSetter(NHOST_JWT_EXPIRES_AT_KEY, null)\n            return {\n              value: null,\n              expiresAt: null,\n              expiresInSeconds: null\n            }\n          },\n          refreshToken: (_, { data }) => {\n            const refreshToken = data.session?.refreshToken || null\n            const refreshTokenId = data.session?.refreshTokenId || null\n\n            if (refreshToken) {\n              storageSetter(NHOST_REFRESH_TOKEN_KEY, refreshToken)\n            }\n\n            if (refreshTokenId) {\n              storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, refreshTokenId)\n            }\n\n            return { value: refreshToken, isPAT: true }\n          }\n        }),\n\n        saveMfaTicket: assign({\n          mfa: (_, e) => e.data?.mfa\n        }),\n\n        resetTimer: assign({\n          refreshTimer: (_) => ({\n            startedAt: new Date(),\n            attempts: 0,\n            lastAttempt: null\n          })\n        }),\n\n        saveRefreshAttempt: assign({\n          refreshTimer: (ctx, e) => ({\n            startedAt: ctx.refreshTimer.startedAt,\n            attempts: ctx.refreshTimer.attempts + 1,\n            lastAttempt: new Date()\n          })\n        }),\n\n        // * Authentication errors\n        saveAuthenticationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({\n            ...errors,\n            authentication: error\n          })\n        }),\n        resetErrors: assign({\n          errors: (_) => ({}),\n          importTokenAttempts: (_) => 0\n        }),\n        saveRegistrationError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          errors: ({ errors }, { data: { error } }: any) => ({ ...errors, registration: error })\n        }),\n        destroyRefreshToken: assign({\n          refreshToken: (_) => {\n            storageSetter(NHOST_REFRESH_TOKEN_KEY, null)\n            storageSetter(NHOST_REFRESH_TOKEN_ID_KEY, null)\n            return { value: null }\n          }\n        }),\n\n        // * Clean the browser url when `autoSignIn` is activated\n        cleanUrl: () => {\n          if (autoSignIn && getParameterByName('refreshToken')) {\n            // * Remove the refresh token from the URL\n            removeParameterFromWindow('refreshToken')\n            removeParameterFromWindow('type')\n          }\n        },\n\n        // * Broadcast the token to other tabs when `autoSignIn` is activated\n        broadcastToken: (context) => {\n          if (autoSignIn) {\n            try {\n              const channel = new BroadcastChannel('nhost')\n              // ? broadcat session instead of token ?\n              channel.postMessage(context.refreshToken.value)\n            } catch (error) {\n              // * BroadcastChannel is not available e.g. react-native\n            }\n          }\n        }\n      },\n\n      guards: {\n        isAnonymous: (ctx, e) => !!ctx.user?.isAnonymous,\n        isSignedIn: (ctx) => !!ctx.user && !!ctx.accessToken.value,\n        noToken: (ctx) => !ctx.refreshToken.value,\n        isRefreshTokenPAT: (ctx) => !!ctx.refreshToken?.isPAT,\n        hasRefreshToken: (ctx) => !!ctx.refreshToken.value,\n        isAutoRefreshDisabled: () => !autoRefreshToken,\n        refreshTimerShouldRefresh: (ctx) => {\n          const { expiresAt } = ctx.accessToken\n          if (!expiresAt) {\n            return false\n          }\n          if (ctx.refreshTimer.lastAttempt) {\n            // * If the refresh timer reached the maximum number of attempts, we should not try again\n            if (ctx.refreshTimer.attempts > REFRESH_TOKEN_MAX_ATTEMPTS) {\n              return false\n            }\n            const elapsed = Date.now() - ctx.refreshTimer.lastAttempt.getTime()\n            // * Exponential backoff\n            return elapsed > Math.pow(2, ctx.refreshTimer.attempts - 1) * 5_000\n          }\n          if (refreshIntervalTime) {\n            // * If a refreshIntervalTime has been passed on as an option, it will notify\n            // * the token should be refershed when this interval is overdue\n            const elapsed = Date.now() - ctx.refreshTimer.startedAt!.getTime()\n            if (elapsed > refreshIntervalTime * 1_000) {\n              return true\n            }\n          }\n          // * In any case, it's time to refresh when there's less than\n          // * TOKEN_REFRESH_MARGIN_SECONDS seconds before the JWT exprires\n          const accessTokenExpirationTime = ctx.accessToken.expiresInSeconds\n\n          if (!accessTokenExpirationTime) {\n            return false\n          }\n\n          const expiresInMilliseconds = expiresAt.getTime() - Date.now()\n\n          // If the token expires in less time than the margin, we should use\n          // a margin based on the token expiration time to avoid refreshing\n          // the token infinitely\n          const remainingMilliseconds =\n            expiresInMilliseconds -\n            1_000 * Math.min(TOKEN_REFRESH_MARGIN_SECONDS, accessTokenExpirationTime * 0.5)\n\n          return remainingMilliseconds <= 0\n        },\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        /** Shoud retry to import the token on network error or any internal server error.\n         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.\n         */\n        shouldRetryImportToken: (ctx, e: any) =>\n          ctx.importTokenAttempts < REFRESH_TOKEN_MAX_ATTEMPTS &&\n          (e.data.error.status === NETWORK_ERROR_CODE || e.data.error.status >= 500),\n        // * Authentication errors\n        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n        unverified: (_, { data: { error } }: any) =>\n          error.status === 401 &&\n          // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)\n          (error.message === 'Email is not verified' || error.error === 'unverified-user'),\n\n        // * Event guards\n        hasSession: (_, e) => !!e.data?.session,\n        hasMfaTicket: (_, e) => !!e.data?.mfa\n      },\n\n      services: {\n        signInPassword: (_, { email, password }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject({ error: INVALID_PASSWORD_ERROR })\n          }\n          return postRequest<SignInResponse>('/signin/email-password', {\n            email,\n            password\n          })\n        },\n        signInPAT: (_context, { pat }) => {\n          return postRequest<SignInPATResponse>('/signin/pat', {\n            personalAccessToken: pat\n          })\n        },\n        passwordlessSms: (context, { phoneNumber, options }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            // TODO implement in hasura-auth\n            // * See https://github.com/nhost/hasura-auth/blob/9c6d0f4ded4fc8fd1b8031926c02796c74a7eada/src/routes/user/deanonymize.ts\n            console.warn(\n              'Deanonymisation from a phone number is not yet implemented in hasura-auth'\n            )\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'sms',\n                phoneNumber,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/sms', {\n              phoneNumber,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        passwordlessSmsOtp: (_, { phoneNumber, otp }) => {\n          if (!isValidPhoneNumber(phoneNumber)) {\n            return Promise.reject({ error: INVALID_PHONE_NUMBER_ERROR })\n          }\n          return postRequest('/signin/passwordless/sms/otp', {\n            phoneNumber,\n            otp\n          })\n        },\n        passwordlessEmail: (context, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject({ error: INVALID_EMAIL_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest(\n              '/user/deanonymize',\n              {\n                signInMethod: 'passwordless',\n                connection: 'email',\n                email,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest('/signin/passwordless/email', {\n              email,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signInAnonymous: (_) => postRequest('/signin/anonymous'),\n        signInMfaTotp: (context, data) => {\n          const ticket: string | undefined = data.ticket || context.mfa?.ticket\n          if (!ticket) {\n            return Promise.reject({ error: NO_MFA_TICKET_ERROR })\n          }\n          if (!isValidTicket(ticket)) {\n            return Promise.reject({ error: INVALID_MFA_TICKET_ERROR })\n          }\n\n          return postRequest('/signin/mfa/totp', {\n            ticket,\n            otp: data.otp\n          })\n        },\n        signInSecurityKeyEmail: async (_, { email }) => {\n          if (!isValidEmail(email)) {\n            throw new CodifiedError(INVALID_EMAIL_ERROR)\n          }\n          const options = await postRequest<PublicKeyCredentialRequestOptionsJSON>(\n            '/signin/webauthn',\n            { email }\n          )\n          let credential: AuthenticationCredentialJSON\n          try {\n            credential = await startAuthentication(options)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignInResponse>('/signin/webauthn/verify', { email, credential })\n        },\n        refreshToken: async (ctx, event) => {\n          const refreshToken = event.type === 'TRY_TOKEN' ? event.token : ctx.refreshToken.value\n          const session = await postRequest<RefreshSessionResponse>('/token', {\n            refreshToken\n          })\n          return { session, error: null }\n        },\n        signout: (ctx, e) =>\n          postRequest('/signout', {\n            refreshToken: ctx.refreshToken.value,\n            all: !!e.all\n          }),\n        signUpEmailPassword: async (context, { email, password, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          if (!isValidPassword(password)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_PASSWORD_ERROR })\n          }\n          if (context.user?.isAnonymous) {\n            return postRequest<SignUpResponse>(\n              '/user/deanonymize',\n              {\n                signInMethod: 'email-password',\n                email,\n                password,\n                options: rewriteRedirectTo(clientUrl, options)\n              },\n              context.accessToken.value\n            )\n          } else {\n            return postRequest<SignUpResponse>('/signup/email-password', {\n              email,\n              password,\n              options: rewriteRedirectTo(clientUrl, options)\n            })\n          }\n        },\n        signUpSecurityKey: async (_, { email, options }) => {\n          if (!isValidEmail(email)) {\n            return Promise.reject<SignUpResponse>({ error: INVALID_EMAIL_ERROR })\n          }\n          // TODO anonymous users\n          const nickname = options?.nickname\n          /*\n           * The `/signup/webauthn` endpoint accepts any option from SignUpOptions,\n           * We therefore remove the nickname from the options object before sending it to the server,\n           * as options if of type `SignUpSecurityKeyOptions`, which extends `SignUpOptions` with the optional `nickname` property.\n           */\n          if (nickname) delete options.nickname\n          const webAuthnOptions = await postRequest<PublicKeyCredentialCreationOptionsJSON>(\n            '/signup/webauthn',\n            { email, options }\n          )\n          let credential: RegistrationCredentialJSON\n          try {\n            credential = await startRegistration(webAuthnOptions)\n          } catch (e) {\n            throw new CodifiedError(e as Error)\n          }\n          return postRequest<SignUpResponse>('/signup/webauthn/verify', {\n            credential,\n            options: {\n              redirectTo: options?.redirectTo,\n              nickname\n            }\n          })\n        },\n        importRefreshToken: async (ctx) => {\n          if (\n            ctx.user &&\n            ctx.refreshToken.value &&\n            ctx.accessToken.value &&\n            ctx.accessToken.expiresAt\n          ) {\n            // * Do not import refresh token if the session already exists (loaded through initial state)\n            // TODO this should eventually be handled upstream in the state machine\n            return {\n              session: {\n                accessToken: ctx.accessToken.value,\n                accessTokenExpiresIn: ctx.accessToken.expiresAt.getTime() - Date.now(),\n                refreshToken: ctx.refreshToken.value,\n                user: ctx.user\n              },\n              error: null\n            }\n          }\n          let error: AuthErrorPayload | null = null\n          if (autoSignIn) {\n            const urlToken = getParameterByName('refreshToken') || null\n            if (urlToken) {\n              try {\n                const session = await postRequest<NhostSession>('/token', {\n                  refreshToken: urlToken\n                })\n                return { session, error: null }\n              } catch (exception) {\n                error = (exception as { error: AuthErrorPayload }).error\n              }\n            } else {\n              const error = getParameterByName('error')\n              if (error) {\n                return Promise.reject<NhostSessionResponse>({\n                  session: null,\n                  error: {\n                    status: VALIDATION_ERROR_CODE,\n                    error,\n                    message: getParameterByName('errorDescription') || error\n                  }\n                })\n              }\n            }\n          }\n          const storageToken = await storageGetter(NHOST_REFRESH_TOKEN_KEY)\n          if (storageToken) {\n            try {\n              const session = await postRequest<NhostSession>('/token', {\n                refreshToken: storageToken\n              })\n              return { session, error: null }\n            } catch (exception) {\n              error = (exception as { error: AuthErrorPayload }).error\n            }\n          }\n          if (error) {\n            return Promise.reject<NhostSessionResponse>({ error, session: null })\n          }\n          return { error: null, session: null }\n        }\n      },\n      delays: {\n        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts }) => {\n          // * Exponential backoff\n          return Math.pow(2, importTokenAttempts - 1) * 5_000\n        }\n      }\n    }\n  )\n}\n", "import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangeEmailOptions, ChangeEmailResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ChangeEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type ChangeEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ChangeEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangeEmailServices = {\n  request: { data: ChangeEmailResponse }\n}\n\nexport type ChangeEmailMachine = ReturnType<typeof createChangeEmailMachine>\n\nexport const createChangeEmailMachine = ({ backendUrl, clientUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangeEmailContext,\n        events: {} as ChangeEmailEvents,\n        services: {} as ChangeEmailServices\n      },\n      tsTypes: {} as import('./change-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changeEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        // TODO change email in the main machine (context.user.email)\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: async (_, { email, options }) => {\n          const res = await postFetch(\n            `${backendUrl}/user/email/change`,\n            { newEmail: email, options: rewriteRedirectTo(clientUrl, options) },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n", "import { assign, createMachine, send } from 'xstate'\nimport { INVALID_PASSWORD_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ChangePasswordResponse } from '../types'\nimport { postFetch } from '../utils'\nimport { isValidPassword } from '../utils/validators'\n\nexport type ChangePasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ChangePasswordEvents =\n  | {\n      type: 'REQUEST'\n      password?: string\n      ticket?: string\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ChangePasswordServices = {\n  requestChange: { data: ChangePasswordResponse }\n}\n\nexport type ChangePasswordMachine = ReturnType<typeof createChangePasswordMachine>\n\nexport const createChangePasswordMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ChangePasswordContext,\n        events: {} as ChangePasswordEvents,\n        services: {} as ChangePasswordServices\n      },\n      tsTypes: {} as import('./change-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidPassword',\n                actions: 'saveInvalidPasswordError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidPasswordError: assign({ error: (_) => INVALID_PASSWORD_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidPassword: (_, { password }) => !isValidPassword(password)\n      },\n      services: {\n        requestChange: (_, { password, ticket }) =>\n          postFetch<ChangePasswordResponse>(\n            `${backendUrl}/user/password`,\n            { newPassword: password, ticket: ticket },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n", "import { assign, createMachine, send } from 'xstate'\nimport { INVALID_MFA_CODE_ERROR, INVALID_MFA_TYPE_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload } from '../types'\nimport { getFetch, postFetch } from '../utils'\n\nexport type EnableMfaContext = {\n  error: AuthErrorPayload | null\n  imageUrl: string | null\n  secret: string | null\n}\n\nexport type EnableMfaEvents =\n  | {\n      type: 'GENERATE'\n    }\n  | {\n      type: 'ACTIVATE'\n      code?: string\n      activeMfaType: 'totp'\n    }\n  | { type: 'GENERATED' }\n  | { type: 'GENERATED_ERROR'; error: AuthErrorPayload | null }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type EnableMfadMachine = ReturnType<typeof createEnableMfaMachine>\n\nexport const createEnableMfaMachine = ({ backendUrl, interpreter }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as EnableMfaContext,\n        events: {} as EnableMfaEvents\n      },\n      tsTypes: {} as import('./enable-mfa.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'enableMfa',\n      initial: 'idle',\n      context: { error: null, imageUrl: null, secret: null },\n      states: {\n        idle: {\n          initial: 'initial',\n          on: {\n            GENERATE: 'generating'\n          },\n          states: {\n            initial: {},\n            error: {}\n          }\n        },\n        generating: {\n          invoke: {\n            src: 'generate',\n            id: 'generate',\n            onDone: { target: 'generated', actions: ['reportGeneratedSuccess', 'saveGeneration'] },\n            onError: { actions: ['saveError', 'reportGeneratedError'], target: 'idle.error' }\n          }\n        },\n        generated: {\n          initial: 'idle',\n          states: {\n            idle: {\n              initial: 'idle',\n              on: {\n                ACTIVATE: [\n                  {\n                    cond: 'invalidMfaType',\n                    actions: 'saveInvalidMfaTypeError',\n                    target: '.error'\n                  },\n                  {\n                    cond: 'invalidMfaCode',\n                    actions: 'saveInvalidMfaCodeError',\n                    target: '.error'\n                  },\n                  {\n                    target: 'activating'\n                  }\n                ]\n              },\n              states: { idle: {}, error: {} }\n            },\n            activating: {\n              invoke: {\n                src: 'activate',\n                id: 'activate',\n                onDone: { target: 'activated', actions: 'reportSuccess' },\n                onError: { actions: ['saveError', 'reportError'], target: 'idle.error' }\n              }\n            },\n            activated: { type: 'final' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidMfaTypeError: assign({ error: (_) => INVALID_MFA_TYPE_ERROR }),\n        saveInvalidMfaCodeError: assign({ error: (_) => INVALID_MFA_CODE_ERROR }),\n        saveError: assign({\n          error: (_, { data: { error } }: any) => error\n        }),\n        saveGeneration: assign({\n          imageUrl: (_, { data: { imageUrl } }: any) => imageUrl,\n          secret: (_, { data: { totpSecret } }: any) => totpSecret\n        }),\n        reportError: send((ctx, event) => {\n          console.log('REPORT', ctx, event)\n          return { type: 'ERROR', error: ctx.error }\n        }),\n        reportSuccess: send('SUCCESS'),\n        reportGeneratedSuccess: send('GENERATED'),\n        reportGeneratedError: send((ctx) => ({ type: 'GENERATED_ERROR', error: ctx.error }))\n      },\n      guards: {\n        invalidMfaCode: (_, { code }) => !code,\n        invalidMfaType: (_, { activeMfaType }) => !activeMfaType || activeMfaType !== 'totp'\n      },\n      services: {\n        generate: async (_) => {\n          const { data } = await getFetch(\n            `${backendUrl}/mfa/totp/generate`,\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n          return data\n        },\n        activate: (_, { code, activeMfaType }) =>\n          postFetch(\n            `${backendUrl}/user/mfa`,\n            { code, activeMfaType },\n            interpreter?.getSnapshot().context.accessToken.value\n          )\n      }\n    }\n  )\n}\n", "import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, ResetPasswordOptions, ResetPasswordResponse } from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type ResetPasswordContext = {\n  error: AuthErrorPayload | null\n}\nexport type ResetPasswordEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: ResetPasswordOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type ResetPasswordServices = {\n  requestChange: { data: ResetPasswordResponse }\n}\n\nexport type ResetPasswordMachine = ReturnType<typeof createResetPasswordMachine>\n\nexport const createResetPasswordMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as ResetPasswordContext,\n        events: {} as ResetPasswordEvents,\n        services: {} as ResetPasswordServices\n      },\n      tsTypes: {} as import('./reset-password.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'changePassword',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'requestChange',\n            id: 'requestChange',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        requestChange: (_, { email, options }) =>\n          postFetch<ResetPasswordResponse>(`${backendUrl}/user/password/reset`, {\n            email,\n            options: rewriteRedirectTo(clientUrl, options)\n          })\n      }\n    }\n  )\n}\n", "import { assign, createMachine, send } from 'xstate'\nimport { INVALID_EMAIL_ERROR } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport {\n  AuthErrorPayload,\n  SendVerificationEmailOptions,\n  SendVerificationEmailResponse\n} from '../types'\nimport { postFetch, rewriteRedirectTo } from '../utils'\nimport { isValidEmail } from '../utils/validators'\n\nexport type SendVerificationEmailContext = {\n  error: AuthErrorPayload | null\n}\n\nexport type SendVerificationEmailEvents =\n  | {\n      type: 'REQUEST'\n      email?: string\n      options?: SendVerificationEmailOptions\n    }\n  | { type: 'SUCCESS' }\n  | { type: 'ERROR'; error: AuthErrorPayload | null }\n\nexport type SendVerificationEmailServices = {\n  request: { data: SendVerificationEmailResponse }\n}\n\nexport type SendVerificationEmailMachine = ReturnType<typeof createSendVerificationEmailMachine>\nexport const createSendVerificationEmailMachine = ({ backendUrl, clientUrl }: AuthClient) => {\n  return createMachine(\n    {\n      schema: {\n        context: {} as SendVerificationEmailContext,\n        events: {} as SendVerificationEmailEvents,\n        services: {} as SendVerificationEmailServices\n      },\n      tsTypes: {} as import('./send-verification-email.typegen').Typegen0,\n      predictableActionArguments: true,\n      id: 'sendVerificationEmail',\n      initial: 'idle',\n      context: { error: null },\n      states: {\n        idle: {\n          on: {\n            REQUEST: [\n              {\n                cond: 'invalidEmail',\n                actions: 'saveInvalidEmailError',\n                target: '.error'\n              },\n              {\n                target: 'requesting'\n              }\n            ]\n          },\n          initial: 'initial',\n          states: {\n            initial: {},\n            success: {},\n            error: {}\n          }\n        },\n        requesting: {\n          invoke: {\n            src: 'request',\n            id: 'request',\n            onDone: { target: 'idle.success', actions: 'reportSuccess' },\n            onError: { actions: ['saveRequestError', 'reportError'], target: 'idle.error' }\n          }\n        }\n      }\n    },\n    {\n      actions: {\n        saveInvalidEmailError: assign({ error: (_) => INVALID_EMAIL_ERROR }),\n        saveRequestError: assign({\n          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037\n          error: (_, { data: { error } }: any) => error\n        }),\n        reportError: send((ctx) => ({ type: 'ERROR', error: ctx.error })),\n        reportSuccess: send('SUCCESS')\n      },\n      guards: {\n        invalidEmail: (_, { email }) => !isValidEmail(email)\n      },\n      services: {\n        request: async (_, { email, options }) => {\n          const res = await postFetch<SendVerificationEmailResponse>(\n            `${backendUrl}/user/email/send-verification-email`,\n            { email, options: rewriteRedirectTo(clientUrl, options) }\n          )\n          return res.data\n        }\n      }\n    }\n  )\n}\n", "import { interpret } from 'xstate'\nimport { AuthInterpreter, AuthMachine, AuthMachineOptions, createAuthMachine } from './machines'\nimport { NhostSession } from './types'\nimport { isBrowser } from './utils'\n\nexport type NhostClientOptions = AuthMachineOptions & {\n  /** @internal create and start xstate interpreter on creation. With React, it is started inside the Nhost provider */\n  start?: boolean\n}\n\n/**\n * @internal\n * This is a private API.\n */\nexport class AuthClient {\n  readonly backendUrl: string\n  readonly clientUrl: string\n  private _machine: AuthMachine\n  private _interpreter?: AuthInterpreter\n  private _started = false\n  private _channel?: BroadcastChannel\n  private _subscriptionsQueue: Set<(client: AuthClient) => void> = new Set()\n  private _subscriptions: Set<() => void> = new Set()\n\n  constructor({\n    clientStorageType = 'web',\n    autoSignIn = true,\n    autoRefreshToken = true,\n    start = true,\n    backendUrl,\n    clientUrl,\n    devTools,\n    ...defaultOptions\n  }: NhostClientOptions) {\n    this.backendUrl = backendUrl\n    this.clientUrl = clientUrl\n\n    this._machine = createAuthMachine({\n      ...defaultOptions,\n      backendUrl,\n      clientUrl,\n      clientStorageType,\n      autoSignIn,\n      autoRefreshToken\n    })\n\n    if (start) {\n      this.start({ devTools })\n    }\n\n    if (typeof window !== 'undefined' && autoSignIn) {\n      try {\n        // TODO listen to sign out\n        // TODO the same refresh token is used and refreshed by all tabs\n        // * Ideally, a single tab should autorefresh and share the new jwt\n        this._channel = new BroadcastChannel('nhost')\n        this._channel.addEventListener('message', (token) => {\n          const existingToken = this.interpreter?.getSnapshot().context.refreshToken.value\n          if (this.interpreter && token.data !== existingToken) {\n            this.interpreter.send('TRY_TOKEN', { token: token.data })\n          }\n        })\n      } catch (error) {\n        // * BroadcastChannel is not available e.g. react-native\n      }\n    }\n  }\n\n  start({\n    devTools = false,\n    initialSession,\n    interpreter\n  }: { interpreter?: AuthInterpreter; initialSession?: NhostSession; devTools?: boolean } = {}) {\n    const context = { ...this.machine.context }\n    if (initialSession) {\n      context.user = initialSession.user\n      context.refreshToken.value = initialSession.refreshToken ?? null\n      context.accessToken.value = initialSession.accessToken ?? null\n      context.accessToken.expiresAt = new Date(\n        Date.now() + initialSession.accessTokenExpiresIn * 1_000\n      )\n    }\n    const machineWithInitialContext = this.machine.withContext(context)\n\n    if (!this._interpreter) {\n      this._interpreter = interpreter || interpret(machineWithInitialContext, { devTools })\n    }\n\n    // * Start the interpreter if not started already. Always restart the interpreter when on the server side\n    if (!this._started || typeof window === 'undefined') {\n      if (this._interpreter.initialized) {\n        this._interpreter.stop()\n        this._subscriptions.forEach((fn) => fn())\n      }\n      this._interpreter.start(machineWithInitialContext.initialState)\n      this._subscriptionsQueue.forEach((fn) => fn(this))\n    }\n\n    this._started = true\n  }\n\n  public get machine() {\n    return this._machine\n  }\n\n  get interpreter(): AuthInterpreter | undefined {\n    return this._interpreter\n  }\n\n  get started(): boolean {\n    return this._started\n  }\n\n  subscribe(fn: (client: AuthClient) => () => void): () => void {\n    if (this.started) {\n      // * The interpreter is already available: we can add the listener straight ahead\n      const subscription = fn(this)\n      this._subscriptions.add(subscription)\n      return subscription\n    } else {\n      // * The interpreter is not yet available: we add the listener to a queue that will be started when setting the interpreter\n      // * Note: in React, the Xstate interpreter does not start from the global state, but from the root component\n      this._subscriptionsQueue.add(fn)\n      return () => {\n        console.log(\n          'onTokenChanged was added before the interpreter started. Cannot unsubscribe listener.'\n        )\n      }\n    }\n  }\n}\n\n/** @deprecated Not in use anymore. Use `clientStorageType: 'cookie'` instead */\nexport class AuthCookieClient extends AuthClient {\n  constructor({\n    ...options\n  }: Omit<\n    NhostClientOptions,\n    'clientStorageGetter' | 'clientStorageSetter' | 'clientStorage' | 'clientStorageType'\n  >) {\n    super({\n      ...options,\n      autoSignIn: isBrowser() && options.autoSignIn,\n      autoRefreshToken: isBrowser() && options.autoRefreshToken,\n      clientStorageType: 'cookie'\n    })\n  }\n}\n\n/** @deprecated Alias for {@link AuthCookieClient} */\nexport const AuthClientSSR = AuthCookieClient\n", "import { startRegistration } from '@simplewebauthn/browser'\nimport {\n  PublicKeyCredentialCreationOptionsJSON,\n  RegistrationCredentialJSON\n} from '@simplewebauthn/typescript-types'\nimport { postFetch } from '..'\nimport { CodifiedError } from '../errors'\nimport { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, SecurityKey } from '../types'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface AddSecurityKeyHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  key?: SecurityKey\n}\n\nexport interface AddSecurityKeyState extends AddSecurityKeyHandlerResult, AuthActionLoadingState {}\n\nexport const addSecurityKeyPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  nickname?: string\n): Promise<AddSecurityKeyHandlerResult> => {\n  try {\n    const { data: options } = await postFetch<PublicKeyCredentialCreationOptionsJSON>(\n      `${backendUrl}/user/webauthn/add`,\n      {},\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    let credential: RegistrationCredentialJSON\n    try {\n      credential = await startRegistration(options)\n    } catch (e) {\n      throw new CodifiedError(e as Error)\n    }\n    const { data: key } = await postFetch<SecurityKey>(\n      `${backendUrl}/user/webauthn/verify`,\n      { credential, nickname },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n    return { key, isError: false, error: null, isSuccess: true }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false }\n  }\n}\n", "import { InterpreterFrom } from 'xstate'\n\nimport { ChangeEmailMachine } from '../machines'\nimport { ChangeEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, NeedsEmailVerificationState } from './types'\nexport interface ChangeEmailHandlerResult\n  extends AuthActionErrorState,\n    NeedsEmailVerificationState {}\n\nexport interface ChangeEmailState extends ChangeEmailHandlerResult, AuthActionLoadingState {}\n\nexport const changeEmailPromise = async (\n  interpreter: InterpreterFrom<ChangeEmailMachine>,\n  email: string,\n  options?: ChangeEmailOptions\n): Promise<ChangeEmailHandlerResult> =>\n  new Promise<ChangeEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((s) => {\n      if (s.matches({ idle: 'error' })) {\n        resolve({ error: s.context.error, isError: true, needsEmailVerification: false })\n      } else if (s.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, needsEmailVerification: true })\n      }\n    })\n  })\n", "import { InterpreterFrom } from 'xstate'\n\nimport { ChangePasswordMachine } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface ChangePasswordState extends ChangePasswordHandlerResult, AuthActionLoadingState {}\n\nexport interface ChangePasswordHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\n\nexport const changePasswordPromise = async (\n  interpreter: InterpreterFrom<ChangePasswordMachine>,\n  password: string,\n  ticket?: string\n): Promise<ChangePasswordHandlerResult> =>\n  new Promise<ChangePasswordHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      password,\n      ticket\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSuccess: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n", "import { InterpreterFrom } from 'xstate'\n\nimport { EnableMfadMachine } from '../machines'\n\nimport { AuthActionErrorState } from './types'\n\nexport interface GenerateQrCodeHandlerResult extends AuthActionErrorState {\n  qrCodeDataUrl: string\n  isGenerated: boolean\n}\n\nexport interface GenerateQrCodeState extends GenerateQrCodeHandlerResult {\n  isGenerating: boolean\n}\nexport interface ActivateMfaHandlerResult extends AuthActionErrorState {\n  isActivated: boolean\n}\n\nexport interface ActivateMfaState extends ActivateMfaHandlerResult {\n  isActivating: boolean\n}\n\nexport const generateQrCodePromise = (service: InterpreterFrom<EnableMfadMachine>) =>\n  new Promise<GenerateQrCodeHandlerResult>((resolve) => {\n    service.send('GENERATE')\n    service.onTransition((state) => {\n      if (state.matches('generated')) {\n        resolve({\n          error: null,\n          isError: false,\n          isGenerated: true,\n          qrCodeDataUrl: state.context.imageUrl || ''\n        })\n      } else if (state.matches({ idle: 'error' })) {\n        resolve({\n          error: state.context.error || null,\n          isError: true,\n          isGenerated: false,\n          qrCodeDataUrl: ''\n        })\n      }\n    })\n  })\nexport const activateMfaPromise = (service: InterpreterFrom<EnableMfadMachine>, code: string) =>\n  new Promise<ActivateMfaHandlerResult>((resolve) => {\n    service.send('ACTIVATE', {\n      activeMfaType: 'totp',\n      code\n    })\n    service.onTransition((state) => {\n      if (state.matches({ generated: 'activated' })) {\n        resolve({ error: null, isActivated: true, isError: false })\n      } else if (state.matches({ generated: { idle: 'error' } })) {\n        resolve({ error: state.context.error, isActivated: false, isError: true })\n      }\n    })\n  })\n", "import { InterpreterFrom } from 'xstate'\n\nimport { ResetPasswordMachine } from '../machines'\nimport { ResetPasswordOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface ResetPasswordHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when an email to reset the password has been sent */\n  isSent: boolean\n}\n\nexport interface ResetPasswordState extends ResetPasswordHandlerResult, AuthActionLoadingState {}\n\nexport const resetPasswordPromise = async (\n  interpreter: InterpreterFrom<ResetPasswordMachine>,\n  email: string,\n  options?: ResetPasswordOptions\n): Promise<ResetPasswordHandlerResult> =>\n  new Promise((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n", "import { InterpreterFrom } from 'xstate'\n\nimport { SendVerificationEmailMachine } from '../machines'\nimport { SendVerificationEmailOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState } from './types'\n\nexport interface SendVerificationEmailHandlerResult extends AuthActionErrorState {\n  /** Returns `true` when a new verification email has been sent */\n  isSent: boolean\n}\n\nexport interface SendVerificationEmailState\n  extends AuthActionLoadingState,\n    SendVerificationEmailHandlerResult {}\n\nexport const sendVerificationEmailPromise = (\n  interpreter: InterpreterFrom<SendVerificationEmailMachine>,\n  email: string,\n  options?: SendVerificationEmailOptions\n): Promise<SendVerificationEmailHandlerResult> =>\n  new Promise<SendVerificationEmailHandlerResult>((resolve) => {\n    interpreter.send('REQUEST', {\n      email,\n      options\n    })\n    interpreter.onTransition((state) => {\n      if (state.matches({ idle: 'error' })) {\n        resolve({ error: state.context.error, isError: true, isSent: false })\n      } else if (state.matches({ idle: 'success' })) {\n        resolve({ error: null, isError: false, isSent: true })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInAnonymousHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInAnonymousState\n  extends SignInAnonymousHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInAnonymousPromise = (\n  interpreter: AuthInterpreter\n): Promise<SignInAnonymousHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_ANONYMOUS')\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          isSuccess: true,\n          isError: false,\n          error: null,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      }\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          isSuccess: false,\n          isError: true,\n          error: state.context.errors.authentication || null,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {\n  needsMfaOtp: boolean\n  mfa: {\n    ticket: string\n  } | null\n}\n\nexport interface SignInEmailPasswordState\n  extends SignInEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string\n) =>\n  new Promise<SignInEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_PASSWORD', {\n      email,\n      password\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        needsMfaOtp: false,\n        mfa: null,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'needsMfa' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: true,\n          mfa: state.context.mfa,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          needsMfaOtp: false,\n          mfa: null,\n          user: state.context.user\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\nexport interface SignInEmailPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {}\nexport interface SignInEmailPasswordlessState\n  extends SignInEmailPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInEmailPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_EMAIL', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({ error: null, isError: false, isSuccess: true })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignInSecurityKeyPasswordlessHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignInSecurityKeyPasswordlessState\n  extends SignInSecurityKeyPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInEmailSecurityKeyPromise = (interpreter: AuthInterpreter, email: string) =>\n  new Promise<SignInSecurityKeyPasswordlessHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send({ type: 'SIGNIN_SECURITY_KEY_EMAIL', email })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInMfaTotpHandlerResult extends SessionActionHandlerResult {}\n\nexport interface SignInMfaTotpState extends SignInMfaTotpHandlerResult, AuthActionLoadingState {}\n\nexport const signInMfaTotpPromise = (interpreter: AuthInterpreter, otp: string, ticket?: string) =>\n  new Promise<SignInMfaTotpHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNIN_MFA_TOTP', {\n      otp,\n      ticket\n    })\n    if (!changed) {\n      return resolve({\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInPATHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInPATState extends SignInPATHandlerResult, AuthActionLoadingState {}\n\nexport const signInPATPromise = (\n  interpreter: AuthInterpreter,\n  pat: string\n): Promise<SignInPATHandlerResult> =>\n  new Promise((resolve) => {\n    const { changed } = interpreter.send('SIGNIN_PAT', { pat })\n\n    if (!changed) {\n      resolve({\n        isSuccess: false,\n        isError: true,\n        error: USER_ALREADY_SIGNED_IN,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'failed' } })) {\n        return resolve({\n          accessToken: null,\n          refreshToken: null,\n          user: null,\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false\n        })\n      }\n\n      if (state.matches({ authentication: 'signedIn' })) {\n        return resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          user: state.context.user,\n          error: null,\n          isError: false,\n          isSuccess: true\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { PasswordlessOptions } from '../types'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignInSmsPasswordlessState\n  extends SignInSmsPasswordlessHandlerResult,\n    AuthActionLoadingState {}\n\nexport interface SignInSmsPasswordlessHandlerResult\n  extends AuthActionErrorState,\n    AuthActionSuccessState {\n  /**\n   * Returns true when the one-time password has been sent over by SMS, and the user needs to send it back to complete sign-in.\n   */\n  needsOtp: boolean\n}\n\nexport const signInSmsPasswordlessPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  options?: PasswordlessOptions\n) =>\n  new Promise<SignInSmsPasswordlessHandlerResult>((resolve) => {\n    const { changed } = interpreter.send('PASSWORDLESS_SMS', { phoneNumber, options })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        needsOtp: false\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.needsOtp')) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsOtp: true\n        })\n      } else if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          needsOtp: false\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionLoadingState, SessionActionHandlerResult } from './types'\n\nexport interface SignInSmsPasswordlessOtpHandlerResult extends SessionActionHandlerResult {}\nexport interface SignInSmsPasswordlessOtpState\n  extends SignInSmsPasswordlessOtpHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signInSmsPasswordlessOtpPromise = (\n  interpreter: AuthInterpreter,\n  phoneNumber: string,\n  otp: string\n) =>\n  new Promise<SignInSmsPasswordlessOtpHandlerResult>((resolve) => {\n    const { changed } = interpreter.send({ type: 'PASSWORDLESS_SMS_OTP', phoneNumber, otp })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        isError: true,\n        isSuccess: false,\n        user: null,\n        accessToken: null,\n        refreshToken: null\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: 'signedIn' })) {\n        resolve({\n          error: null,\n          isError: false,\n          isSuccess: true,\n          user: state.context.user,\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value\n        })\n      } else if (state.matches({ registration: { incomplete: 'failed' } })) {\n        resolve({\n          error: state.context.errors.authentication || null,\n          isError: true,\n          isSuccess: false,\n          user: null,\n          accessToken: null,\n          refreshToken: null\n        })\n      }\n    })\n  })\n", "import { USER_UNAUTHENTICATED } from '../errors'\nimport { AuthInterpreter } from '../machines'\n\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface SignOutlessHandlerResult extends AuthActionErrorState, AuthActionSuccessState {}\nexport interface SignOutlessState extends SignOutlessHandlerResult, AuthActionLoadingState {}\n\nexport const signOutPromise = async (\n  interpreter: AuthInterpreter,\n  all?: boolean\n): Promise<SignOutlessHandlerResult> =>\n  new Promise<SignOutlessHandlerResult>((resolve) => {\n    const { event } = interpreter.send('SIGNOUT', { all })\n    if (event.type !== 'SIGNED_OUT') {\n      return resolve({ isSuccess: false, isError: true, error: USER_UNAUTHENTICATED })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches({ authentication: { signedOut: 'success' } })) {\n        resolve({ isSuccess: true, isError: false, error: null })\n      } else if (state.matches('authentication.signedOut.failed')) {\n        resolve({ isSuccess: false, isError: true, error: state.context.errors.signout || null })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { SignUpOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpEmailPasswordHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpEmailPasswordState\n  extends SignUpEmailPasswordHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailPasswordPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  password: string,\n  options?: SignUpOptions\n): Promise<SignUpEmailPasswordHandlerResult> =>\n  new Promise<SignUpEmailPasswordHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_EMAIL_PASSWORD', {\n      email,\n      password,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n", "import { USER_ALREADY_SIGNED_IN } from '../errors'\nimport { AuthInterpreter } from '../machines'\nimport { SignUpSecurityKeyOptions } from '../types'\n\nimport {\n  AuthActionLoadingState,\n  NeedsEmailVerificationState,\n  SessionActionHandlerResult\n} from './types'\n\nexport interface SignUpSecurityKeyHandlerResult\n  extends SessionActionHandlerResult,\n    NeedsEmailVerificationState {}\n\nexport interface SignUpSecurityKeyState\n  extends SignUpSecurityKeyHandlerResult,\n    AuthActionLoadingState {}\n\nexport const signUpEmailSecurityKeyPromise = (\n  interpreter: AuthInterpreter,\n  email: string,\n  options?: SignUpSecurityKeyOptions\n): Promise<SignUpSecurityKeyHandlerResult> =>\n  new Promise<SignUpSecurityKeyHandlerResult>((resolve) => {\n    const { changed, context } = interpreter.send('SIGNUP_SECURITY_KEY', {\n      email,\n      options\n    })\n    if (!changed) {\n      return resolve({\n        error: USER_ALREADY_SIGNED_IN,\n        accessToken: context.accessToken.value,\n        refreshToken: context.refreshToken.value,\n        isError: true,\n        isSuccess: false,\n        needsEmailVerification: false,\n        user: context.user\n      })\n    }\n    interpreter.onTransition((state) => {\n      if (state.matches('registration.incomplete.failed')) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: state.context.errors.registration || null,\n          isError: true,\n          isSuccess: false,\n          needsEmailVerification: false,\n          user: null\n        })\n      } else if (\n        state.matches({\n          authentication: { signedOut: 'noErrors' },\n          registration: { incomplete: 'needsEmailVerification' }\n        })\n      ) {\n        resolve({\n          accessToken: null,\n          refreshToken: null,\n          error: null,\n          isError: false,\n          isSuccess: false,\n          needsEmailVerification: true,\n          user: null\n        })\n      } else if (state.matches({ authentication: 'signedIn', registration: 'complete' })) {\n        resolve({\n          accessToken: state.context.accessToken.value,\n          refreshToken: state.context.refreshToken.value,\n          error: null,\n          isError: false,\n          isSuccess: true,\n          needsEmailVerification: false,\n          user: state.context.user\n        })\n      }\n    })\n  })\n", "import { AuthClient } from '../internal-client'\nimport { AuthErrorPayload, PersonalAccessTokenCreationResponse } from '../types'\nimport { postFetch } from '../utils/fetch'\nimport { AuthActionErrorState, AuthActionLoadingState, AuthActionSuccessState } from './types'\n\nexport interface CreatePATHandlerParams {\n  /**\n   * The expiration date of the personal access token.\n   */\n  expiresAt: Date\n  /**\n   * Optional metadata to attach to the personal access token.\n   */\n  metadata?: Record<string, string | number>\n}\n\nexport interface CreatePATHandlerResult extends AuthActionErrorState, AuthActionSuccessState {\n  /**\n   * The data returned by the backend.\n   */\n  data?: {\n    /**\n     * The ID of the personal access token that was created.\n     */\n    id?: string | null\n    /**\n     * The personal access token that was created.\n     */\n    personalAccessToken?: string | null\n  } | null\n}\n\nexport interface CreatePATState extends CreatePATHandlerResult, AuthActionLoadingState {}\n\nexport const createPATPromise = async (\n  { backendUrl, interpreter }: AuthClient,\n  { expiresAt, metadata }: CreatePATHandlerParams\n): Promise<CreatePATHandlerResult> => {\n  try {\n    const { data } = await postFetch<PersonalAccessTokenCreationResponse>(\n      `${backendUrl}/pat`,\n      { expiresAt: expiresAt.toUTCString(), metadata },\n      interpreter?.getSnapshot().context.accessToken.value\n    )\n\n    return {\n      data: data\n        ? {\n            id: data.id || null,\n            personalAccessToken: data.personalAccessToken || null\n          }\n        : null,\n      isError: false,\n      error: null,\n      isSuccess: true\n    }\n  } catch (e) {\n    const { error } = e as { error: AuthErrorPayload }\n    return { isError: true, error, isSuccess: false, data: null }\n  }\n}\n", "import jwt_decode from 'jwt-decode'\nimport { interpret } from 'xstate'\nimport {\n  EMAIL_NEEDS_VERIFICATION,\n  INVALID_REFRESH_TOKEN,\n  INVALID_SIGN_IN_METHOD,\n  NO_REFRESH_TOKEN,\n  TOKEN_REFRESHER_RUNNING_ERROR\n} from './errors'\nimport { AuthClient } from './internal-client'\nimport {\n  AuthInterpreter,\n  createChangeEmailMachine,\n  createChangePasswordMachine,\n  createResetPasswordMachine,\n  createSendVerificationEmailMachine\n} from './machines'\nimport {\n  addSecurityKeyPromise,\n  changeEmailPromise,\n  changePasswordPromise,\n  resetPasswordPromise,\n  sendVerificationEmailPromise,\n  signInAnonymousPromise,\n  signInEmailPasswordPromise,\n  signInEmailPasswordlessPromise,\n  signInEmailSecurityKeyPromise,\n  signInMfaTotpPromise,\n  signInPATPromise,\n  signInSmsPasswordlessOtpPromise,\n  signInSmsPasswordlessPromise,\n  signOutPromise,\n  signUpEmailPasswordPromise,\n  signUpEmailSecurityKeyPromise\n} from './promises'\nimport { createPATPromise } from './promises/createPAT'\nimport {\n  AuthChangedFunction,\n  AuthErrorPayload,\n  ChangeEmailParams,\n  ChangeEmailResponse,\n  ChangePasswordParams,\n  ChangePasswordResponse,\n  DeanonymizeParams,\n  DeanonymizeResponse,\n  JWTClaims,\n  JWTHasuraClaims,\n  NhostAuthConstructorParams,\n  NhostSessionResponse,\n  OnTokenChangedFunction,\n  ResetPasswordParams,\n  ResetPasswordResponse,\n  SecurityKey,\n  SendVerificationEmailParams,\n  SendVerificationEmailResponse,\n  SignInPATResponse,\n  SignInParams,\n  SignInResponse,\n  SignOutResponse,\n  SignUpParams,\n  SignUpResponse\n} from './types'\nimport {\n  encodeQueryParameters,\n  getAuthenticationResult,\n  getSession,\n  isBrowser,\n  rewriteRedirectTo\n} from './utils'\n\n/**\n * @alias Auth\n */\nexport class HasuraAuthClient {\n  private _client: AuthClient\n  readonly url: string\n  constructor({\n    url,\n    autoRefreshToken = true,\n    autoSignIn = true,\n    clientStorage,\n    clientStorageType,\n    refreshIntervalTime,\n    start = true\n  }: NhostAuthConstructorParams) {\n    this.url = url\n    this._client = new AuthClient({\n      backendUrl: url,\n      clientUrl: (typeof window !== 'undefined' && window.location?.origin) || '',\n      autoRefreshToken,\n      autoSignIn,\n      start,\n      clientStorage,\n      clientStorageType,\n      refreshIntervalTime\n    })\n  }\n\n  /**\n   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.\n   *\n   * @example\n   * ### Sign up with an email and password\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign up with a security key\n   * ```ts\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up\n   */\n  async signUp(params: SignUpParams): Promise<SignUpResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { email, options } = params\n    if ('securityKey' in params) {\n      return getAuthenticationResult(\n        await signUpEmailSecurityKeyPromise(interpreter, email, options)\n      )\n    }\n    return getAuthenticationResult(\n      await signUpEmailPasswordPromise(interpreter, email, params.password, options)\n    )\n  }\n\n  /**\n   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.\n   *\n   * @example\n   * ### Sign in a user using email and password\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)\n   * ```ts\n   * nhost.auth.signIn({ provider: 'google' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless email (Magic Link)\n   * ```ts\n   * nhost.auth.signIn({ email: 'joe@example.com' })\n   * ```\n   *\n   * @example\n   * ### Sign in a user using passwordless SMS\n   * ```ts\n   * // [step 1/2] Passwordless sign in using SMS\n   * nhost.auth.signIn({ phoneNumber: '+11233213123' })\n   *\n   * // [step 2/2] Finish passwordless sign in using SMS (OTP)\n   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })\n   * ```\n   *\n   * @example\n   * ### Sign in anonymously\n   * ```ts\n   * // Sign in anonymously\n   * nhost.auth.signIn()\n   *\n   * // Later in the application, the user can complete their registration\n   * nhost.auth.signUp({\n   *   email: 'joe@example.com',\n   *   password: 'secret-password'\n   * })\n   * ```\n   *\n   * @example\n   * ### Sign in with a security key\n   * ```ts\n   * nhost.auth.signIn({\n   *   email: 'joe@example.com',\n   *   securityKey: true\n   * })\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in\n   */\n  async signIn(\n    params?: SignInParams\n  ): Promise<SignInResponse & { providerUrl?: string; provider?: string }> {\n    const interpreter = await this.waitUntilReady()\n    // * Anonymous sign-in\n    if (!params) {\n      const anonymousResult = await signInAnonymousPromise(interpreter)\n      return { ...getAuthenticationResult(anonymousResult), mfa: null }\n    }\n\n    // * Sign in with a social provider (OAuth)\n    if ('provider' in params) {\n      const { provider, options } = params\n      const providerUrl = encodeQueryParameters(\n        `${this._client.backendUrl}/signin/provider/${provider}`,\n        rewriteRedirectTo(this._client.clientUrl, options as any)\n      )\n      if (isBrowser()) {\n        window.location.href = providerUrl\n      }\n      return { providerUrl, provider, session: null, mfa: null, error: null }\n    }\n\n    // * Email + password\n    if ('email' in params && 'password' in params) {\n      const res = await signInEmailPasswordPromise(interpreter, params.email, params.password)\n      if (res.needsEmailVerification) {\n        return { session: null, mfa: null, error: EMAIL_NEEDS_VERIFICATION }\n      }\n      if (res.needsMfaOtp) {\n        return {\n          session: null,\n          mfa: res.mfa,\n          error: null\n        }\n      }\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    if ('email' in params && 'securityKey' in params) {\n      if (params.securityKey !== true) {\n        throw Error('securityKey must be true')\n      }\n      const res = await signInEmailSecurityKeyPromise(interpreter, params.email)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless Email (magic link)\n    if ('email' in params) {\n      const { email, options } = params\n      const { error } = await signInEmailPasswordlessPromise(interpreter, email, options)\n      return {\n        session: null,\n        mfa: null,\n        error\n      }\n    }\n\n    // * Passwordless SMS: [step 2/2] sign in using SMS OTP\n    if ('phoneNumber' in params && 'otp' in params) {\n      const res = await signInSmsPasswordlessOtpPromise(interpreter, params.phoneNumber, params.otp)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    // * Passwordless SMS: [step 1/2] sign in using SMS\n    if ('phoneNumber' in params) {\n      const { error } = await signInSmsPasswordlessPromise(\n        interpreter,\n        params.phoneNumber,\n        params.options\n      )\n      return { error, mfa: null, session: null }\n    }\n\n    // * Email + password MFA TOTP\n    if ('otp' in params) {\n      const res = await signInMfaTotpPromise(interpreter, params.otp, params.ticket)\n      return { ...getAuthenticationResult(res), mfa: null }\n    }\n\n    return { error: INVALID_SIGN_IN_METHOD, mfa: null, session: null }\n  }\n\n  /**\n   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).\n   *\n   * @example\n   * ```ts\n   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat\n   *\n   * @param personalAccessToken - The personal access token to sign in with\n   */\n  async signInPAT(personalAccessToken: string): Promise<SignInPATResponse> {\n    const interpreter = await this.waitUntilReady()\n    const res = await signInPATPromise(interpreter, personalAccessToken)\n\n    return getAuthenticationResult(res)\n  }\n\n  /**\n   * Use `nhost.auth.signOut` to sign out the user.\n   *\n   * @example\n   * ### Sign out the user from current device\n   * ```ts\n   * nhost.auth.signOut()\n   * ```\n   *\n   * @example\n   * ### Sign out the user from all devices\n   * ```ts\n   * nhost.auth.signOut({all: true})\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out\n   */\n  async signOut(params?: { all?: boolean }): Promise<SignOutResponse> {\n    const interpreter = await this.waitUntilReady()\n    const { error } = await signOutPromise(interpreter, params?.all)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.resetPassword({email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password\n   */\n  async resetPassword({ email, options }: ResetPasswordParams): Promise<ResetPasswordResponse> {\n    const service = interpret(createResetPasswordMachine(this._client)).start()\n    const { error } = await resetPasswordPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-password\n   */\n  async changePassword({\n    newPassword,\n    ticket\n  }: ChangePasswordParams): Promise<ChangePasswordResponse> {\n    const service = interpret(createChangePasswordMachine(this._client)).start()\n    const { error } = await changePasswordPromise(service, newPassword, ticket)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email\n   */\n  async sendVerificationEmail({\n    email,\n    options\n  }: SendVerificationEmailParams): Promise<SendVerificationEmailResponse> {\n    const service = interpret(createSendVerificationEmailMachine(this._client)).start()\n    const { error } = await sendVerificationEmailPromise(service, email, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/change-email\n   */\n  async changeEmail({ newEmail, options }: ChangeEmailParams): Promise<ChangeEmailResponse> {\n    const service = interpret(createChangeEmailMachine(this._client)).start()\n    const { error } = await changeEmailPromise(service, newEmail, options)\n    return { error }\n  }\n\n  /**\n   * Use `nhost.auth.deanonymize` to deanonymize a user.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize\n   */\n  async deanonymize(params: DeanonymizeParams): Promise<DeanonymizeResponse> {\n    const interpreter = await this.waitUntilReady()\n    if (params.signInMethod === 'passwordless') {\n      if (params.connection === 'email') {\n        const { error } = await signInEmailPasswordlessPromise(\n          interpreter,\n          params.email,\n          params.options\n        )\n        return { error }\n      }\n      if (params.connection === 'sms') {\n        const { error } = await signInSmsPasswordlessPromise(\n          interpreter,\n          params.phoneNumber,\n          params.options\n        )\n        return { error }\n      }\n    }\n    if (params.signInMethod === 'email-password') {\n      const { error } = await signUpEmailPasswordPromise(\n        interpreter,\n        params.email,\n        params.password,\n        params.options\n      )\n      return { error }\n    }\n    throw Error(`Unknown deanonymization method`)\n  }\n\n  /**\n   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.\n   * @param nickname optional human-readable nickname for the security key\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key\n   */\n  async addSecurityKey(\n    nickname?: string\n  ): Promise<{ error: AuthErrorPayload | null; key?: SecurityKey }> {\n    const { error, key } = await addSecurityKeyPromise(this._client, nickname)\n    return { error, key }\n  }\n\n  /**\n   * Use `nhost.auth.createPAT` to create a personal access token for the user.\n   *\n   * @param expiresAt Expiration date for the token\n   * @param metadata Optional metadata to store with the token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat\n   */\n  async createPAT(expiresAt: Date, metadata?: Record<string, string | number>) {\n    return createPATPromise(this._client, { expiresAt, metadata })\n  }\n\n  /**\n   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.\n   *\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed\n   */\n  onTokenChanged(fn: OnTokenChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'TOKEN_CHANGED') {\n          fn(getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.\n   *\n   * @example\n   * ```ts\n   * nhost.auth.onAuthStateChanged((event, session) => {\n   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)\n   * });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed\n   */\n  onAuthStateChanged(fn: AuthChangedFunction): Function {\n    return this._client.subscribe(() => {\n      const subscription = this._client.interpreter?.onTransition(({ event, context }) => {\n        if (event.type === 'SIGNED_IN' || event.type === 'SIGNED_OUT') {\n          fn(event.type, getSession(context))\n        }\n      })\n      return () => subscription?.stop()\n    })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.\n   *\n   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:\n   * 1. The user is not authenticated\n   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.\n   *\n   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated = nhost.auth.isAuthenticated();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this._client.interpreter?.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.\n   *\n   * The promise won't resolve until the authentication status is known.\n   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.\n   *\n   * @example\n   * ```ts\n   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async\n   */\n  async isAuthenticatedAsync(): Promise<boolean> {\n    const interpreter = await this.waitUntilReady()\n    return interpreter.getSnapshot().matches({ authentication: 'signedIn' })\n  }\n\n  /**\n   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.\n   *\n   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not\n   * because some internal authentication network requests have not been resolved yet.\n   *\n   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).\n   *\n   * @example\n   * ```ts\n   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();\n   *\n   * if (isLoading) {\n   *   console.log('Loading...')\n   * }\n   *\n   * if (isAuthenticated) {\n   *   console.log('User is authenticated');\n   * }\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status\n   */\n  getAuthenticationStatus(): {\n    isAuthenticated: boolean\n    isLoading: boolean\n    connectionAttempts: number\n  } {\n    const connectionAttempts =\n      this.client.interpreter?.getSnapshot().context.importTokenAttempts || 0\n    if (!this.isReady()) {\n      return {\n        isAuthenticated: false,\n        isLoading: true,\n        connectionAttempts\n      }\n    }\n    return { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts }\n  }\n\n  /**\n   * Use `nhost.auth.getAccessToken` to get the access token of the user.\n   *\n   * @example\n   * ```ts\n   * const accessToken = nhost.auth.getAccessToken();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token\n   */\n  getAccessToken(): string | undefined {\n    return this._client.interpreter?.getSnapshot().context.accessToken.value ?? undefined\n  }\n\n  /**\n   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.\n   *\n   * @example\n   * ```ts\n   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token\n   */\n  public getDecodedAccessToken(): JWTClaims | null {\n    const jwt = this.getAccessToken()\n    if (!jwt) return null\n    return jwt_decode<JWTClaims>(jwt)\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.\n   *\n   * @example\n   * ```ts\n   * const hasuraClaims = nhost.auth.getHasuraClaims();\n   * ```\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims\n   */\n  public getHasuraClaims(): JWTHasuraClaims | null {\n    return this.getDecodedAccessToken()?.['https://hasura.io/jwt/claims'] || null\n  }\n\n  /**\n   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.\n   *\n   * @example\n   * ```ts\n   * // if `x-hasura-company-id` exists as a custom claim\n   * const companyId = nhost.auth.getHsauraClaim('company-id')\n   * ```\n   *\n   * @param name Name of the variable. You don't have to specify `x-hasura-`.\n   *\n   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim\n   */\n  public getHasuraClaim(name: string): string | string[] | null {\n    return (\n      this.getHasuraClaims()?.[name.startsWith('x-hasura-') ? name : `x-hasura-${name}`] || null\n    )\n  }\n\n  /**\n   *\n   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.\n   *\n   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.\n   *\n   * @example\n   * ```ts\n   * // Refresh the session with the the current internal refresh token.\n   * nhost.auth.refreshToken();\n   *\n   * // Refresh the session with an external refresh token.\n   * nhost.auth.refreshToken(refreshToken);\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session\n   */\n  async refreshSession(refreshToken?: string): Promise<NhostSessionResponse> {\n    try {\n      const interpreter = await this.waitUntilReady()\n      return new Promise((resolve) => {\n        const token = refreshToken || interpreter.getSnapshot().context.refreshToken.value\n        if (!token) {\n          return resolve({ session: null, error: NO_REFRESH_TOKEN })\n        }\n        const { changed } = interpreter.send('TRY_TOKEN', { token })\n        if (!changed) {\n          return resolve({ session: null, error: TOKEN_REFRESHER_RUNNING_ERROR })\n        }\n        interpreter.onTransition((state) => {\n          if (state.matches({ token: { idle: 'error' } })) {\n            resolve({\n              session: null,\n              // * TODO get the error from xstate once it is implemented\n              error: INVALID_REFRESH_TOKEN\n            })\n          } else if (state.event.type === 'TOKEN_CHANGED') {\n            resolve({ session: getSession(state.context), error: null })\n          }\n        })\n      })\n    } catch (error: any) {\n      // TODO return error in the correct format\n      return { session: null, error: error.message }\n    }\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getSession()` to get the session of the user.\n   *\n   * @example\n   * ```ts\n   * const session = nhost.auth.getSession();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-session\n   */\n  getSession() {\n    return getSession(this._client.interpreter?.getSnapshot()?.context)\n  }\n\n  /**\n   *\n   * Use `nhost.auth.getUser()` to get the signed-in user.\n   *\n   * @example\n   * ```ts\n   * const user = nhost.auth.getUser();\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/auth/get-user\n   */\n  getUser() {\n    return this._client.interpreter?.getSnapshot()?.context?.user || null\n  }\n\n  /**\n   * Make sure the state machine is set, and wait for it to be ready\n   * @returns\n   */\n  private waitUntilReady(): Promise<AuthInterpreter> {\n    const TIMEOUT_IN_SECONS = 15\n    const interpreter = this._client.interpreter\n    if (!interpreter) {\n      throw Error('Auth interpreter not set')\n    }\n    if (!interpreter.getSnapshot().hasTag('loading')) {\n      return Promise.resolve(interpreter)\n    }\n    return new Promise((resolve, reject) => {\n      let timer: ReturnType<typeof setTimeout> = setTimeout(\n        () => reject(`The state machine is not yet ready after ${TIMEOUT_IN_SECONS} seconds.`),\n        TIMEOUT_IN_SECONS * 1_000\n      )\n      interpreter.onTransition((state) => {\n        if (!state.hasTag('loading')) {\n          clearTimeout(timer)\n          return resolve(interpreter)\n        }\n      })\n    })\n  }\n\n  private isReady() {\n    return !this._client.interpreter?.getSnapshot()?.hasTag('loading')\n  }\n\n  get client() {\n    return this._client\n  }\n}\n", "import fetchPonyfill from 'fetch-ponyfill'\nimport LegacyFormData from 'form-data'\nimport { StorageErrorPayload, StorageUploadResponse } from './types'\n\nlet fetch = globalThis.fetch\n\n/** Convert any string into ISO-8859-1 */\nexport const toIso88591 = (fileName: string) => {\n  try {\n    btoa(fileName)\n    return fileName\n  } catch {\n    return encodeURIComponent(fileName)\n  }\n}\n\nexport const fetchUpload = async (\n  backendUrl: string,\n  data: FormData | LegacyFormData,\n  {\n    accessToken,\n    name,\n    fileId,\n    bucketId,\n    adminSecret,\n    onUploadProgress,\n    headers: initialHeaders = {}\n  }: {\n    accessToken?: string\n    name?: string\n    fileId?: string\n    bucketId?: string\n    adminSecret?: string\n    onUploadProgress?: (event: { total: number; loaded: number }) => void\n    headers?: Record<string, string>\n  } = {}\n): Promise<StorageUploadResponse> => {\n  const headers: HeadersInit = {\n    ...initialHeaders\n  }\n  if (bucketId) {\n    data.append('bucket-id', bucketId)\n  }\n  if (adminSecret) {\n    headers['x-hasura-admin-secret'] = adminSecret\n  }\n  if (accessToken) {\n    headers['Authorization'] = `Bearer ${accessToken}`\n  }\n\n  const url = `${backendUrl}/files`\n  if (typeof XMLHttpRequest === 'undefined') {\n    // * Non-browser environment: XMLHttpRequest is not available\n    try {\n      if (data instanceof LegacyFormData) {\n        fetch = fetchPonyfill().fetch\n      }\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers,\n        body: data as any // * https://github.com/form-data/form-data/issues/513\n      })\n\n      const responseData = await response.json()\n\n      if (!response.ok) {\n        const error: StorageErrorPayload = {\n          status: response.status,\n          message: responseData?.error?.message || response.statusText,\n          // * errors from hasura-storage are not codified\n          error: response.statusText\n        }\n        return { error, fileMetadata: null }\n      }\n      const fileMetadata = responseData\n      return { fileMetadata, error: null }\n    } catch (e) {\n      const error: StorageErrorPayload = {\n        status: 0,\n        message: (e as Error).message,\n        error: (e as Error).message\n      }\n      return { error, fileMetadata: null }\n    }\n  }\n\n  // * Browser environment: XMLHttpRequest is available\n  return new Promise((resolve) => {\n    let xhr = new XMLHttpRequest()\n    xhr.responseType = 'json'\n\n    xhr.onload = () => {\n      if (xhr.status < 200 || xhr.status >= 300) {\n        return resolve({\n          fileMetadata: null,\n          error: {\n            error: xhr.response?.error ?? xhr.response,\n            message: xhr.response?.error?.message ?? xhr.response,\n            status: xhr.status\n          }\n        })\n      }\n      return resolve({ fileMetadata: xhr.response, error: null })\n    }\n\n    xhr.onerror = () => {\n      // only triggers if the request couldn't be made at all e.g. network error\n      return resolve({\n        fileMetadata: null,\n        error: { error: xhr.statusText, message: xhr.statusText, status: xhr.status }\n      })\n    }\n\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', onUploadProgress, false)\n    }\n\n    xhr.open('POST', url, true)\n\n    Object.entries(headers).forEach(([key, value]) => {\n      xhr.setRequestHeader(key, value)\n    })\n\n    xhr.send(data as any) // * https://github.com/form-data/form-data/issues/513\n  })\n}\n", "import fetchPonyfill from 'fetch-ponyfill'\nimport LegacyFormData from 'form-data'\nimport {\n  ApiDeleteParams,\n  ApiDeleteResponse,\n  ApiGetPresignedUrlParams,\n  ApiGetPresignedUrlResponse,\n  StorageUploadFileParams,\n  StorageUploadFileResponse,\n  StorageUploadFormDataParams,\n  StorageUploadFormDataResponse\n} from './utils/types'\nimport { fetchUpload } from './utils/upload'\n\nlet fetch: any\n\nif (typeof fetch === 'undefined') {\n  fetch = fetchPonyfill().fetch\n}\n\n/**\n * @internal\n * This is an internal class.\n */\nexport class HasuraStorageApi {\n  private url: string\n  private accessToken?: string\n  private adminSecret?: string\n\n  constructor({ url }: { url: string }) {\n    this.url = url\n  }\n\n  async uploadFormData({\n    formData,\n    headers,\n    bucketId\n  }: StorageUploadFormDataParams): Promise<StorageUploadFormDataResponse> {\n    const { error, fileMetadata } = await fetchUpload(this.url, formData, {\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret,\n      bucketId,\n      headers\n    })\n\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (fileMetadata && !('processedFiles' in fileMetadata)) {\n      return {\n        fileMetadata: {\n          processedFiles: [fileMetadata]\n        },\n        error: null\n      }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  async uploadFile({\n    file,\n    bucketId,\n    id,\n    name\n  }: StorageUploadFileParams): Promise<StorageUploadFileResponse> {\n    const formData = typeof window === 'undefined' ? new LegacyFormData() : new FormData()\n\n    formData.append('file[]', file)\n    formData.append('metadata[]', JSON.stringify({ id, name }))\n\n    const { error, fileMetadata } = await fetchUpload(this.url, formData, {\n      accessToken: this.accessToken,\n      adminSecret: this.adminSecret,\n      bucketId,\n      fileId: id,\n      name\n    })\n\n    if (error) {\n      return { fileMetadata: null, error }\n    }\n\n    if (fileMetadata && 'processedFiles' in fileMetadata) {\n      return {\n        fileMetadata: fileMetadata.processedFiles[0],\n        error: null\n      }\n    }\n\n    return { fileMetadata, error: null }\n  }\n\n  async getPresignedUrl(params: ApiGetPresignedUrlParams): Promise<ApiGetPresignedUrlResponse> {\n    try {\n      const { fileId } = params\n      const response = await fetch(`${this.url}/files/${fileId}/presignedurl`, {\n        method: 'GET',\n        headers: this.generateAuthHeaders()\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      const presignedUrl = await response.json()\n      return { presignedUrl, error: null }\n    } catch (error) {\n      return { presignedUrl: null, error: error as Error }\n    }\n  }\n\n  async delete(params: ApiDeleteParams): Promise<ApiDeleteResponse> {\n    try {\n      const { fileId } = params\n      const response = await fetch(`${this.url}/files/${fileId}`, {\n        method: 'DELETE',\n        headers: this.generateAuthHeaders()\n      })\n      if (!response.ok) {\n        throw new Error(await response.text())\n      }\n      return { error: null }\n    } catch (error) {\n      return { error: error as Error }\n    }\n  }\n\n  /**\n   * Set the access token to use for authentication.\n   *\n   * @param accessToken Access token\n   * @returns Hasura Storage API instance\n   */\n  setAccessToken(accessToken?: string): HasuraStorageApi {\n    this.accessToken = accessToken\n\n    return this\n  }\n\n  /**\n   * Set the admin secret to use for authentication.\n   *\n   * @param adminSecret Hasura admin secret\n   * @returns Hasura Storage API instance\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageApi {\n    this.adminSecret = adminSecret\n\n    return this\n  }\n\n  private generateAuthHeaders(): HeadersInit | undefined {\n    if (!this.adminSecret && !this.accessToken) {\n      return undefined\n    }\n\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n\n    return {\n      Authorization: `Bearer ${this.accessToken}`\n    }\n  }\n}\n", "import { StorageImageTransformationParams } from '../types'\n\n/**\n * Appends image transformation parameters to the URL. If the URL already\n * contains query parameters, the transformation parameters are appended to\n * the existing query parameters.\n *\n * @internal\n * @param url - The URL to append the transformation parameters to.\n * @param params - The image transformation parameters.\n * @returns The URL with the transformation parameters appended.\n */\nexport default function appendImageTransformationParameters(\n  url: string,\n  params?: StorageImageTransformationParams\n): string {\n  if (!params || Object.keys(params).length === 0) {\n    return url\n  }\n\n  const urlObject = new URL(url)\n\n  // create an object with the transformation parameters by using the first\n  // character of the parameter name as the key\n  const imageTransformationParams = Object.entries(params).reduce(\n    (accumulator, [key, value]) => ({ ...accumulator, [key.charAt(0)]: value }),\n    {} as Record<string, any>\n  )\n\n  // set the query parameters in the URL object\n  Object.entries(imageTransformationParams).forEach(([key, value]) => {\n    if (!value) {\n      return\n    }\n\n    urlObject.searchParams.set(key, value)\n  })\n\n  return urlObject.toString()\n}\n", "import { HasuraStorageApi } from './hasura-storage-api'\nimport {\n  appendImageTransformationParameters,\n  StorageDeleteParams,\n  StorageDeleteResponse,\n  StorageGetPresignedUrlParams,\n  StorageGetPresignedUrlResponse,\n  StorageGetUrlParams,\n  StorageUploadFileParams,\n  StorageUploadFileResponse,\n  StorageUploadFormDataParams,\n  StorageUploadFormDataResponse,\n  StorageUploadParams,\n  StorageUploadResponse\n} from './utils'\n\nexport interface NhostStorageConstructorParams {\n  /**\n   * Storage endpoint.\n   */\n  url: string\n  /**\n   * Admin secret. When set, it is sent as an `x-hasura-admin-secret` header for all requests.\n   */\n  adminSecret?: string\n}\n/**\n * @alias Storage\n */\nexport class HasuraStorageClient {\n  readonly url: string\n  private api: HasuraStorageApi\n\n  constructor({ url, adminSecret }: NhostStorageConstructorParams) {\n    this.url = url\n    this.api = new HasuraStorageApi({ url })\n    this.setAdminSecret(adminSecret)\n  }\n\n  /**\n   * Use `nhost.storage.upload` to upload a file. \n   * \n   * It's possible to use [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) or [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) to upload a file. The `File` instance is only available in the browser while `FormData` with [`form-data`](https://www.npmjs.com/package/form-data) works both in the browser and in NodeJS (server).\n   * \n   * If no `bucketId` is specified the bucket `default` is used.\n   *\n   * @example\n   * \n   * Upload a file from a browser using `File`.\n   * \n   * ```ts\n   * await nhost.storage.upload({ file })\n   * ```\n   * \n   * Upload a file from a browser using `File` to a specific Bucket.\n   * \n    @example\n   * ```ts\n   * await nhost.storage.upload({ file, bucketId: '<Bucket-ID>' })\n   * ```\n   * \n   * Upload a file from a server using `FormData` with [`form-data`](https://www.npmjs.com/package/form-data).\n   *\n   * @example\n   * ```ts\n   * const fd = new FormData() \n   * fd.append('file', fs.createReadStream('./tests/assets/sample.pdf'))\n   * \n   * await storage.upload({\n   *   formData: fd\n   * })\n   * ```\n   * \n   * @docs https://docs.nhost.io/reference/javascript/storage/upload\n   */\n\n  async upload(params: StorageUploadFileParams): Promise<StorageUploadFileResponse>\n  async upload(params: StorageUploadFormDataParams): Promise<StorageUploadFormDataResponse>\n  async upload(params: StorageUploadParams): Promise<StorageUploadResponse> {\n    if ('file' in params) {\n      return this.api.uploadFile(params)\n    }\n\n    return this.api.uploadFormData(params)\n  }\n\n  /**\n   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url\n   */\n  getPublicUrl(params: StorageGetUrlParams): string {\n    const { fileId, ...imageTransformationParams } = params\n    return appendImageTransformationParameters(\n      `${this.url}/files/${fileId}`,\n      imageTransformationParams\n    )\n  }\n\n  /**\n   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.\n   *\n   * @example\n   * ```ts\n   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })\n   *\n   * if (error) {\n   *   throw error;\n   * }\n   *\n   * console.log('url: ', presignedUrl.url)\n   * console.log('expiration: ', presignedUrl.expiration)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url\n   */\n  async getPresignedUrl(\n    params: StorageGetPresignedUrlParams\n  ): Promise<StorageGetPresignedUrlResponse> {\n    const { fileId, ...imageTransformationParams } = params\n    const { presignedUrl, error } = await this.api.getPresignedUrl(params)\n    if (error) {\n      return { presignedUrl: null, error }\n    }\n\n    if (!presignedUrl) {\n      return { presignedUrl: null, error: new Error('Invalid file id') }\n    }\n\n    const urlWithTransformationParams = appendImageTransformationParameters(\n      presignedUrl.url,\n      imageTransformationParams\n    )\n\n    return {\n      presignedUrl: {\n        ...presignedUrl,\n        url: urlWithTransformationParams\n      },\n      error: null\n    }\n  }\n\n  /**\n   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.\n   *\n   * @example\n   * ```ts\n   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/delete\n   */\n  async delete(params: StorageDeleteParams): Promise<StorageDeleteResponse> {\n    const { error } = await this.api.delete(params)\n    if (error) {\n      return { error }\n    }\n\n    return { error: null }\n  }\n\n  /**\n   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAccessToken('some-access-token')\n   * ```\n   *\n   * @param accessToken Access token\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token\n   */\n  setAccessToken(accessToken?: string): HasuraStorageClient {\n    this.api.setAccessToken(accessToken)\n\n    return this\n  }\n\n  /**\n   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in \"admin mode\".\n   *\n   * @example\n   * ```ts\n   * nhost.storage.setAdminSecret('some-admin-secret')\n   * ```\n   *\n   * @param adminSecret Hasura admin secret\n   *\n   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret\n   */\n  setAdminSecret(adminSecret?: string): HasuraStorageClient {\n    this.api.setAdminSecret(adminSecret)\n\n    return this\n  }\n}\n", "import { assign, createMachine } from 'xstate'\nimport { FileUploadConfig, StorageErrorPayload } from '../utils'\nimport { fetchUpload } from '../utils/upload'\n\nimport FallbackFormData from 'form-data'\n\nlet FormData: any\n\nif (typeof FormData === 'undefined') {\n  FormData = FallbackFormData\n}\n\nexport type FileUploadContext = {\n  progress: number | null\n  loaded: number\n  error: StorageErrorPayload | null\n  id?: string\n  bucketId?: string\n  file?: File\n}\n\nexport type FileUploadEventPayload = {}\nexport type FileUploadEvents =\n  | { type: 'ADD'; file: File; id?: string; bucketId?: string; name?: string }\n  | ({\n      type: 'UPLOAD'\n      file?: File\n      id?: string\n      name?: string\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; progress: number; loaded: number; additions: number }\n  | { type: 'UPLOAD_DONE'; id: string; bucketId: string }\n  | { type: 'UPLOAD_ERROR'; error: StorageErrorPayload }\n  | { type: 'CANCEL' }\n  | { type: 'DESTROY' }\n\nexport const INITIAL_FILE_CONTEXT: FileUploadContext = {\n  progress: null,\n  loaded: 0,\n  error: null,\n  bucketId: undefined,\n  file: undefined,\n  id: undefined\n}\n\nexport type FileUploadMachine = ReturnType<typeof createFileUploadMachine>\nexport const createFileUploadMachine = () =>\n  createMachine(\n    {\n      predictableActionArguments: true,\n      schema: {\n        context: {} as FileUploadContext,\n        events: {} as FileUploadEvents\n      },\n      tsTypes: {} as import('./file-upload.typegen').Typegen0,\n      context: { ...INITIAL_FILE_CONTEXT },\n      initial: 'idle',\n      on: {\n        DESTROY: { actions: 'sendDestroy', target: 'stopped' }\n      },\n      states: {\n        idle: {\n          on: {\n            ADD: { actions: 'addFile' },\n            UPLOAD: { cond: 'hasFile', target: 'uploading' }\n          }\n        },\n        uploading: {\n          entry: 'resetProgress',\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress', 'sendProgress'] },\n            UPLOAD_DONE: 'uploaded',\n            UPLOAD_ERROR: 'error',\n            CANCEL: 'idle'\n          },\n          invoke: { src: 'uploadFile' }\n        },\n        uploaded: {\n          entry: ['setFileMetadata', 'sendDone'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        error: {\n          entry: ['setError', 'sendError'],\n          on: {\n            ADD: { actions: 'addFile', target: 'idle' },\n            UPLOAD: { actions: 'resetContext', target: 'uploading' }\n          }\n        },\n        stopped: { type: 'final' }\n      }\n    },\n    {\n      guards: {\n        hasFile: (context, event) => !!context.file || !!event.file\n      },\n\n      actions: {\n        incrementProgress: assign({\n          loaded: (_, { loaded }) => loaded,\n          progress: (_, { progress }) => progress\n        }),\n        setFileMetadata: assign({\n          id: (_, { id }) => id,\n          bucketId: (_, { bucketId }) => bucketId,\n          progress: (_) => 100\n        }),\n        setError: assign({ error: (_, { error }) => error }),\n        sendProgress: () => {},\n        sendError: () => {},\n        sendDestroy: () => {},\n        sendDone: () => {},\n        resetProgress: assign({ progress: (_) => null, loaded: (_) => 0 }),\n        resetContext: assign((_) => INITIAL_FILE_CONTEXT),\n        addFile: assign({\n          file: (_, { file }) => file,\n          bucketId: (_, { bucketId }) => bucketId,\n          id: (_, { id }) => id\n        })\n      },\n      services: {\n        uploadFile: (context, event) => (callback) => {\n          const file = (event.file || context.file)!\n          const data = new FormData()\n          data.append('file[]', file)\n\n          let currentLoaded = 0\n\n          fetchUpload(event.url, data, {\n            fileId: event.id || context.id,\n            bucketId: event.bucketId || context.bucketId,\n            accessToken: event.accessToken,\n            adminSecret: event.adminSecret,\n            name: event.name || file.name,\n            onUploadProgress: (event) => {\n              const loaded = event.total ? Math.round((event.loaded * file.size!) / event.total) : 0\n              const additions = loaded - currentLoaded\n              currentLoaded = loaded\n              callback({\n                type: 'UPLOAD_PROGRESS',\n                progress: event.total ? Math.round((loaded * 100) / event.total) : 0,\n                loaded,\n                additions\n              })\n            }\n          }).then(({ fileMetadata, error }) => {\n            if (error) {\n              callback({ type: 'UPLOAD_ERROR', error })\n            }\n            if (fileMetadata && !('processedFiles' in fileMetadata)) {\n              const { id, bucketId } = fileMetadata\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n\n            if (fileMetadata && 'processedFiles' in fileMetadata) {\n              // TODO: Add support for multiple files\n              const { id, bucketId } = fileMetadata.processedFiles[0]\n              callback({ type: 'UPLOAD_DONE', id, bucketId })\n            }\n          })\n\n          return () => {}\n        }\n      }\n    }\n  )\n", "import { actions, ActorRefFrom, assign, createMachine, send, spawn } from 'xstate'\n\nimport { FileUploadConfig } from '../utils'\n\nimport { createFileUploadMachine, FileUploadMachine, INITIAL_FILE_CONTEXT } from './file-upload'\n\nconst { pure, sendParent } = actions\n\nexport type FileItemRef = ActorRefFrom<FileUploadMachine>\n\nexport type AnyFileList = File | File[] | FileList\n\nexport type MultipleFilesUploadContext = {\n  progress: number | null\n  files: FileItemRef[]\n  loaded: number\n  total: number\n}\n\nexport type MultipleFilesUploadEvents =\n  | { type: 'ADD'; files: AnyFileList; bucketId?: string }\n  | ({\n      type: 'UPLOAD'\n      files?: AnyFileList\n      bucketId?: string\n    } & FileUploadConfig)\n  | { type: 'UPLOAD_PROGRESS'; additions: number }\n  | { type: 'UPLOAD_DONE' }\n  | { type: 'UPLOAD_ERROR' }\n  | { type: 'CANCEL' }\n  | { type: 'REMOVE' }\n  | { type: 'CLEAR' }\n\nexport type MultipleFilesUploadMachine = ReturnType<typeof createMultipleFilesUploadMachine>\n\nexport const createMultipleFilesUploadMachine = () => {\n  return createMachine(\n    {\n      id: 'files-list',\n      schema: {\n        context: {} as MultipleFilesUploadContext,\n        events: {} as MultipleFilesUploadEvents\n      },\n      tsTypes: {} as import('./multiple-files-upload.typegen').Typegen0,\n      predictableActionArguments: true,\n      context: {\n        progress: null,\n        files: [],\n        loaded: 0,\n        total: 0\n      },\n      initial: 'idle',\n      on: {\n        UPLOAD: { cond: 'hasFileToDownload', actions: 'addItem', target: 'uploading' },\n        ADD: { actions: 'addItem' },\n        REMOVE: { actions: 'removeItem' }\n      },\n      states: {\n        idle: {\n          entry: ['resetProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        uploading: {\n          entry: ['upload', 'startProgress', 'resetLoaded', 'resetTotal'],\n          on: {\n            UPLOAD_PROGRESS: { actions: ['incrementProgress'] },\n            UPLOAD_DONE: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            UPLOAD_ERROR: [\n              { cond: 'isAllUploaded', target: 'uploaded' },\n              { cond: 'isAllUploadedOrError', target: 'error' }\n            ],\n            CANCEL: { actions: 'cancel', target: 'idle' }\n          }\n        },\n        uploaded: {\n          entry: 'setUploaded',\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        },\n        error: {\n          on: {\n            CLEAR: { actions: 'clearList', target: 'idle' }\n          }\n        }\n      }\n    },\n    {\n      guards: {\n        hasFileToDownload: (context, event) =>\n          context.files.some((ref) => ref.getSnapshot()!.matches('idle')) || !!event.files,\n        isAllUploaded: (context) =>\n          context.files.every((item) => item.getSnapshot()?.matches('uploaded')),\n        isAllUploadedOrError: (context) =>\n          context.files.every((item) => {\n            const snap = item.getSnapshot()\n            return snap?.matches('error') || snap?.matches('uploaded')\n          })\n      },\n\n      actions: {\n        incrementProgress: assign((context, event) => {\n          const loaded: number = context.loaded + event.additions\n          const progress = Math.round((loaded * 100) / context.total)\n          return { ...context, loaded, progress }\n        }),\n        setUploaded: assign({\n          progress: (_) => 100,\n          loaded: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetTotal: assign({\n          total: ({ files }) =>\n            files\n              .map((ref) => ref.getSnapshot()!)\n              .filter((snap) => !snap.matches('uploaded'))\n              .reduce((agg, curr) => agg + curr.context.file?.size!, 0)\n        }),\n        resetLoaded: assign({ loaded: (_) => 0 }),\n        startProgress: assign({ progress: (_) => 0 }),\n        resetProgress: assign({ progress: (_) => null }),\n        addItem: assign((context, { files, bucketId }) => {\n          const additions = files\n            ? Array.isArray(files)\n              ? files // File[]\n              : 'item' in files // FileList\n              ? Array.from(files)\n              : [files] // File\n            : [] // No file\n          const total = context.total + additions.reduce((agg, curr) => agg + curr.size, 0)\n          const progress = Math.round((context.loaded * 100) / total)\n          return {\n            files: [\n              ...context.files,\n              ...additions.map((file) =>\n                spawn(\n                  createFileUploadMachine()\n                    .withConfig({\n                      actions: {\n                        sendProgress: sendParent((_, { additions }) => ({\n                          type: 'UPLOAD_PROGRESS',\n                          additions\n                        })),\n                        sendDone: sendParent('UPLOAD_DONE'),\n                        sendError: sendParent('UPLOAD_ERROR'),\n                        sendDestroy: sendParent('REMOVE')\n                      }\n                    })\n                    .withContext({ ...INITIAL_FILE_CONTEXT, file, bucketId }),\n                  { sync: true }\n                )\n              )\n            ],\n            total,\n            loaded: context.loaded,\n            progress\n          }\n        }),\n        removeItem: assign({\n          files: (context) =>\n            context.files.filter((ref) => {\n              const stopped = ref.getSnapshot()?.matches('stopped')\n              if (stopped) {\n                ref.stop?.()\n              }\n              return !stopped\n            })\n        }),\n        clearList: pure((context) =>\n          context.files.map((ref) => send({ type: 'DESTROY' }, { to: ref.id }))\n        ),\n        upload: pure((context, event) => context.files.map((ref) => send(event, { to: ref.id }))),\n        cancel: pure((context) =>\n          context.files.map((ref) => send({ type: 'CANCEL' }, { to: ref.id }))\n        )\n      }\n    }\n  )\n}\n", "import { InterpreterFrom } from 'xstate'\n\nimport { FileItemRef, FileUploadMachine } from '../machines'\nimport { FileUploadConfig, StorageActionErrorState, StorageUploadFileParams } from '../utils'\n\nexport interface UploadProgressState {\n  /**\n   * Returns `true` when the file is being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface UploadFileHandlerResult extends StorageActionErrorState {\n  /**\n   * Returns `true` when the file has been successfully uploaded.\n   */\n  isUploaded: boolean\n  /**\n   * Returns the id of the file.\n   */\n  id?: string\n  /**\n   * Returns the bucket id.\n   */\n  bucketId?: string\n  /**\n   * Returns the name of the file.\n   */\n  name?: string\n}\n\nexport interface FileUploadState extends UploadFileHandlerResult, UploadProgressState {}\n\nexport const uploadFilePromise = async (\n  params: FileUploadConfig & Partial<StorageUploadFileParams>,\n  interpreter: FileItemRef | InterpreterFrom<FileUploadMachine>\n): Promise<UploadFileHandlerResult> =>\n  new Promise<UploadFileHandlerResult>((resolve) => {\n    interpreter.send({\n      type: 'UPLOAD',\n      ...params\n    })\n    interpreter.subscribe((s) => {\n      if (s.matches('error')) {\n        resolve({\n          error: s.context.error,\n          isError: true,\n          isUploaded: false\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({\n          error: null,\n          isError: false,\n          isUploaded: true,\n          id: s.context.id,\n          bucketId: s.context.id,\n          name: s.context.file?.name\n        })\n      }\n    })\n  })\n", "import { InterpreterFrom } from 'xstate'\n\nimport { AnyFileList, FileItemRef, MultipleFilesUploadMachine } from '../machines'\nimport { FileUploadConfig } from '../utils'\n\nexport interface MultipleUploadProgressState {\n  /**\n   * Returns `true` when the files are being uploaded.\n   */\n  isUploading: boolean\n  /**\n   * Returns the overall progress of the upload, from 0 to 100. Returns null if the upload has not started yet.\n   */\n  progress: number | null\n}\n\nexport interface MultipleFilesHandlerResult {\n  /**\n   * The list of file uploads. The properties can be accessed through `item.getSnapshot()` of with the `useFileUploadItem` hook.\n   */\n  files: FileItemRef[]\n  /**\n   * Returns `true` when all upload request are processed, but at least one of them has failed.\n   */\n  isError: boolean\n  /**\n   * Returns the list of file uploads that have failed\n   */\n  errors: FileItemRef[]\n}\n\nexport interface MultipleFilesUploadState\n  extends MultipleFilesHandlerResult,\n    MultipleUploadProgressState {\n  /**\n   * Returns `true` when all the files have been successfully uploaded.\n   */\n  isUploaded: boolean\n}\n\nexport type UploadMultipleFilesActionParams = {\n  files?: AnyFileList\n  bucketId?: string\n}\n\nexport const uploadMultipleFilesPromise = async (\n  params: FileUploadConfig & UploadMultipleFilesActionParams,\n  service: InterpreterFrom<MultipleFilesUploadMachine>\n): Promise<MultipleFilesHandlerResult> =>\n  new Promise((resolve) => {\n    service.send({\n      type: 'UPLOAD',\n      ...params,\n      files: params.files\n    })\n    service.onTransition((s) => {\n      if (s.matches('error')) {\n        resolve({\n          errors: s.context.files.filter((ref) => ref.getSnapshot()?.context.error),\n          isError: true,\n          files: []\n        })\n      } else if (s.matches('uploaded')) {\n        resolve({ errors: [], isError: false, files: s.context.files })\n      }\n    })\n  })\n", "import { RequestDocument, RequestOptions, Variables } from './types'\n\nexport function parseRequestArgs<V extends Variables = Variables>(\n  documentOrOptions: RequestDocument | RequestOptions<V>,\n  variables?: V,\n  config?: RequestInit\n): RequestOptions<V> {\n  return (\n    (documentOrOptions as RequestOptions<V>).document\n      ? documentOrOptions\n      : {\n          document: documentOrOptions,\n          variables,\n          config\n        }\n  ) as RequestOptions<V>\n}\n", "import { DocumentNode, OperationDefinitionNode, parse, print } from 'graphql'\nimport { RequestDocument } from './types'\n\n/**\n * helpers\n */\n\nfunction extractOperationName(document: DocumentNode): string | undefined {\n  let operationName = undefined\n\n  const operationDefinitions = document.definitions.filter(\n    (definition) => definition.kind === 'OperationDefinition'\n  ) as OperationDefinitionNode[]\n\n  if (operationDefinitions.length === 1) {\n    operationName = operationDefinitions[0].name?.value\n  }\n\n  return operationName\n}\n\nexport function resolveRequestDocument(document: RequestDocument): {\n  query: string\n  operationName?: string\n} {\n  if (typeof document === 'string') {\n    let operationName = undefined\n\n    try {\n      const parsedDocument = parse(document)\n      operationName = extractOperationName(parsedDocument)\n    } catch (err) {\n      // Failed parsing the document, the operationName will be undefined\n    }\n\n    return { query: document, operationName }\n  }\n\n  const operationName = extractOperationName(document)\n\n  return { query: print(document), operationName }\n}\n", "import { TypedDocumentNode } from '@graphql-typed-document-node/core'\nimport fetch from 'isomorphic-unfetch'\nimport { parseRequestArgs } from './parse-args'\nimport { resolveRequestDocument } from './resolve-request-document'\nimport {\n  NhostGraphqlConstructorParams,\n  NhostGraphqlRequestConfig,\n  NhostGraphqlRequestResponse,\n  RemoveIndex,\n  RequestDocument,\n  RequestOptions,\n  Variables\n} from './types'\n\n/**\n * @alias GraphQL\n */\nexport class NhostGraphqlClient {\n  readonly _url: string\n  private accessToken: string | null\n  private adminSecret?: string\n\n  constructor(params: NhostGraphqlConstructorParams) {\n    const { url, adminSecret } = params\n\n    this._url = url\n    this.accessToken = null\n    this.adminSecret = adminSecret\n  }\n\n  /**\n   * Use `nhost.graphql.request` to send a GraphQL request. For more serious GraphQL usage we recommend using a GraphQL client such as Apollo Client (https://www.apollographql.com/docs/react).\n   *\n   * @example\n   * ```ts\n   * const CUSTOMERS = gql`\n   *  query {\n   *   customers {\n   *    id\n   *    name\n   *  }\n   * }\n   * `\n   * const { data, error } = await nhost.graphql.request(CUSTOMERS)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/graphql/request\n   */\n  request<T = any, V = Variables>(\n    document: RequestDocument | TypedDocumentNode<T, V>,\n    ...variablesAndRequestHeaders: V extends Record<any, never>\n      ? [variables?: V, config?: NhostGraphqlRequestConfig]\n      : keyof RemoveIndex<V> extends never\n      ? [variables?: V, config?: NhostGraphqlRequestConfig]\n      : [variables: V, config?: NhostGraphqlRequestConfig]\n  ): Promise<NhostGraphqlRequestResponse<T>>\n  async request<T = any, V extends Variables = Variables>(\n    options: RequestOptions<V, T>\n  ): Promise<NhostGraphqlRequestResponse<T>>\n  async request<T = any, V extends Variables = Variables>(\n    documentOrOptions: RequestDocument | TypedDocumentNode<T, V> | RequestOptions<V>,\n    ...variablesAndRequestHeaders: V extends Record<any, never>\n      ? [variables?: V, config?: NhostGraphqlRequestConfig]\n      : keyof RemoveIndex<V> extends never\n      ? [variables?: V, config?: NhostGraphqlRequestConfig]\n      : [variables: V, config?: NhostGraphqlRequestConfig]\n  ): Promise<NhostGraphqlRequestResponse<T>> {\n    const [variables, config] = variablesAndRequestHeaders\n    const requestOptions = parseRequestArgs(documentOrOptions, variables, config)\n\n    const { headers, ...otherOptions } = config || {}\n    const { query, operationName } = resolveRequestDocument(requestOptions.document)\n    try {\n      const response = await fetch(this.httpUrl, {\n        method: 'POST',\n        body: JSON.stringify({\n          operationName,\n          query,\n          variables\n        }),\n        headers: {\n          'Content-Type': 'application/json',\n          ...this.generateAccessTokenHeaders(),\n          ...headers\n        },\n        ...otherOptions\n      })\n      if (!response.ok) {\n        return {\n          data: null,\n          error: {\n            error: response.statusText,\n            message: response.statusText,\n            status: response.status\n          }\n        }\n      }\n      const { data, errors } = await response.json()\n\n      if (errors) {\n        return {\n          data: null,\n          error: errors\n        }\n      }\n      if (typeof data !== 'object' || Array.isArray(data) || data === null) {\n        return {\n          data: null,\n          error: {\n            error: 'invalid-response',\n            message: 'incorrect response data from GraphQL server',\n            status: 0\n          }\n        }\n      }\n\n      return { data, error: null }\n    } catch (e) {\n      const error = e as Error\n      return {\n        data: null,\n        error: {\n          message: error.message,\n          status: error.name === 'AbortError' ? 0 : 500,\n          error: error.name === 'AbortError' ? 'abort-error' : 'unknown'\n        }\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.graphql.httpUrl` to get the GraphQL HTTP URL.\n   * @example\n   * ```ts\n   * const url = nhost.graphql.httpUrl;\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/graphql/get-http-url\n   */\n  get httpUrl(): string {\n    return this._url\n  }\n\n  /**\n   * Use `nhost.graphql.wsUrl` to get the GraphQL WebSocket URL.\n   * @example\n   * ```ts\n   * const url = nhost.graphql.wsUrl;\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/graphql/get-ws-url\n   */\n  get wsUrl(): string {\n    return this._url.replace(/^(http)(s?):\\/\\//, 'ws$2://')\n  }\n\n  /**\n   * Use `nhost.graphql.url` to get the GraphQL URL.\n   * @deprecated Use `nhost.graphql.httpUrl` and `nhost.graphql.wsUrl` instead.\n   */\n  get url(): string {\n    return this._url\n  }\n\n  /**\n   * Use `nhost.graphql.getUrl()` to get the GraphQL URL.\n   * @deprecated Use `nhost.graphql.httpUrl` and `nhost.graphql.wsUrl` instead.\n   */\n  getUrl(): string {\n    return this._url\n  }\n\n  /**\n   * Use `nhost.graphql.setAccessToken` to a set an access token to be used in subsequent graphql requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.graphql.setAccessToken('some-access-token')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/graphql/set-access-token\n   */\n  setAccessToken(accessToken: string | undefined) {\n    if (!accessToken) {\n      this.accessToken = null\n      return\n    }\n\n    this.accessToken = accessToken\n  }\n\n  private generateAccessTokenHeaders(): NhostGraphqlRequestConfig['headers'] {\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n    if (this.accessToken) {\n      return {\n        Authorization: `Bearer ${this.accessToken}`\n      }\n    }\n    return {}\n  }\n}\n", "import { NhostClientConstructorParams } from './types'\n\n// a port can be a number or a placeholder string with leading and trailing double underscores, f.e. \"8080\" or \"__PLACEHOLDER_NAME__\"\nexport const LOCALHOST_REGEX =\n  /^((?<protocol>http[s]?):\\/\\/)?(?<host>(localhost|local))(:(?<port>(\\d+|__\\w+__)))?$/\n\n/**\n * \\`backendUrl\\` should now be used only when self-hosting\n * \\`subdomain\\` and `region` should be used instead when using the Nhost platform\n *\n * @param backendOrSubdomain\n * @param service\n * @returns\n */\nexport function urlFromSubdomain(\n  backendOrSubdomain: Pick<NhostClientConstructorParams, 'region' | 'subdomain' | 'backendUrl'>,\n  service: string\n): string {\n  const { backendUrl, subdomain, region } = backendOrSubdomain\n\n  if (backendUrl) {\n    return `${backendUrl}/v1/${service}`\n  }\n\n  if (!subdomain) {\n    throw new Error('Either `backendUrl` or `subdomain` must be set.')\n  }\n\n  // check if subdomain is [http[s]://]localhost[:port] or [http[s]://]local[:port]\n  const subdomainLocalhostFound = subdomain.match(LOCALHOST_REGEX)\n  if (subdomainLocalhostFound?.groups) {\n    const { protocol, host, port } = subdomainLocalhostFound.groups\n\n    const urlFromEnv = getValueFromEnv(service)\n    if (urlFromEnv) {\n      return urlFromEnv\n    }\n\n    if (host === 'localhost') {\n      console.warn(\n        'The `subdomain` is set to \"localhost\". Support for this will be removed in a future release. Please use \"local\" instead.'\n      )\n\n      return `${protocol || 'http'}://localhost:${port || 1337}/v1/${service}`\n    }\n\n    return port\n      ? `${protocol || 'https'}://local.${service}.nhost.run:${port}/v1`\n      : `${protocol || 'https'}://local.${service}.nhost.run/v1`\n  }\n\n  if (!region) {\n    throw new Error('`region` must be set when using a `subdomain` other than \"local\".')\n  }\n\n  return `https://${subdomain}.${service}.${region}.nhost.run/v1`\n}\n\n/**\n *\n * @returns whether the code is running in a browser\n */\nfunction isBrowser(): boolean {\n  return typeof window !== 'undefined'\n}\n\n/**\n *\n * @returns whether the code is running in a Node.js environment\n */\nfunction environmentIsAvailable() {\n  return typeof process !== 'undefined' && process.env\n}\n\n/**\n *\n * @param service auth | storage | graphql | functions\n * @returns the service's url if the corresponding env var is set\n * NHOST_${service}_URL\n */\nfunction getValueFromEnv(service: string) {\n  if (isBrowser() || !environmentIsAvailable()) {\n    return null\n  }\n\n  return process.env[`NHOST_${service.toUpperCase()}_URL`]\n}\n\n/**\n * Combines a base URL and a path into a single URL string.\n *\n * @param baseUrl - The base URL to use.\n * @param path - The path to append to the base URL.\n * @returns The combined URL string.\n */\nexport function buildUrl(baseUrl: string, path: string) {\n  const hasLeadingSlash = path.startsWith('/')\n  const urlPath = hasLeadingSlash ? path : `/${path}`\n  return baseUrl + urlPath\n}\n", "import { HasuraAuthClient } from '@nhost/hasura-auth-js'\n\nimport { urlFromSubdomain } from '../utils/helpers'\nimport { NhostClientConstructorParams } from '../utils/types'\n\n/**\n * Creates a client for Auth from either a subdomain or a URL\n */\nexport function createAuthClient(params: NhostClientConstructorParams) {\n  const authUrl =\n    'subdomain' in params || 'backendUrl' in params\n      ? urlFromSubdomain(params, 'auth')\n      : params.authUrl\n\n  if (!authUrl) {\n    throw new Error('Please provide `subdomain` or `authUrl`.')\n  }\n\n  return new HasuraAuthClient({ url: authUrl, ...params })\n}\n", "import fetch from 'isomorphic-unfetch'\nimport { buildUrl, urlFromSubdomain } from '../../utils/helpers'\nimport { NhostClientConstructorParams } from '../../utils/types'\nimport {\n  NhostFunctionCallConfig,\n  NhostFunctionCallResponse,\n  NhostFunctionsConstructorParams\n} from './types'\n/**\n * Creates a client for Functions from either a subdomain or a URL\n */\nexport function createFunctionsClient(params: NhostClientConstructorParams) {\n  const functionsUrl =\n    'subdomain' in params || 'backendUrl' in params\n      ? urlFromSubdomain(params, 'functions')\n      : params.functionsUrl\n\n  if (!functionsUrl) {\n    throw new Error('Please provide `subdomain` or `functionsUrl`.')\n  }\n\n  return new NhostFunctionsClient({ url: functionsUrl, ...params })\n}\n\n/**\n * @alias Functions\n */\nexport class NhostFunctionsClient {\n  readonly url: string\n  private accessToken: string | null\n  private adminSecret?: string\n\n  constructor(params: NhostFunctionsConstructorParams) {\n    const { url, adminSecret } = params\n\n    this.url = url\n    this.accessToken = null\n    this.adminSecret = adminSecret\n  }\n\n  /**\n   * Use `nhost.functions.call` to call (sending a POST request to) a serverless function. Use generic\n   * types to specify the expected response data, request body and error message.\n   *\n   * @example\n   * ### Without generic types\n   * ```ts\n   * await nhost.functions.call('send-welcome-email', { email: 'joe@example.com', name: 'Joe Doe' })\n   * ```\n   *\n   * @example\n   * ### Using generic types\n   * ```ts\n   * type Data = {\n   *   message: string\n   * }\n   *\n   * type Body = {\n   *   email: string\n   *   name: string\n   * }\n   *\n   * type ErrorMessage = {\n   *   details: string\n   * }\n   *\n   * // The function will only accept a body of type `Body`\n   * const { res, error } = await nhost.functions.call<Data, Body, ErrorMessage>(\n   *   'send-welcome-email',\n   *   { email: 'joe@example.com', name: 'Joe Doe' }\n   * )\n   *\n   * // Now the response data is typed as `Data`\n   * console.log(res?.data.message)\n   *\n   * // Now the error message is typed as `ErrorMessage`\n   * console.log(error?.message.details)\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/call\n   */\n  async call<TData = unknown, TBody = any, TErrorMessage = any>(\n    url: string,\n    body?: TBody | null,\n    config?: NhostFunctionCallConfig\n  ): Promise<NhostFunctionCallResponse<TData, TErrorMessage>> {\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n      ...this.generateAccessTokenHeaders(),\n      ...config?.headers\n    }\n\n    const fullUrl = buildUrl(this.url, url)\n\n    try {\n      const result = await fetch(fullUrl, {\n        body: body ? JSON.stringify(body) : null,\n        headers,\n        method: 'POST'\n      })\n\n      if (!result.ok) {\n        let message: TErrorMessage\n\n        if (result.headers.get('content-type')?.includes('application/json')) {\n          message = await result.json()\n        } else {\n          message = (await result.text()) as unknown as TErrorMessage\n        }\n\n        return {\n          res: null,\n          error: {\n            message,\n            error: result.statusText,\n            status: result.status\n          }\n        }\n      }\n\n      let data: TData\n\n      if (result.headers.get('content-type')?.includes('application/json')) {\n        data = await result.json()\n      } else {\n        data = (await result.text()) as unknown as TData\n      }\n\n      return {\n        res: { data, status: result.status, statusText: result.statusText },\n        error: null\n      }\n    } catch (e) {\n      const error = e as Error\n      return {\n        res: null,\n        error: {\n          message: error.message as unknown as TErrorMessage,\n          status: error.name === 'AbortError' ? 0 : 500,\n          error: error.name === 'AbortError' ? 'abort-error' : 'unknown'\n        }\n      }\n    }\n  }\n\n  /**\n   * Use `nhost.functions.setAccessToken` to a set an access token to be used in subsequent functions requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.\n   *\n   * @example\n   * ```ts\n   * nhost.functions.setAccessToken('some-access-token')\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-access-token\n   */\n  setAccessToken(accessToken: string | undefined) {\n    if (!accessToken) {\n      this.accessToken = null\n      return\n    }\n\n    this.accessToken = accessToken\n  }\n\n  generateAccessTokenHeaders(): NhostFunctionCallConfig['headers'] {\n    if (this.adminSecret) {\n      return {\n        'x-hasura-admin-secret': this.adminSecret\n      }\n    }\n    if (this.accessToken) {\n      return {\n        Authorization: `Bearer ${this.accessToken}`\n      }\n    }\n    return {}\n  }\n}\n", "import { NhostGraphqlClient } from '@nhost/graphql-js'\nimport { urlFromSubdomain } from '../utils/helpers'\nimport { NhostClientConstructorParams } from '../utils/types'\n\n/**\n * Creates a client for GraphQL from either a subdomain or a URL\n */\nexport function createGraphqlClient(params: NhostClientConstructorParams) {\n  const graphqlUrl =\n    'subdomain' in params || 'backendUrl' in params\n      ? urlFromSubdomain(params, 'graphql')\n      : params.graphqlUrl\n\n  if (!graphqlUrl) {\n    throw new Error('Please provide `subdomain` or `graphqlUrl`.')\n  }\n\n  return new NhostGraphqlClient({ url: graphqlUrl, ...params })\n}\n", "import { HasuraStorageClient } from '@nhost/hasura-storage-js'\n\nimport { urlFromSubdomain } from '../utils/helpers'\nimport { NhostClientConstructorParams } from '../utils/types'\n\n/**\n * Creates a client for Storage from either a subdomain or a URL\n */\nexport function createStorageClient(params: NhostClientConstructorParams) {\n  const storageUrl =\n    'subdomain' in params || 'backendUrl' in params\n      ? urlFromSubdomain(params, 'storage')\n      : params.storageUrl\n\n  if (!storageUrl) {\n    throw new Error('Please provide `subdomain` or `storageUrl`.')\n  }\n\n  return new HasuraStorageClient({ url: storageUrl, ...params })\n}\n", "import { NhostGraphqlClient } from '@nhost/graphql-js'\nimport { HasuraAuthClient } from '@nhost/hasura-auth-js'\nimport { HasuraStorageClient } from '@nhost/hasura-storage-js'\nimport { NhostClientConstructorParams } from '../utils/types'\nimport { createAuthClient } from './auth'\nimport { createFunctionsClient, NhostFunctionsClient } from './functions'\nimport { createGraphqlClient } from './graphql'\nimport { createStorageClient } from './storage'\n\nexport const createNhostClient = (params: NhostClientConstructorParams) => new NhostClient(params)\n\nexport class NhostClient {\n  auth: HasuraAuthClient\n  storage: HasuraStorageClient\n  functions: NhostFunctionsClient\n  graphql: NhostGraphqlClient\n  private _adminSecret?: string\n  readonly devTools?: boolean\n\n  /**\n   * Nhost Client\n   *\n   * @example\n   * ```ts\n   * const nhost = new NhostClient({ subdomain, region });\n   * ```\n   *\n   * @docs https://docs.nhost.io/reference/javascript\n   */\n  constructor({\n    refreshIntervalTime,\n    clientStorage,\n    clientStorageType,\n    autoRefreshToken,\n    autoSignIn,\n    adminSecret,\n    devTools,\n    start = true,\n    ...urlParams\n  }: NhostClientConstructorParams) {\n    // * Set clients for all services\n    this.auth = createAuthClient({\n      refreshIntervalTime,\n      clientStorage,\n      clientStorageType,\n      autoRefreshToken,\n      autoSignIn,\n      start,\n      ...urlParams\n    })\n    this.storage = createStorageClient({ adminSecret, ...urlParams })\n    this.functions = createFunctionsClient({ adminSecret, ...urlParams })\n    this.graphql = createGraphqlClient({ adminSecret, ...urlParams })\n\n    this.auth.onAuthStateChanged((event, session) => {\n      if (event === 'SIGNED_OUT') {\n        this.storage.setAccessToken(undefined)\n        this.functions.setAccessToken(undefined)\n        this.graphql.setAccessToken(undefined)\n\n        return\n      }\n\n      const accessToken = session?.accessToken\n      this.storage.setAccessToken(accessToken)\n      this.functions.setAccessToken(accessToken)\n      this.graphql.setAccessToken(accessToken)\n    })\n\n    // * Update access token for clients, including when signin in\n    this.auth.onTokenChanged((session) => {\n      const accessToken = session?.accessToken\n      this.storage.setAccessToken(accessToken)\n      this.functions.setAccessToken(accessToken)\n      this.graphql.setAccessToken(accessToken)\n    })\n\n    this._adminSecret = adminSecret\n    this.devTools = devTools\n  }\n\n  get adminSecret(): string | undefined {\n    return this._adminSecret\n  }\n\n  set adminSecret(newValue: string | undefined) {\n    this._adminSecret = newValue\n    this.storage.setAdminSecret(newValue)\n    // TODO inconsistent API: storage can change admin secret, but functions/graphql cannot\n    // this.functions.setAdminSecret(newValue)\n    // this.graphql.setAdminSecret(newValue)\n  }\n}\n"],
  "mappings": "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",
  "names": ["InvalidCharacterError", "message", "this", "prototype", "Error", "name", "window", "atob", "bind", "input", "str", "String", "replace", "length", "bs", "buffer", "bc", "idx", "output", "charAt", "fromCharCode", "indexOf", "decodeURIComponent", "m", "p", "code", "charCodeAt", "toString", "toUpperCase", "err", "InvalidTokenError", "token", "options", "pos", "header", "JSON", "parse", "base64_url_decode", "split", "e", "NHOST_REFRESH_TOKEN_KEY", "NHOST_REFRESH_TOKEN_ID_KEY", "NHOST_JWT_EXPIRES_AT_KEY", "MIN_PASSWORD_LENGTH", "TOKEN_REFRESH_MARGIN_SECONDS", "REFRESH_TOKEN_MAX_ATTEMPTS", "NETWORK_ERROR_CODE", "OTHER_ERROR_CODE", "VALIDATION_ERROR_CODE", "STATE_ERROR_CODE", "CodifiedError", "original", "INVALID_EMAIL_ERROR", "INVALID_MFA_TYPE_ERROR", "INVALID_MFA_CODE_ERROR", "INVALID_PASSWORD_ERROR", "INVALID_PHONE_NUMBER_ERROR", "INVALID_MFA_TICKET_ERROR", "NO_MFA_TICKET_ERROR", "NO_REFRESH_TOKEN", "TOKEN_REFRESHER_RUNNING_ERROR", "USER_ALREADY_SIGNED_IN", "USER_UNAUTHENTICATED", "USER_NOT_ANONYMOUS", "EMAIL_NEEDS_VERIFICATION", "INVALID_REFRESH_TOKEN", "INVALID_SIGN_IN_METHOD", "INITIAL_MACHINE_CONTEXT", "utf8StringToBuffer", "value", "bufferToBase64URLString", "buffer", "bytes", "str", "charCode", "base64URLStringToBuffer", "base64URLString", "base64", "padLength", "padded", "binary", "i", "browserSupportsWebAuthn", "toPublicKeyCredentialDescriptor", "descriptor", "id", "isValidDomain", "hostname", "WebAuthnError", "message", "name", "identifyRegistrationError", "error", "options", "_a", "_b", "publicKey", "param", "effectiveDomain", "WebAuthnAbortService", "webauthnAbortService", "startRegistration", "creationOptionsJSON", "credential", "err", "rawId", "response", "type", "credentialJSON", "bufferToUTF8String", "browserSupportsWebAuthnAutofill", "globalPublicKeyCredential", "identifyAuthenticationError", "startAuthentication", "requestOptionsJSON", "useBrowserAutofill", "allowCredentials", "userHandle", "isBrowser", "inMemoryLocalStorage", "defaultClientStorageGetter", "key", "defaultClientStorageSetter", "localStorageGetter", "clientStorageType", "clientStorage", "Cookies", "localStorageSetter", "getSession", "context", "getAuthenticationResult", "accessToken", "refreshToken", "isError", "user", "fetch", "fetchPonyfill", "fetchWrapper", "url", "method", "token", "body", "headers", "result", "postFetch", "getFetch", "encodeQueryParameters", "baseUrl", "parameters", "encodedParameters", "stringValue", "rewriteRedirectTo", "clientUrl", "redirectTo", "otherOptions", "baseClientUrl", "clientParams", "additionalParams", "combinedParams", "pathName", "getParameterByName", "regex", "results", "removeParameterFromWindow", "location", "search", "hash", "isValidEmail", "email", "isValidPassword", "password", "isValidPhoneNumber", "phoneNumber", "isValidTicket", "ticket", "createAuthMachine", "backendUrl", "refreshIntervalTime", "autoRefreshToken", "autoSignIn", "storageGetter", "storageSetter", "postRequest", "data", "createMachine", "send", "assign", "importTokenAttempts", "_", "accessTokenExpiresIn", "nextRefresh", "refreshTokenId", "e", "ctx", "errors", "expiresAt", "accessTokenExpirationTime", "_context", "pat", "otp", "event", "nickname", "webAuthnOptions", "urlToken", "exception", "storageToken", "createChangeEmailMachine", "interpreter", "createChangePasswordMachine", "createEnableMfaMachine", "imageUrl", "totpSecret", "code", "activeMfaType", "createResetPasswordMachine", "createSendVerificationEmailMachine", "AuthClient", "start", "devTools", "defaultOptions", "existingToken", "initialSession", "machineWithInitialContext", "interpret", "fn", "subscription", "AuthCookieClient", "AuthClientSSR", "addSecurityKeyPromise", "changeEmailPromise", "resolve", "changePasswordPromise", "state", "generateQrCodePromise", "service", "activateMfaPromise", "resetPasswordPromise", "sendVerificationEmailPromise", "signInAnonymousPromise", "changed", "signInEmailPasswordPromise", "signInEmailPasswordlessPromise", "signInEmailSecurityKeyPromise", "signInMfaTotpPromise", "signInPATPromise", "signInSmsPasswordlessPromise", "signInSmsPasswordlessOtpPromise", "signOutPromise", "all", "signUpEmailPasswordPromise", "signUpEmailSecurityKeyPromise", "createPATPromise", "metadata", "HasuraAuthClient", "params", "anonymousResult", "provider", "providerUrl", "res", "personalAccessToken", "newPassword", "newEmail", "connectionAttempts", "jwt", "jwt_decode", "_c", "reject", "timer", "fetch", "fetchUpload", "backendUrl", "data", "accessToken", "name", "fileId", "bucketId", "adminSecret", "onUploadProgress", "initialHeaders", "headers", "url", "LegacyFormData", "fetchPonyfill", "response", "responseData", "_a", "e", "resolve", "xhr", "_b", "_e", "_d", "_c", "key", "value", "HasuraStorageApi", "formData", "error", "fileMetadata", "file", "id", "params", "appendImageTransformationParameters", "urlObject", "imageTransformationParams", "accumulator", "HasuraStorageClient", "presignedUrl", "urlWithTransformationParams", "FormData", "FallbackFormData", "INITIAL_FILE_CONTEXT", "createFileUploadMachine", "createMachine", "context", "event", "assign", "_", "loaded", "progress", "callback", "currentLoaded", "additions", "pure", "sendParent", "actions", "createMultipleFilesUploadMachine", "ref", "item", "snap", "files", "agg", "curr", "total", "spawn", "stopped", "send", "uploadFilePromise", "interpreter", "uploadMultipleFilesPromise", "service", "parseRequestArgs", "documentOrOptions", "variables", "config", "extractOperationName", "document", "operationName", "operationDefinitions", "definition", "_a", "resolveRequestDocument", "parsedDocument", "parse", "print", "NhostGraphqlClient", "params", "url", "adminSecret", "variablesAndRequestHeaders", "requestOptions", "headers", "otherOptions", "query", "response", "fetch", "data", "errors", "e", "error", "accessToken", "LOCALHOST_REGEX", "urlFromSubdomain", "backendOrSubdomain", "service", "backendUrl", "subdomain", "region", "subdomainLocalhostFound", "protocol", "host", "port", "urlFromEnv", "getValueFromEnv", "isBrowser", "environmentIsAvailable", "buildUrl", "baseUrl", "path", "urlPath", "createAuthClient", "params", "authUrl", "HasuraAuthClient", "createFunctionsClient", "functionsUrl", "NhostFunctionsClient", "url", "adminSecret", "body", "config", "headers", "fullUrl", "result", "fetch", "message", "_a", "data", "_b", "e", "error", "accessToken", "createGraphqlClient", "graphqlUrl", "NhostGraphqlClient", "createStorageClient", "storageUrl", "HasuraStorageClient", "createNhostClient", "NhostClient", "refreshIntervalTime", "clientStorage", "clientStorageType", "autoRefreshToken", "autoSignIn", "devTools", "start", "urlParams", "event", "session", "newValue"]
}
