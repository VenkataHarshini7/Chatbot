import {
  actions_exports,
  api,
  assign,
  createMachine,
  interpret,
  require_browser,
  require_browser2,
  require_fetch_browser,
  send,
  spawn
} from "./chunk-C5IEOSZL.js";
import {
  parse,
  print
} from "./chunk-HP7ZXSBS.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/jwt-decode/build/jwt-decode.esm.js
function e(e2) {
  this.message = e2;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t2 = String(r2).replace(/=+$/, "");
  if (t2.length % 4 == 1) throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a % 4 ? 64 * n2 + o2 : o2, a++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a & 6)) : 0) o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c;
};
function t(e2) {
  var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
  switch (t2.length % 4) {
    case 0:
      break;
    case 2:
      t2 += "==";
      break;
    case 3:
      t2 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e3) {
      return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
        var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
      }));
    }(t2);
  } catch (e3) {
    return r(t2);
  }
}
function n(e2) {
  this.message = e2;
}
function o(e2, r2) {
  if ("string" != typeof e2) throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e2.split(".")[o2]));
  } catch (e3) {
    throw new n("Invalid token specified: " + e3.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
var jwt_decode_esm_default = o;

// node_modules/@nhost/hasura-auth-js/dist/index.esm.js
var import_fetch_ponyfill = __toESM(require_fetch_browser());
var O = "nhostRefreshToken";
var N = "nhostRefreshTokenId";
var R = "nhostRefreshTokenExpiresAt";
var de = 3;
var fe = 60;
var H = 5;
var Z = 0;
var J = 1;
var k = 10;
var C = 20;
var U = class extends Error {
  constructor(e2) {
    super(e2.message), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), e2 instanceof Error ? (this.name = e2.name, this.error = {
      error: e2.name,
      status: J,
      message: e2.message
    }) : (this.name = e2.error, this.error = e2);
  }
};
var A = {
  status: k,
  error: "invalid-email",
  message: "Email is incorrectly formatted"
};
var he = {
  status: k,
  error: "invalid-mfa-type",
  message: "MFA type is invalid"
};
var me = {
  status: k,
  error: "invalid-mfa-code",
  message: "MFA code is invalid"
};
var $ = {
  status: k,
  error: "invalid-password",
  message: "Password is incorrectly formatted"
};
var Y = {
  status: k,
  error: "invalid-phone-number",
  message: "Phone number is incorrectly formatted"
};
var Ee = {
  status: k,
  error: "invalid-mfa-ticket",
  message: "MFA ticket is invalid"
};
var ge = {
  status: k,
  error: "no-mfa-ticket",
  message: "No MFA ticket has been provided"
};
var Te = {
  status: k,
  error: "no-refresh-token",
  message: "No refresh token has been provided"
};
var pe = {
  status: C,
  error: "refresher-already-running",
  message: "The token refresher is already running. You must wait until is has finished before submitting a new token."
};
var y = {
  status: C,
  error: "already-signed-in",
  message: "User is already signed in"
};
var we = {
  status: C,
  error: "unauthenticated-user",
  message: "User is not authenticated"
};
var or = {
  status: C,
  error: "user-not-anonymous",
  message: "User is not anonymous"
};
var ke = {
  status: C,
  error: "unverified-user",
  message: "Email needs verification"
};
var ye = {
  status: k,
  error: "invalid-refresh-token",
  message: "Invalid or expired refresh token"
};
var Se = {
  status: J,
  error: "invalid-sign-in-method",
  message: "Invalid sign-in method"
};
var G = {
  user: null,
  mfa: null,
  accessToken: {
    value: null,
    expiresAt: null,
    expiresInSeconds: 15
  },
  refreshTimer: {
    startedAt: null,
    attempts: 0,
    lastAttempt: null
  },
  refreshToken: {
    value: null
  },
  importTokenAttempts: 0,
  errors: {}
};
function ve(t2) {
  return new TextEncoder().encode(t2);
}
function _(t2) {
  const e2 = new Uint8Array(t2);
  let n2 = "";
  for (const s of e2)
    n2 += String.fromCharCode(s);
  return btoa(n2).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function j(t2) {
  const e2 = t2.replace(/-/g, "+").replace(/_/g, "/"), n2 = (4 - e2.length % 4) % 4, r2 = e2.padEnd(e2.length + n2, "="), s = atob(r2), i = new ArrayBuffer(s.length), c = new Uint8Array(i);
  for (let d2 = 0; d2 < s.length; d2++)
    c[d2] = s.charCodeAt(d2);
  return i;
}
function ee() {
  return (window == null ? void 0 : window.PublicKeyCredential) !== void 0 && typeof window.PublicKeyCredential == "function";
}
function re(t2) {
  const { id: e2 } = t2;
  return {
    ...t2,
    id: j(e2),
    transports: t2.transports
  };
}
function ne(t2) {
  return t2 === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t2);
}
var g = class extends Error {
  constructor(e2, n2 = "WebAuthnError") {
    super(e2), this.name = n2;
  }
};
function Ae({ error: t2, options: e2 }) {
  var n2, r2;
  const { publicKey: s } = e2;
  if (!s)
    throw Error("options was missing required publicKey property");
  if (t2.name === "AbortError") {
    if (e2.signal === new AbortController().signal)
      return new g("Registration ceremony was sent an abort signal", "AbortError");
  } else if (t2.name === "ConstraintError") {
    if (((n2 = s.authenticatorSelection) === null || n2 === void 0 ? void 0 : n2.requireResidentKey) === true)
      return new g("Discoverable credentials were required but no available authenticator supported it", "ConstraintError");
    if (((r2 = s.authenticatorSelection) === null || r2 === void 0 ? void 0 : r2.userVerification) === "required")
      return new g("User verification was required but no available authenticator supported it", "ConstraintError");
  } else {
    if (t2.name === "InvalidStateError")
      return new g("The authenticator was previously registered", "InvalidStateError");
    if (t2.name === "NotAllowedError")
      return new g("User clicked cancel, or the registration ceremony timed out", "NotAllowedError");
    if (t2.name === "NotSupportedError")
      return s.pubKeyCredParams.filter((c) => c.type === "public-key").length === 0 ? new g('No entry in pubKeyCredParams was of type "public-key"', "NotSupportedError") : new g("No available authenticator supported any of the specified pubKeyCredParams algorithms", "NotSupportedError");
    if (t2.name === "SecurityError") {
      const i = window.location.hostname;
      if (ne(i)) {
        if (s.rp.id !== i)
          return new g(`The RP ID "${s.rp.id}" is invalid for this domain`, "SecurityError");
      } else
        return new g(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (t2.name === "TypeError") {
      if (s.user.id.byteLength < 1 || s.user.id.byteLength > 64)
        return new g("User ID was not between 1 and 64 characters", "TypeError");
    } else if (t2.name === "UnknownError")
      return new g("The authenticator was unable to process the specified options, or could not create a new credential", "UnknownError");
  }
  return t2;
}
var Ie = class {
  createNewAbortSignal() {
    return this.controller && this.controller.abort(), this.controller = new AbortController(), this.controller.signal;
  }
  reset() {
    this.controller = void 0;
  }
};
var K = new Ie();
async function te(t2) {
  if (!ee())
    throw new Error("WebAuthn is not supported in this browser");
  const n2 = { publicKey: {
    ...t2,
    challenge: j(t2.challenge),
    user: {
      ...t2.user,
      id: ve(t2.user.id)
    },
    excludeCredentials: t2.excludeCredentials.map(re)
  } };
  n2.signal = K.createNewAbortSignal();
  let r2;
  try {
    r2 = await navigator.credentials.create(n2);
  } catch (h) {
    throw Ae({ error: h, options: n2 });
  } finally {
    K.reset();
  }
  if (!r2)
    throw new Error("Registration was not completed");
  const { id: s, rawId: i, response: c, type: d2 } = r2, f = {
    id: s,
    rawId: _(i),
    response: {
      attestationObject: _(c.attestationObject),
      clientDataJSON: _(c.clientDataJSON)
    },
    type: d2,
    clientExtensionResults: r2.getClientExtensionResults(),
    authenticatorAttachment: r2.authenticatorAttachment
  };
  return typeof c.getTransports == "function" && (f.transports = c.getTransports()), f;
}
function _e(t2) {
  return new TextDecoder("utf-8").decode(t2);
}
async function Re() {
  if (navigator.credentials.conditionalMediationSupported)
    return true;
  const t2 = window.PublicKeyCredential;
  return t2.isConditionalMediationAvailable !== void 0 && t2.isConditionalMediationAvailable();
}
function Pe({ error: t2, options: e2 }) {
  var n2;
  const { publicKey: r2 } = e2;
  if (!r2)
    throw Error("options was missing required publicKey property");
  if (t2.name === "AbortError") {
    if (e2.signal === new AbortController().signal)
      return new g("Authentication ceremony was sent an abort signal", "AbortError");
  } else {
    if (t2.name === "NotAllowedError")
      return !((n2 = r2.allowCredentials) === null || n2 === void 0) && n2.length ? new g("No available authenticator recognized any of the allowed credentials", "NotAllowedError") : new g("User clicked cancel, or the authentication ceremony timed out", "NotAllowedError");
    if (t2.name === "SecurityError") {
      const s = window.location.hostname;
      if (ne(s)) {
        if (r2.rpId !== s)
          return new g(`The RP ID "${r2.rpId}" is invalid for this domain`, "SecurityError");
      } else
        return new g(`${window.location.hostname} is an invalid domain`, "SecurityError");
    } else if (t2.name === "UnknownError")
      return new g("The authenticator was unable to process the specified options, or could not create a new assertion signature", "UnknownError");
  }
  return t2;
}
async function Oe(t2, e2 = false) {
  var n2, r2;
  if (!ee())
    throw new Error("WebAuthn is not supported in this browser");
  let s;
  ((n2 = t2.allowCredentials) === null || n2 === void 0 ? void 0 : n2.length) !== 0 && (s = (r2 = t2.allowCredentials) === null || r2 === void 0 ? void 0 : r2.map(re));
  const i = {
    ...t2,
    challenge: j(t2.challenge),
    allowCredentials: s
  }, c = {};
  if (e2) {
    if (!await Re())
      throw Error("Browser does not support WebAuthn autofill");
    if (document.querySelectorAll("input[autocomplete*='webauthn']").length < 1)
      throw Error('No <input> with `"webauthn"` in its `autocomplete` attribute was detected');
    c.mediation = "conditional", i.allowCredentials = [];
  }
  c.publicKey = i, c.signal = K.createNewAbortSignal();
  let d2;
  try {
    d2 = await navigator.credentials.get(c);
  } catch (l) {
    throw Pe({ error: l, options: c });
  } finally {
    K.reset();
  }
  if (!d2)
    throw new Error("Authentication was not completed");
  const { id: f, rawId: h, response: a, type: o2 } = d2;
  let u2;
  return a.userHandle && (u2 = _e(a.userHandle)), {
    id: f,
    rawId: _(h),
    response: {
      authenticatorData: _(a.authenticatorData),
      clientDataJSON: _(a.clientDataJSON),
      signature: _(a.signature),
      userHandle: u2
    },
    type: o2,
    clientExtensionResults: d2.getClientExtensionResults(),
    authenticatorAttachment: d2.authenticatorAttachment
  };
}
var V = typeof window != "undefined";
var M = /* @__PURE__ */ new Map();
var be = (t2) => {
  var e2;
  return V && typeof localStorage != "undefined" ? localStorage.getItem(t2) : (e2 = M.get(t2)) != null ? e2 : null;
};
var Ce = (t2, e2) => {
  V && typeof localStorage != "undefined" ? e2 ? localStorage.setItem(t2, e2) : localStorage.removeItem(t2) : e2 ? M.set(t2, e2) : M.has(t2) && M.delete(t2);
};
var Ne = (t2, e2) => {
  if (t2 === "localStorage" || t2 === "web")
    return be;
  if (t2 === "cookie")
    return (n2) => {
      var r2;
      return V && (r2 = api.get(n2)) != null ? r2 : null;
    };
  if (!e2)
    throw Error(
      `clientStorageType is set to '${t2}' but no clientStorage has been given`
    );
  if (t2 === "react-native")
    return (n2) => {
      var r2;
      return (r2 = e2.getItem) == null ? void 0 : r2.call(e2, n2);
    };
  if (t2 === "capacitor")
    return (n2) => {
      var r2;
      return (r2 = e2.get) == null ? void 0 : r2.call(e2, { key: n2 });
    };
  if (t2 === "expo-secure-storage")
    return (n2) => {
      var r2;
      return (r2 = e2.getItemAsync) == null ? void 0 : r2.call(e2, n2);
    };
  if (t2 === "custom") {
    if (e2.getItem && e2.removeItem)
      return e2.getItem;
    if (e2.getItemAsync)
      return e2.getItemAsync;
    throw Error(
      `clientStorageType is set to 'custom' but clientStorage is missing either "getItem" and "removeItem" properties or "getItemAsync" property`
    );
  }
  throw Error(`Unknown storage type: ${t2}`);
};
var xe = (t2, e2) => {
  if (t2 === "localStorage" || t2 === "web")
    return Ce;
  if (t2 === "cookie")
    return (n2, r2) => {
      V && (r2 ? api.set(n2, r2, { expires: 30, sameSite: "lax", httpOnly: false }) : api.remove(n2));
    };
  if (!e2)
    throw Error(
      `clientStorageType is set to '${t2}' but no clienStorage has been given`
    );
  if (t2 === "react-native")
    return (n2, r2) => {
      var s, i;
      return r2 ? (s = e2.setItem) == null ? void 0 : s.call(e2, n2, r2) : (i = e2.removeItem) == null ? void 0 : i.call(e2, n2);
    };
  if (t2 === "capacitor")
    return (n2, r2) => {
      var s, i;
      return r2 ? (s = e2.set) == null ? void 0 : s.call(e2, { key: n2, value: r2 }) : (i = e2.remove) == null ? void 0 : i.call(e2, { key: n2 });
    };
  if (t2 === "expo-secure-storage")
    return async (n2, r2) => {
      var s, i;
      return r2 ? (s = e2.setItemAsync) == null ? void 0 : s.call(e2, n2, r2) : (i = e2.deleteItemAsync) == null ? void 0 : i.call(e2, n2);
    };
  if (t2 === "custom") {
    if (!e2.removeItem)
      throw Error(
        "clientStorageType is set to 'custom' but clientStorage is missing a removeItem property"
      );
    if (e2.setItem)
      return (n2, r2) => {
        var s, i;
        return r2 ? (s = e2.setItem) == null ? void 0 : s.call(e2, n2, r2) : (i = e2.removeItem) == null ? void 0 : i.call(e2, n2);
      };
    if (e2.setItemAsync)
      return async (n2, r2) => {
        var s, i;
        return r2 ? (s = e2.setItemAsync) == null ? void 0 : s.call(e2, n2, r2) : (i = e2.removeItem) == null ? void 0 : i.call(e2, n2);
      };
    throw Error(
      "clientStorageType is set to 'custom' but clientStorage is missing setItem or setItemAsync property"
    );
  }
  throw Error(`Unknown storage type: ${t2}`);
};
var x = (t2) => !t2 || !t2.accessToken.value || !t2.accessToken.expiresAt || !t2.user ? null : {
  accessToken: t2.accessToken.value,
  accessTokenExpiresIn: (t2.accessToken.expiresAt.getTime() - Date.now()) / 1e3,
  refreshToken: t2.refreshToken.value,
  user: t2.user
};
var v = ({
  accessToken: t2,
  refreshToken: e2,
  isError: n2,
  user: r2,
  error: s
}) => n2 ? {
  session: null,
  error: s
} : r2 && t2 ? {
  // TODO either return the refresh token or remove it from the session type
  session: { accessToken: t2, accessTokenExpiresIn: 0, refreshToken: e2, user: r2 },
  error: null
} : { session: null, error: null };
var q = () => typeof window != "undefined";
var se = globalThis.fetch;
typeof EdgeRuntime != "string" && (se = (0, import_fetch_ponyfill.default)().fetch);
var ie = async (t2, e2, { token: n2, body: r2 } = {}) => {
  const s = {
    "Content-Type": "application/json",
    Accept: "*/*"
  };
  n2 && (s.Authorization = `Bearer ${n2}`);
  const i = {
    method: e2,
    headers: s
  };
  r2 && (i.body = JSON.stringify(r2));
  try {
    const c = await se(t2, i);
    if (!c.ok) {
      const d2 = await c.json();
      return Promise.reject({ error: d2 });
    }
    try {
      return { data: await c.json(), error: null };
    } catch {
      return console.warn(`Unexpected response: can't parse the response of the server at ${t2}`), { data: "OK", error: null };
    }
  } catch {
    const d2 = {
      message: "Network Error",
      status: Z,
      error: "network"
    };
    return Promise.reject({ error: d2 });
  }
};
var S = async (t2, e2, n2) => ie(t2, "POST", { token: n2, body: e2 });
var De = (t2, e2) => ie(t2, "GET", { token: e2 });
var oe = (t2, e2) => {
  const n2 = e2 && Object.entries(e2).map(([r2, s]) => {
    const i = Array.isArray(s) ? s.join(",") : typeof s == "object" ? JSON.stringify(s) : s;
    return `${r2}=${encodeURIComponent(i)}`;
  }).join("&");
  return n2 ? `${t2}?${n2}` : t2;
};
var w = (t2, e2) => {
  if (!(e2 != null && e2.redirectTo))
    return e2;
  const { redirectTo: n2, ...r2 } = e2;
  if (!t2)
    return n2.startsWith("/") ? r2 : e2;
  const s = new URL(t2), i = Object.fromEntries(new URLSearchParams(s.search)), c = new URL(n2.startsWith("/") ? s.origin + n2 : n2), d2 = new URLSearchParams(c.search);
  let f = Object.fromEntries(d2);
  n2.startsWith("/") && (f = { ...i, ...f });
  let h = s.pathname;
  return c.pathname.length > 1 && (h += c.pathname.slice(1)), {
    ...r2,
    redirectTo: oe(c.origin + h, f)
  };
};
function D(t2, e2) {
  var s;
  if (!e2) {
    if (typeof window == "undefined")
      return;
    e2 = ((s = window.location) == null ? void 0 : s.href) || "";
  }
  t2 = t2.replace(/[\[\]]/g, "\\$&");
  const n2 = new RegExp("[?&#]" + t2 + "(=([^&#]*)|&|#|$)"), r2 = n2.exec(e2);
  return r2 ? r2[2] ? decodeURIComponent(r2[2].replace(/\+/g, " ")) : "" : null;
}
function F(t2) {
  var n2;
  if (typeof window == "undefined")
    return;
  const e2 = window == null ? void 0 : window.location;
  if (e2 && e2) {
    const r2 = new URLSearchParams(e2.search), s = new URLSearchParams((n2 = e2.hash) == null ? void 0 : n2.slice(1));
    r2.delete(t2), s.delete(t2);
    let i = window.location.pathname;
    Array.from(r2).length && (i += `?${r2.toString()}`), Array.from(s).length && (i += `#${s.toString()}`), window.history.pushState({}, "", i);
  }
}
var I = (t2) => !!t2 && typeof t2 == "string" && !!String(t2).toLowerCase().match(
  /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/
);
var W = (t2) => !!t2 && typeof t2 == "string" && t2.length >= de;
var z = (t2) => !!t2 && typeof t2 == "string";
var Ue = (t2) => t2 && typeof t2 == "string" && t2.match(/^mfaTotp:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);
var Me = ({
  backendUrl: t2,
  clientUrl: e2,
  clientStorageType: n2 = "web",
  clientStorage: r2,
  refreshIntervalTime: s,
  autoRefreshToken: i = true,
  autoSignIn: c = true
}) => {
  const d2 = Ne(n2, r2), f = xe(n2, r2), h = async (a, o2, u2) => (await S(`${t2}${a}`, o2, u2)).data;
  return createMachine(
    {
      schema: {
        context: {},
        events: {},
        services: {}
      },
      tsTypes: {},
      context: G,
      predictableActionArguments: true,
      id: "nhost",
      type: "parallel",
      states: {
        authentication: {
          initial: "starting",
          on: {
            SESSION_UPDATE: [
              {
                cond: "hasSession",
                actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                target: ".signedIn"
              }
            ]
          },
          states: {
            starting: {
              tags: ["loading"],
              always: { cond: "isSignedIn", target: "signedIn" },
              invoke: {
                id: "importRefreshToken",
                src: "importRefreshToken",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "signedIn"
                  },
                  {
                    target: "signedOut"
                  }
                ],
                onError: [
                  {
                    cond: "shouldRetryImportToken",
                    actions: "incrementTokenImportAttempts",
                    target: "retryTokenImport"
                  },
                  { actions: ["saveAuthenticationError"], target: "signedOut" }
                ]
              }
            },
            retryTokenImport: {
              tags: ["loading"],
              after: {
                RETRY_IMPORT_TOKEN_DELAY: "starting"
              }
            },
            signedOut: {
              initial: "noErrors",
              entry: "reportSignedOut",
              states: {
                noErrors: {},
                success: {},
                needsSmsOtp: {},
                needsMfa: {},
                failed: {},
                signingOut: {
                  entry: ["clearContextExceptRefreshToken"],
                  exit: ["destroyRefreshToken", "reportTokenChanged"],
                  invoke: {
                    src: "signout",
                    id: "signingOut",
                    onDone: {
                      target: "success"
                    },
                    onError: {
                      target: "failed",
                      actions: ["saveAuthenticationError"]
                    }
                  }
                }
              },
              on: {
                SIGNIN_PASSWORD: "authenticating.password",
                SIGNIN_ANONYMOUS: "authenticating.anonymous",
                SIGNIN_SECURITY_KEY_EMAIL: "authenticating.securityKeyEmail",
                SIGNIN_MFA_TOTP: "authenticating.mfa.totp",
                SIGNIN_PAT: "authenticating.pat"
              }
            },
            authenticating: {
              entry: "resetErrors",
              states: {
                password: {
                  invoke: {
                    src: "signInPassword",
                    id: "authenticateUserWithPassword",
                    onDone: [
                      {
                        cond: "hasMfaTicket",
                        actions: ["saveMfaTicket"],
                        target: "#nhost.authentication.signedOut.needsMfa"
                      },
                      {
                        actions: ["saveSession", "reportTokenChanged"],
                        target: "#nhost.authentication.signedIn"
                      }
                    ],
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                },
                pat: {
                  invoke: {
                    src: "signInPAT",
                    id: "authenticateWithPAT",
                    onDone: {
                      actions: ["savePATSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                anonymous: {
                  invoke: {
                    src: "signInAnonymous",
                    id: "authenticateAnonymously",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: {
                      actions: "saveAuthenticationError",
                      target: "#nhost.authentication.signedOut.failed"
                    }
                  }
                },
                mfa: {
                  states: {
                    totp: {
                      invoke: {
                        src: "signInMfaTotp",
                        id: "signInMfaTotp",
                        onDone: {
                          actions: ["saveSession", "reportTokenChanged"],
                          target: "#nhost.authentication.signedIn"
                        },
                        onError: {
                          actions: ["saveAuthenticationError"],
                          target: "#nhost.authentication.signedOut.failed"
                        }
                      }
                    }
                  }
                },
                securityKeyEmail: {
                  invoke: {
                    src: "signInSecurityKeyEmail",
                    id: "authenticateUserWithSecurityKey",
                    onDone: {
                      actions: ["saveSession", "reportTokenChanged"],
                      target: "#nhost.authentication.signedIn"
                    },
                    onError: [
                      {
                        cond: "unverified",
                        target: [
                          "#nhost.authentication.signedOut",
                          "#nhost.registration.incomplete.needsEmailVerification"
                        ]
                      },
                      {
                        actions: "saveAuthenticationError",
                        target: "#nhost.authentication.signedOut.failed"
                      }
                    ]
                  }
                }
              }
            },
            signedIn: {
              type: "parallel",
              entry: ["reportSignedIn", "cleanUrl", "broadcastToken", "resetErrors"],
              on: {
                SIGNOUT: "signedOut.signingOut"
              },
              states: {
                refreshTimer: {
                  id: "timer",
                  initial: "idle",
                  states: {
                    disabled: { type: "final" },
                    stopped: {
                      always: {
                        cond: "noToken",
                        target: "idle"
                      }
                    },
                    idle: {
                      always: [
                        { cond: "isAutoRefreshDisabled", target: "disabled" },
                        { cond: "isRefreshTokenPAT", target: "disabled" },
                        { cond: "hasRefreshToken", target: "running" }
                      ]
                    },
                    running: {
                      initial: "pending",
                      entry: "resetTimer",
                      states: {
                        pending: {
                          after: {
                            1e3: {
                              internal: false,
                              target: "pending"
                            }
                          },
                          always: {
                            cond: "refreshTimerShouldRefresh",
                            target: "refreshing"
                          }
                        },
                        refreshing: {
                          invoke: {
                            src: "refreshToken",
                            id: "refreshToken",
                            onDone: {
                              actions: ["saveSession", "resetTimer", "reportTokenChanged"],
                              target: "pending"
                            },
                            onError: [{ actions: "saveRefreshAttempt", target: "pending" }]
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        token: {
          initial: "idle",
          states: {
            idle: {
              on: {
                TRY_TOKEN: "running"
              },
              initial: "noErrors",
              states: { noErrors: {}, error: {} }
            },
            running: {
              invoke: {
                src: "refreshToken",
                id: "authenticateWithToken",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: ["#nhost.authentication.signedIn", "idle.noErrors"]
                },
                onError: [
                  { cond: "isSignedIn", target: "idle.error" },
                  {
                    actions: "saveAuthenticationError",
                    target: ["#nhost.authentication.signedOut.failed", "idle.error"]
                  }
                ]
              }
            }
          }
        },
        registration: {
          initial: "incomplete",
          on: {
            SIGNED_IN: [{ cond: "isAnonymous", target: ".incomplete" }, ".complete"]
          },
          states: {
            incomplete: {
              on: {
                SIGNUP_EMAIL_PASSWORD: "emailPassword",
                SIGNUP_SECURITY_KEY: "securityKey",
                PASSWORDLESS_EMAIL: "passwordlessEmail",
                PASSWORDLESS_SMS: "passwordlessSms",
                PASSWORDLESS_SMS_OTP: "passwordlessSmsOtp"
              },
              initial: "noErrors",
              states: {
                noErrors: {},
                needsEmailVerification: {},
                needsOtp: {},
                failed: {}
              }
            },
            emailPassword: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpEmailPassword",
                id: "signUpEmailPassword",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            securityKey: {
              entry: ["resetErrors"],
              invoke: {
                src: "signUpSecurityKey",
                id: "signUpSecurityKey",
                onDone: [
                  {
                    cond: "hasSession",
                    actions: ["saveSession", "reportTokenChanged"],
                    target: "#nhost.authentication.signedIn"
                  },
                  {
                    actions: "clearContext",
                    target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                  }
                ],
                onError: [
                  {
                    cond: "unverified",
                    target: "incomplete.needsEmailVerification"
                  },
                  {
                    actions: "saveRegistrationError",
                    target: "incomplete.failed"
                  }
                ]
              }
            },
            passwordlessEmail: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessEmail",
                id: "passwordlessEmail",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsEmailVerification"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSms: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSms",
                id: "passwordlessSms",
                onDone: {
                  actions: "clearContext",
                  target: ["#nhost.authentication.signedOut", "incomplete.needsOtp"]
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            passwordlessSmsOtp: {
              entry: ["resetErrors"],
              invoke: {
                src: "passwordlessSmsOtp",
                id: "passwordlessSmsOtp",
                onDone: {
                  actions: ["saveSession", "reportTokenChanged"],
                  target: "#nhost.authentication.signedIn"
                },
                onError: {
                  actions: "saveRegistrationError",
                  target: "incomplete.failed"
                }
              }
            },
            complete: {
              on: {
                SIGNED_OUT: "incomplete"
              }
            }
          }
        }
      }
    },
    {
      actions: {
        reportSignedIn: send("SIGNED_IN"),
        reportSignedOut: send("SIGNED_OUT"),
        reportTokenChanged: send("TOKEN_CHANGED"),
        incrementTokenImportAttempts: assign({
          importTokenAttempts: ({ importTokenAttempts: a }) => a + 1
        }),
        clearContext: assign(() => (f(R, null), f(O, null), f(N, null), {
          ...G
        })),
        clearContextExceptRefreshToken: assign(({ refreshToken: { value: a } }) => (f(R, null), {
          ...G,
          refreshToken: { value: a }
        })),
        // * Save session in the context, and persist the refresh token and the jwt expiration outside of the machine
        saveSession: assign({
          user: (a, { data: o2 }) => {
            var u2;
            return ((u2 = o2 == null ? void 0 : o2.session) == null ? void 0 : u2.user) || null;
          },
          accessToken: (a, { data: o2 }) => {
            if (o2.session) {
              const { accessTokenExpiresIn: u2, accessToken: l } = o2.session, m4 = new Date(Date.now() + u2 * 1e3);
              return f(R, m4.toISOString()), {
                value: l,
                expiresAt: m4,
                expiresInSeconds: u2
              };
            }
            return f(R, null), {
              value: null,
              expiresAt: null,
              expiresInSeconds: null
            };
          },
          refreshToken: (a, { data: o2 }) => {
            var m4, p;
            const u2 = ((m4 = o2.session) == null ? void 0 : m4.refreshToken) || null, l = ((p = o2.session) == null ? void 0 : p.refreshTokenId) || null;
            return u2 && f(O, u2), l && f(N, l), { value: u2 };
          }
        }),
        savePATSession: assign({
          user: (a, { data: o2 }) => {
            var u2;
            return ((u2 = o2 == null ? void 0 : o2.session) == null ? void 0 : u2.user) || null;
          },
          accessToken: (a, { data: o2 }) => {
            if (o2.session) {
              const { accessTokenExpiresIn: u2, accessToken: l } = o2.session, m4 = new Date(Date.now() + u2 * 1e3);
              return f(R, m4.toISOString()), {
                value: l,
                expiresAt: m4,
                expiresInSeconds: u2
              };
            }
            return f(R, null), {
              value: null,
              expiresAt: null,
              expiresInSeconds: null
            };
          },
          refreshToken: (a, { data: o2 }) => {
            var m4, p;
            const u2 = ((m4 = o2.session) == null ? void 0 : m4.refreshToken) || null, l = ((p = o2.session) == null ? void 0 : p.refreshTokenId) || null;
            return u2 && f(O, u2), l && f(N, l), { value: u2, isPAT: true };
          }
        }),
        saveMfaTicket: assign({
          mfa: (a, o2) => {
            var u2;
            return (u2 = o2.data) == null ? void 0 : u2.mfa;
          }
        }),
        resetTimer: assign({
          refreshTimer: (a) => ({
            startedAt: /* @__PURE__ */ new Date(),
            attempts: 0,
            lastAttempt: null
          })
        }),
        saveRefreshAttempt: assign({
          refreshTimer: (a, o2) => ({
            startedAt: a.refreshTimer.startedAt,
            attempts: a.refreshTimer.attempts + 1,
            lastAttempt: /* @__PURE__ */ new Date()
          })
        }),
        // * Authentication errors
        saveAuthenticationError: assign({
          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
          errors: ({ errors: a }, { data: { error: o2 } }) => ({
            ...a,
            authentication: o2
          })
        }),
        resetErrors: assign({
          errors: (a) => ({}),
          importTokenAttempts: (a) => 0
        }),
        saveRegistrationError: assign({
          // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
          errors: ({ errors: a }, { data: { error: o2 } }) => ({ ...a, registration: o2 })
        }),
        destroyRefreshToken: assign({
          refreshToken: (a) => (f(O, null), f(N, null), { value: null })
        }),
        // * Clean the browser url when `autoSignIn` is activated
        cleanUrl: () => {
          c && D("refreshToken") && (F("refreshToken"), F("type"));
        },
        // * Broadcast the token to other tabs when `autoSignIn` is activated
        broadcastToken: (a) => {
          if (c)
            try {
              new BroadcastChannel("nhost").postMessage(a.refreshToken.value);
            } catch {
            }
        }
      },
      guards: {
        isAnonymous: (a, o2) => {
          var u2;
          return !!((u2 = a.user) != null && u2.isAnonymous);
        },
        isSignedIn: (a) => !!a.user && !!a.accessToken.value,
        noToken: (a) => !a.refreshToken.value,
        isRefreshTokenPAT: (a) => {
          var o2;
          return !!((o2 = a.refreshToken) != null && o2.isPAT);
        },
        hasRefreshToken: (a) => !!a.refreshToken.value,
        isAutoRefreshDisabled: () => !i,
        refreshTimerShouldRefresh: (a) => {
          const { expiresAt: o2 } = a.accessToken;
          if (!o2)
            return false;
          if (a.refreshTimer.lastAttempt)
            return a.refreshTimer.attempts > H ? false : Date.now() - a.refreshTimer.lastAttempt.getTime() > Math.pow(2, a.refreshTimer.attempts - 1) * 5e3;
          if (s && Date.now() - a.refreshTimer.startedAt.getTime() > s * 1e3)
            return true;
          const u2 = a.accessToken.expiresInSeconds;
          return u2 ? o2.getTime() - Date.now() - 1e3 * Math.min(fe, u2 * 0.5) <= 0 : false;
        },
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        /** Shoud retry to import the token on network error or any internal server error.
         * Don't retry more than REFRESH_TOKEN_MAX_ATTEMPTS times.
         */
        shouldRetryImportToken: (a, o2) => a.importTokenAttempts < H && (o2.data.error.status === Z || o2.data.error.status >= 500),
        // * Authentication errors
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        unverified: (a, { data: { error: o2 } }) => o2.status === 401 && // * legacy: don't use the message contents to determine if the email is unverified, but the error type (error.error)
        (o2.message === "Email is not verified" || o2.error === "unverified-user"),
        // * Event guards
        hasSession: (a, o2) => {
          var u2;
          return !!((u2 = o2.data) != null && u2.session);
        },
        hasMfaTicket: (a, o2) => {
          var u2;
          return !!((u2 = o2.data) != null && u2.mfa);
        }
      },
      services: {
        signInPassword: (a, { email: o2, password: u2 }) => I(o2) ? W(u2) ? h("/signin/email-password", {
          email: o2,
          password: u2
        }) : Promise.reject({ error: $ }) : Promise.reject({ error: A }),
        signInPAT: (a, { pat: o2 }) => h("/signin/pat", {
          personalAccessToken: o2
        }),
        passwordlessSms: (a, { phoneNumber: o2, options: u2 }) => {
          var l;
          return z(o2) ? (l = a.user) != null && l.isAnonymous ? (console.warn(
            "Deanonymisation from a phone number is not yet implemented in hasura-auth"
          ), h(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "sms",
              phoneNumber: o2,
              options: w(e2, u2)
            },
            a.accessToken.value
          )) : h("/signin/passwordless/sms", {
            phoneNumber: o2,
            options: w(e2, u2)
          }) : Promise.reject({ error: Y });
        },
        passwordlessSmsOtp: (a, { phoneNumber: o2, otp: u2 }) => z(o2) ? h("/signin/passwordless/sms/otp", {
          phoneNumber: o2,
          otp: u2
        }) : Promise.reject({ error: Y }),
        passwordlessEmail: (a, { email: o2, options: u2 }) => {
          var l;
          return I(o2) ? (l = a.user) != null && l.isAnonymous ? h(
            "/user/deanonymize",
            {
              signInMethod: "passwordless",
              connection: "email",
              email: o2,
              options: w(e2, u2)
            },
            a.accessToken.value
          ) : h("/signin/passwordless/email", {
            email: o2,
            options: w(e2, u2)
          }) : Promise.reject({ error: A });
        },
        signInAnonymous: (a) => h("/signin/anonymous"),
        signInMfaTotp: (a, o2) => {
          var l;
          const u2 = o2.ticket || ((l = a.mfa) == null ? void 0 : l.ticket);
          return u2 ? Ue(u2) ? h("/signin/mfa/totp", {
            ticket: u2,
            otp: o2.otp
          }) : Promise.reject({ error: Ee }) : Promise.reject({ error: ge });
        },
        signInSecurityKeyEmail: async (a, { email: o2 }) => {
          if (!I(o2))
            throw new U(A);
          const u2 = await h(
            "/signin/webauthn",
            { email: o2 }
          );
          let l;
          try {
            l = await Oe(u2);
          } catch (m4) {
            throw new U(m4);
          }
          return h("/signin/webauthn/verify", { email: o2, credential: l });
        },
        refreshToken: async (a, o2) => {
          const u2 = o2.type === "TRY_TOKEN" ? o2.token : a.refreshToken.value;
          return { session: await h("/token", {
            refreshToken: u2
          }), error: null };
        },
        signout: (a, o2) => h("/signout", {
          refreshToken: a.refreshToken.value,
          all: !!o2.all
        }),
        signUpEmailPassword: async (a, { email: o2, password: u2, options: l }) => {
          var m4;
          return I(o2) ? W(u2) ? (m4 = a.user) != null && m4.isAnonymous ? h(
            "/user/deanonymize",
            {
              signInMethod: "email-password",
              email: o2,
              password: u2,
              options: w(e2, l)
            },
            a.accessToken.value
          ) : h("/signup/email-password", {
            email: o2,
            password: u2,
            options: w(e2, l)
          }) : Promise.reject({ error: $ }) : Promise.reject({ error: A });
        },
        signUpSecurityKey: async (a, { email: o2, options: u2 }) => {
          if (!I(o2))
            return Promise.reject({ error: A });
          const l = u2 == null ? void 0 : u2.nickname;
          l && delete u2.nickname;
          const m4 = await h(
            "/signup/webauthn",
            { email: o2, options: u2 }
          );
          let p;
          try {
            p = await te(m4);
          } catch (ce) {
            throw new U(ce);
          }
          return h("/signup/webauthn/verify", {
            credential: p,
            options: {
              redirectTo: u2 == null ? void 0 : u2.redirectTo,
              nickname: l
            }
          });
        },
        importRefreshToken: async (a) => {
          if (a.user && a.refreshToken.value && a.accessToken.value && a.accessToken.expiresAt)
            return {
              session: {
                accessToken: a.accessToken.value,
                accessTokenExpiresIn: a.accessToken.expiresAt.getTime() - Date.now(),
                refreshToken: a.refreshToken.value,
                user: a.user
              },
              error: null
            };
          let o2 = null;
          if (c) {
            const l = D("refreshToken") || null;
            if (l)
              try {
                return { session: await h("/token", {
                  refreshToken: l
                }), error: null };
              } catch (m4) {
                o2 = m4.error;
              }
            else {
              const m4 = D("error");
              if (m4)
                return Promise.reject({
                  session: null,
                  error: {
                    status: k,
                    error: m4,
                    message: D("errorDescription") || m4
                  }
                });
            }
          }
          const u2 = await d2(O);
          if (u2)
            try {
              return { session: await h("/token", {
                refreshToken: u2
              }), error: null };
            } catch (l) {
              o2 = l.error;
            }
          return o2 ? Promise.reject({ error: o2, session: null }) : { error: null, session: null };
        }
      },
      delays: {
        RETRY_IMPORT_TOKEN_DELAY: ({ importTokenAttempts: a }) => Math.pow(2, a - 1) * 5e3
      }
    }
  );
};
var Ke = ({ backendUrl: t2, clientUrl: e2, interpreter: n2 }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "changeEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: assign({ error: (r2) => A }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (r2, { data: { error: s } }) => s
      }),
      reportError: send((r2) => ({ type: "ERROR", error: r2.error })),
      // TODO change email in the main machine (context.user.email)
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (r2, { email: s }) => !I(s)
    },
    services: {
      requestChange: async (r2, { email: s, options: i }) => (await S(
        `${t2}/user/email/change`,
        { newEmail: s, options: w(e2, i) },
        n2 == null ? void 0 : n2.getSnapshot().context.accessToken.value
      )).data
    }
  }
);
var Ve = ({ backendUrl: t2, interpreter: e2 }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidPassword",
              actions: "saveInvalidPasswordError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidPasswordError: assign({ error: (n2) => $ }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (n2, { data: { error: r2 } }) => r2
      }),
      reportError: send((n2) => ({ type: "ERROR", error: n2.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidPassword: (n2, { password: r2 }) => !W(r2)
    },
    services: {
      requestChange: (n2, { password: r2, ticket: s }) => S(
        `${t2}/user/password`,
        { newPassword: r2, ticket: s },
        e2 == null ? void 0 : e2.getSnapshot().context.accessToken.value
      )
    }
  }
);
var ar = ({ backendUrl: t2, interpreter: e2 }) => createMachine(
  {
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "enableMfa",
    initial: "idle",
    context: { error: null, imageUrl: null, secret: null },
    states: {
      idle: {
        initial: "initial",
        on: {
          GENERATE: "generating"
        },
        states: {
          initial: {},
          error: {}
        }
      },
      generating: {
        invoke: {
          src: "generate",
          id: "generate",
          onDone: { target: "generated", actions: ["reportGeneratedSuccess", "saveGeneration"] },
          onError: { actions: ["saveError", "reportGeneratedError"], target: "idle.error" }
        }
      },
      generated: {
        initial: "idle",
        states: {
          idle: {
            initial: "idle",
            on: {
              ACTIVATE: [
                {
                  cond: "invalidMfaType",
                  actions: "saveInvalidMfaTypeError",
                  target: ".error"
                },
                {
                  cond: "invalidMfaCode",
                  actions: "saveInvalidMfaCodeError",
                  target: ".error"
                },
                {
                  target: "activating"
                }
              ]
            },
            states: { idle: {}, error: {} }
          },
          activating: {
            invoke: {
              src: "activate",
              id: "activate",
              onDone: { target: "activated", actions: "reportSuccess" },
              onError: { actions: ["saveError", "reportError"], target: "idle.error" }
            }
          },
          activated: { type: "final" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidMfaTypeError: assign({ error: (n2) => he }),
      saveInvalidMfaCodeError: assign({ error: (n2) => me }),
      saveError: assign({
        error: (n2, { data: { error: r2 } }) => r2
      }),
      saveGeneration: assign({
        imageUrl: (n2, { data: { imageUrl: r2 } }) => r2,
        secret: (n2, { data: { totpSecret: r2 } }) => r2
      }),
      reportError: send((n2, r2) => (console.log("REPORT", n2, r2), { type: "ERROR", error: n2.error })),
      reportSuccess: send("SUCCESS"),
      reportGeneratedSuccess: send("GENERATED"),
      reportGeneratedError: send((n2) => ({ type: "GENERATED_ERROR", error: n2.error }))
    },
    guards: {
      invalidMfaCode: (n2, { code: r2 }) => !r2,
      invalidMfaType: (n2, { activeMfaType: r2 }) => !r2 || r2 !== "totp"
    },
    services: {
      generate: async (n2) => {
        const { data: r2 } = await De(
          `${t2}/mfa/totp/generate`,
          e2 == null ? void 0 : e2.getSnapshot().context.accessToken.value
        );
        return r2;
      },
      activate: (n2, { code: r2, activeMfaType: s }) => S(
        `${t2}/user/mfa`,
        { code: r2, activeMfaType: s },
        e2 == null ? void 0 : e2.getSnapshot().context.accessToken.value
      )
    }
  }
);
var Ge = ({ backendUrl: t2, clientUrl: e2 }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "changePassword",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "requestChange",
          id: "requestChange",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: assign({ error: (n2) => A }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (n2, { data: { error: r2 } }) => r2
      }),
      reportError: send((n2) => ({ type: "ERROR", error: n2.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (n2, { email: r2 }) => !I(r2)
    },
    services: {
      requestChange: (n2, { email: r2, options: s }) => S(`${t2}/user/password/reset`, {
        email: r2,
        options: w(e2, s)
      })
    }
  }
);
var Le = ({ backendUrl: t2, clientUrl: e2 }) => createMachine(
  {
    schema: {
      context: {},
      events: {},
      services: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    id: "sendVerificationEmail",
    initial: "idle",
    context: { error: null },
    states: {
      idle: {
        on: {
          REQUEST: [
            {
              cond: "invalidEmail",
              actions: "saveInvalidEmailError",
              target: ".error"
            },
            {
              target: "requesting"
            }
          ]
        },
        initial: "initial",
        states: {
          initial: {},
          success: {},
          error: {}
        }
      },
      requesting: {
        invoke: {
          src: "request",
          id: "request",
          onDone: { target: "idle.success", actions: "reportSuccess" },
          onError: { actions: ["saveRequestError", "reportError"], target: "idle.error" }
        }
      }
    }
  },
  {
    actions: {
      saveInvalidEmailError: assign({ error: (n2) => A }),
      saveRequestError: assign({
        // * Untyped action payload. See https://github.com/statelyai/xstate/issues/3037
        error: (n2, { data: { error: r2 } }) => r2
      }),
      reportError: send((n2) => ({ type: "ERROR", error: n2.error })),
      reportSuccess: send("SUCCESS")
    },
    guards: {
      invalidEmail: (n2, { email: r2 }) => !I(r2)
    },
    services: {
      request: async (n2, { email: r2, options: s }) => (await S(
        `${t2}/user/email/send-verification-email`,
        { email: r2, options: w(e2, s) }
      )).data
    }
  }
);
var ae = class {
  constructor({
    clientStorageType: e2 = "web",
    autoSignIn: n2 = true,
    autoRefreshToken: r2 = true,
    start: s = true,
    backendUrl: i,
    clientUrl: c,
    devTools: d2,
    ...f
  }) {
    if (this._started = false, this._subscriptionsQueue = /* @__PURE__ */ new Set(), this._subscriptions = /* @__PURE__ */ new Set(), this.backendUrl = i, this.clientUrl = c, this._machine = Me({
      ...f,
      backendUrl: i,
      clientUrl: c,
      clientStorageType: e2,
      autoSignIn: n2,
      autoRefreshToken: r2
    }), s && this.start({ devTools: d2 }), typeof window != "undefined" && n2)
      try {
        this._channel = new BroadcastChannel("nhost"), this._channel.addEventListener("message", (h) => {
          var o2;
          const a = (o2 = this.interpreter) == null ? void 0 : o2.getSnapshot().context.refreshToken.value;
          this.interpreter && h.data !== a && this.interpreter.send("TRY_TOKEN", { token: h.data });
        });
      } catch {
      }
  }
  start({
    devTools: e2 = false,
    initialSession: n2,
    interpreter: r2
  } = {}) {
    var c, d2;
    const s = { ...this.machine.context };
    n2 && (s.user = n2.user, s.refreshToken.value = (c = n2.refreshToken) != null ? c : null, s.accessToken.value = (d2 = n2.accessToken) != null ? d2 : null, s.accessToken.expiresAt = new Date(
      Date.now() + n2.accessTokenExpiresIn * 1e3
    ));
    const i = this.machine.withContext(s);
    this._interpreter || (this._interpreter = r2 || interpret(i, { devTools: e2 })), (!this._started || typeof window == "undefined") && (this._interpreter.initialized && (this._interpreter.stop(), this._subscriptions.forEach((f) => f())), this._interpreter.start(i.initialState), this._subscriptionsQueue.forEach((f) => f(this))), this._started = true;
  }
  get machine() {
    return this._machine;
  }
  get interpreter() {
    return this._interpreter;
  }
  get started() {
    return this._started;
  }
  subscribe(e2) {
    if (this.started) {
      const n2 = e2(this);
      return this._subscriptions.add(n2), n2;
    } else
      return this._subscriptionsQueue.add(e2), () => {
        console.log(
          "onTokenChanged was added before the interpreter started. Cannot unsubscribe listener."
        );
      };
  }
};
var $e = class extends ae {
  constructor({
    ...e2
  }) {
    super({
      ...e2,
      autoSignIn: q() && e2.autoSignIn,
      autoRefreshToken: q() && e2.autoRefreshToken,
      clientStorageType: "cookie"
    });
  }
};
var cr = $e;
var qe = async ({ backendUrl: t2, interpreter: e2 }, n2) => {
  try {
    const { data: r2 } = await S(
      `${t2}/user/webauthn/add`,
      {},
      e2 == null ? void 0 : e2.getSnapshot().context.accessToken.value
    );
    let s;
    try {
      s = await te(r2);
    } catch (c) {
      throw new U(c);
    }
    const { data: i } = await S(
      `${t2}/user/webauthn/verify`,
      { credential: s, nickname: n2 },
      e2 == null ? void 0 : e2.getSnapshot().context.accessToken.value
    );
    return { key: i, isError: false, error: null, isSuccess: true };
  } catch (r2) {
    const { error: s } = r2;
    return { isError: true, error: s, isSuccess: false };
  }
};
var We = async (t2, e2, n2) => new Promise((r2) => {
  t2.send("REQUEST", {
    email: e2,
    options: n2
  }), t2.onTransition((s) => {
    s.matches({ idle: "error" }) ? r2({ error: s.context.error, isError: true, needsEmailVerification: false }) : s.matches({ idle: "success" }) && r2({ error: null, isError: false, needsEmailVerification: true });
  });
});
var je = async (t2, e2, n2) => new Promise((r2) => {
  t2.send("REQUEST", {
    password: e2,
    ticket: n2
  }), t2.onTransition((s) => {
    s.matches({ idle: "error" }) ? r2({ error: s.context.error, isError: true, isSuccess: false }) : s.matches({ idle: "success" }) && r2({ error: null, isError: false, isSuccess: true });
  });
});
var ur = (t2) => new Promise((e2) => {
  t2.send("GENERATE"), t2.onTransition((n2) => {
    n2.matches("generated") ? e2({
      error: null,
      isError: false,
      isGenerated: true,
      qrCodeDataUrl: n2.context.imageUrl || ""
    }) : n2.matches({ idle: "error" }) && e2({
      error: n2.context.error || null,
      isError: true,
      isGenerated: false,
      qrCodeDataUrl: ""
    });
  });
});
var lr = (t2, e2) => new Promise((n2) => {
  t2.send("ACTIVATE", {
    activeMfaType: "totp",
    code: e2
  }), t2.onTransition((r2) => {
    r2.matches({ generated: "activated" }) ? n2({ error: null, isActivated: true, isError: false }) : r2.matches({ generated: { idle: "error" } }) && n2({ error: r2.context.error, isActivated: false, isError: true });
  });
});
var He = async (t2, e2, n2) => new Promise((r2) => {
  t2.send("REQUEST", {
    email: e2,
    options: n2
  }), t2.onTransition((s) => {
    s.matches({ idle: "error" }) ? r2({ error: s.context.error, isError: true, isSent: false }) : s.matches({ idle: "success" }) && r2({ error: null, isError: false, isSent: true });
  });
});
var Ye = (t2, e2, n2) => new Promise((r2) => {
  t2.send("REQUEST", {
    email: e2,
    options: n2
  }), t2.onTransition((s) => {
    s.matches({ idle: "error" }) ? r2({ error: s.context.error, isError: true, isSent: false }) : s.matches({ idle: "success" }) && r2({ error: null, isError: false, isSent: true });
  });
});
var Fe = (t2) => new Promise((e2) => {
  const { changed: n2 } = t2.send("SIGNIN_ANONYMOUS");
  n2 || e2({
    isSuccess: false,
    isError: true,
    error: y,
    user: null,
    accessToken: null,
    refreshToken: null
  }), t2.onTransition((r2) => {
    r2.matches({ authentication: "signedIn" }) && e2({
      isSuccess: true,
      isError: false,
      error: null,
      user: r2.context.user,
      accessToken: r2.context.accessToken.value,
      refreshToken: r2.context.refreshToken.value
    }), r2.matches({ authentication: { signedOut: "failed" } }) && e2({
      isSuccess: false,
      isError: true,
      error: r2.context.errors.authentication || null,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  });
});
var ze = (t2, e2, n2) => new Promise((r2) => {
  const { changed: s, context: i } = t2.send("SIGNIN_PASSWORD", {
    email: e2,
    password: n2
  });
  if (!s)
    return r2({
      accessToken: i.accessToken.value,
      refreshToken: i.refreshToken.value,
      error: y,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: i.user
    });
  t2.onTransition((c) => {
    c.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? r2({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      needsMfaOtp: false,
      mfa: null,
      user: null
    }) : c.matches({ authentication: { signedOut: "needsMfa" } }) ? r2({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: true,
      mfa: c.context.mfa,
      user: null
    }) : c.matches({ authentication: { signedOut: "failed" } }) ? r2({
      accessToken: null,
      refreshToken: null,
      error: c.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: null
    }) : c.matches({ authentication: "signedIn" }) && r2({
      accessToken: c.context.accessToken.value,
      refreshToken: c.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      needsMfaOtp: false,
      mfa: null,
      user: c.context.user
    });
  });
});
var Q = (t2, e2, n2) => new Promise((r2) => {
  const { changed: s } = t2.send("PASSWORDLESS_EMAIL", {
    email: e2,
    options: n2
  });
  if (!s)
    return r2({
      error: y,
      isError: true,
      isSuccess: false
    });
  t2.onTransition((i) => {
    i.matches("registration.incomplete.failed") ? r2({
      error: i.context.errors.registration || null,
      isError: true,
      isSuccess: false
    }) : i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) && r2({ error: null, isError: false, isSuccess: true });
  });
});
var Qe = (t2, e2) => new Promise((n2) => {
  const { changed: r2, context: s } = t2.send({ type: "SIGNIN_SECURITY_KEY_EMAIL", email: e2 });
  if (!r2)
    return n2({
      accessToken: s.accessToken.value,
      refreshToken: s.refreshToken.value,
      error: y,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: s.user
    });
  t2.onTransition((i) => {
    i.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? n2({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : i.matches({ authentication: { signedOut: "failed" } }) ? n2({
      accessToken: null,
      refreshToken: null,
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : i.matches({ authentication: "signedIn" }) && n2({
      accessToken: i.context.accessToken.value,
      refreshToken: i.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: i.context.user
    });
  });
});
var Be = (t2, e2, n2) => new Promise((r2) => {
  const { changed: s, context: i } = t2.send("SIGNIN_MFA_TOTP", {
    otp: e2,
    ticket: n2
  });
  if (!s)
    return r2({
      accessToken: i.accessToken.value,
      refreshToken: i.refreshToken.value,
      error: y,
      isError: true,
      isSuccess: false,
      user: i.user
    });
  t2.onTransition((c) => {
    c.matches({ authentication: { signedOut: "failed" } }) ? r2({
      accessToken: null,
      refreshToken: null,
      error: c.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      user: null
    }) : c.matches({ authentication: "signedIn" }) && r2({
      accessToken: c.context.accessToken.value,
      refreshToken: c.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      user: c.context.user
    });
  });
});
var Xe = (t2, e2) => new Promise((n2) => {
  const { changed: r2 } = t2.send("SIGNIN_PAT", { pat: e2 });
  r2 || n2({
    isSuccess: false,
    isError: true,
    error: y,
    user: null,
    accessToken: null,
    refreshToken: null
  }), t2.onTransition((s) => {
    if (s.matches({ authentication: { signedOut: "failed" } }))
      return n2({
        accessToken: null,
        refreshToken: null,
        user: null,
        error: s.context.errors.authentication || null,
        isError: true,
        isSuccess: false
      });
    if (s.matches({ authentication: "signedIn" }))
      return n2({
        accessToken: s.context.accessToken.value,
        refreshToken: s.context.refreshToken.value,
        user: s.context.user,
        error: null,
        isError: false,
        isSuccess: true
      });
  });
});
var B = (t2, e2, n2) => new Promise((r2) => {
  const { changed: s } = t2.send("PASSWORDLESS_SMS", { phoneNumber: e2, options: n2 });
  if (!s)
    return r2({
      error: y,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  t2.onTransition((i) => {
    i.matches("registration.incomplete.needsOtp") ? r2({
      error: null,
      isError: false,
      isSuccess: false,
      needsOtp: true
    }) : i.matches("registration.incomplete.failed") && r2({
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      needsOtp: false
    });
  });
});
var Ze = (t2, e2, n2) => new Promise((r2) => {
  const { changed: s } = t2.send({ type: "PASSWORDLESS_SMS_OTP", phoneNumber: e2, otp: n2 });
  if (!s)
    return r2({
      error: y,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  t2.onTransition((i) => {
    i.matches({ authentication: "signedIn" }) ? r2({
      error: null,
      isError: false,
      isSuccess: true,
      user: i.context.user,
      accessToken: i.context.accessToken.value,
      refreshToken: i.context.refreshToken.value
    }) : i.matches({ registration: { incomplete: "failed" } }) && r2({
      error: i.context.errors.authentication || null,
      isError: true,
      isSuccess: false,
      user: null,
      accessToken: null,
      refreshToken: null
    });
  });
});
var Je = async (t2, e2) => new Promise((n2) => {
  const { event: r2 } = t2.send("SIGNOUT", { all: e2 });
  if (r2.type !== "SIGNED_OUT")
    return n2({ isSuccess: false, isError: true, error: we });
  t2.onTransition((s) => {
    s.matches({ authentication: { signedOut: "success" } }) ? n2({ isSuccess: true, isError: false, error: null }) : s.matches("authentication.signedOut.failed") && n2({ isSuccess: false, isError: true, error: s.context.errors.signout || null });
  });
});
var X = (t2, e2, n2, r2) => new Promise((s) => {
  const { changed: i, context: c } = t2.send("SIGNUP_EMAIL_PASSWORD", {
    email: e2,
    password: n2,
    options: r2
  });
  if (!i)
    return s({
      error: y,
      accessToken: c.accessToken.value,
      refreshToken: c.refreshToken.value,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: c.user
    });
  t2.onTransition((d2) => {
    d2.matches("registration.incomplete.failed") ? s({
      accessToken: null,
      refreshToken: null,
      error: d2.context.errors.registration || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : d2.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? s({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : d2.matches({ authentication: "signedIn", registration: "complete" }) && s({
      accessToken: d2.context.accessToken.value,
      refreshToken: d2.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: d2.context.user
    });
  });
});
var er = (t2, e2, n2) => new Promise((r2) => {
  const { changed: s, context: i } = t2.send("SIGNUP_SECURITY_KEY", {
    email: e2,
    options: n2
  });
  if (!s)
    return r2({
      error: y,
      accessToken: i.accessToken.value,
      refreshToken: i.refreshToken.value,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: i.user
    });
  t2.onTransition((c) => {
    c.matches("registration.incomplete.failed") ? r2({
      accessToken: null,
      refreshToken: null,
      error: c.context.errors.registration || null,
      isError: true,
      isSuccess: false,
      needsEmailVerification: false,
      user: null
    }) : c.matches({
      authentication: { signedOut: "noErrors" },
      registration: { incomplete: "needsEmailVerification" }
    }) ? r2({
      accessToken: null,
      refreshToken: null,
      error: null,
      isError: false,
      isSuccess: false,
      needsEmailVerification: true,
      user: null
    }) : c.matches({ authentication: "signedIn", registration: "complete" }) && r2({
      accessToken: c.context.accessToken.value,
      refreshToken: c.context.refreshToken.value,
      error: null,
      isError: false,
      isSuccess: true,
      needsEmailVerification: false,
      user: c.context.user
    });
  });
});
var rr = async ({ backendUrl: t2, interpreter: e2 }, { expiresAt: n2, metadata: r2 }) => {
  try {
    const { data: s } = await S(
      `${t2}/pat`,
      { expiresAt: n2.toUTCString(), metadata: r2 },
      e2 == null ? void 0 : e2.getSnapshot().context.accessToken.value
    );
    return {
      data: s ? {
        id: s.id || null,
        personalAccessToken: s.personalAccessToken || null
      } : null,
      isError: false,
      error: null,
      isSuccess: true
    };
  } catch (s) {
    const { error: i } = s;
    return { isError: true, error: i, isSuccess: false, data: null };
  }
};
var dr = class {
  constructor({
    url: e2,
    autoRefreshToken: n2 = true,
    autoSignIn: r2 = true,
    clientStorage: s,
    clientStorageType: i,
    refreshIntervalTime: c,
    start: d2 = true
  }) {
    var f;
    this.url = e2, this._client = new ae({
      backendUrl: e2,
      clientUrl: typeof window != "undefined" && ((f = window.location) == null ? void 0 : f.origin) || "",
      autoRefreshToken: n2,
      autoSignIn: r2,
      start: d2,
      clientStorage: s,
      clientStorageType: i,
      refreshIntervalTime: c
    });
  }
  /**
   * Use `nhost.auth.signUp` to sign up a user using email and password. If you want to sign up a user using passwordless email (Magic Link), SMS, or an OAuth provider, use the `signIn` function instead.
   *
   * @example
   * ### Sign up with an email and password
   * ```ts
   * nhost.auth.signUp({
   *   email: 'joe@example.com',
   *   password: 'secret-password'
   * })
   * ```
   *
   * @example
   * ### Sign up with a security key
   * ```ts
   * nhost.auth.signUp({
   *   email: 'joe@example.com',
   *   securityKey: true
   * })
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-up
   */
  async signUp(e2) {
    const n2 = await this.waitUntilReady(), { email: r2, options: s } = e2;
    return "securityKey" in e2 ? v(
      await er(n2, r2, s)
    ) : v(
      await X(n2, r2, e2.password, s)
    );
  }
  /**
   * Use `nhost.auth.signIn` to sign in a user using email and password, passwordless (email or sms) or an external provider. `signIn` can be used to sign in a user in various ways depending on the parameters.
   *
   * @example
   * ### Sign in a user using email and password
   * ```ts
   * nhost.auth.signIn({
   *   email: 'joe@example.com',
   *   password: 'secret-password'
   * })
   * ```
   *
   * @example
   * ### Sign in a user using an OAuth provider (e.g: Google or Facebook)
   * ```ts
   * nhost.auth.signIn({ provider: 'google' })
   * ```
   *
   * @example
   * ### Sign in a user using passwordless email (Magic Link)
   * ```ts
   * nhost.auth.signIn({ email: 'joe@example.com' })
   * ```
   *
   * @example
   * ### Sign in a user using passwordless SMS
   * ```ts
   * // [step 1/2] Passwordless sign in using SMS
   * nhost.auth.signIn({ phoneNumber: '+11233213123' })
   *
   * // [step 2/2] Finish passwordless sign in using SMS (OTP)
   * nhost.auth.signIn({ phoneNumber: '+11233213123', otp: '123456' })
   * ```
   *
   * @example
   * ### Sign in anonymously
   * ```ts
   * // Sign in anonymously
   * nhost.auth.signIn()
   *
   * // Later in the application, the user can complete their registration
   * nhost.auth.signUp({
   *   email: 'joe@example.com',
   *   password: 'secret-password'
   * })
   * ```
   *
   * @example
   * ### Sign in with a security key
   * ```ts
   * nhost.auth.signIn({
   *   email: 'joe@example.com',
   *   securityKey: true
   * })
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in
   */
  async signIn(e2) {
    const n2 = await this.waitUntilReady();
    if (!e2) {
      const r2 = await Fe(n2);
      return { ...v(r2), mfa: null };
    }
    if ("provider" in e2) {
      const { provider: r2, options: s } = e2, i = oe(
        `${this._client.backendUrl}/signin/provider/${r2}`,
        w(this._client.clientUrl, s)
      );
      return q() && (window.location.href = i), { providerUrl: i, provider: r2, session: null, mfa: null, error: null };
    }
    if ("email" in e2 && "password" in e2) {
      const r2 = await ze(n2, e2.email, e2.password);
      return r2.needsEmailVerification ? { session: null, mfa: null, error: ke } : r2.needsMfaOtp ? {
        session: null,
        mfa: r2.mfa,
        error: null
      } : { ...v(r2), mfa: null };
    }
    if ("email" in e2 && "securityKey" in e2) {
      if (e2.securityKey !== true)
        throw Error("securityKey must be true");
      const r2 = await Qe(n2, e2.email);
      return { ...v(r2), mfa: null };
    }
    if ("email" in e2) {
      const { email: r2, options: s } = e2, { error: i } = await Q(n2, r2, s);
      return {
        session: null,
        mfa: null,
        error: i
      };
    }
    if ("phoneNumber" in e2 && "otp" in e2) {
      const r2 = await Ze(n2, e2.phoneNumber, e2.otp);
      return { ...v(r2), mfa: null };
    }
    if ("phoneNumber" in e2) {
      const { error: r2 } = await B(
        n2,
        e2.phoneNumber,
        e2.options
      );
      return { error: r2, mfa: null, session: null };
    }
    if ("otp" in e2) {
      const r2 = await Be(n2, e2.otp, e2.ticket);
      return { ...v(r2), mfa: null };
    }
    return { error: Se, mfa: null, session: null };
  }
  /**
   * Use `nhost.auth.signInPAT` to sign in with a personal access token (PAT).
   *
   * @example
   * ```ts
   * nhost.auth.signInPAT('34f74930-09c0-4af5-a8d5-28fad78e3415')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-in-pat
   *
   * @param personalAccessToken - The personal access token to sign in with
   */
  async signInPAT(e2) {
    const n2 = await this.waitUntilReady(), r2 = await Xe(n2, e2);
    return v(r2);
  }
  /**
   * Use `nhost.auth.signOut` to sign out the user.
   *
   * @example
   * ### Sign out the user from current device
   * ```ts
   * nhost.auth.signOut()
   * ```
   *
   * @example
   * ### Sign out the user from all devices
   * ```ts
   * nhost.auth.signOut({all: true})
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/sign-out
   */
  async signOut(e2) {
    const n2 = await this.waitUntilReady(), { error: r2 } = await Je(n2, e2 == null ? void 0 : e2.all);
    return { error: r2 };
  }
  /**
   * Use `nhost.auth.resetPassword` to reset the password for a user. This will send a reset-password link in an email to the user. When the user clicks the reset-password link the user is automatically signed-in. Once signed-in, the user can change their password using `nhost.auth.changePassword()`.
   *
   * @example
   * ```ts
   * nhost.auth.resetPassword({email: 'joe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/reset-password
   */
  async resetPassword({ email: e2, options: n2 }) {
    const r2 = interpret(Ge(this._client)).start(), { error: s } = await He(r2, e2, n2);
    return { error: s };
  }
  /**
   * Use `nhost.auth.changePassword` to change the password for the signed-in user. The old password is not needed. In case the user is not signed-in, a password reset ticket needs to be provided.
   *
   * @example
   * ```ts
   * nhost.auth.changePassword({ newPassword: 'new-secret-password' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/change-password
   */
  async changePassword({
    newPassword: e2,
    ticket: n2
  }) {
    const r2 = interpret(Ve(this._client)).start(), { error: s } = await je(r2, e2, n2);
    return { error: s };
  }
  /**
   * Use `nhost.auth.sendVerificationEmail` to send a verification email to the specified email. The email contains a verification-email link. When the user clicks the verification-email link their email is verified.
   *
   * @example
   * ```ts
   * nhost.auth.sendVerificationEmail({ email: 'joe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/send-verification-email
   */
  async sendVerificationEmail({
    email: e2,
    options: n2
  }) {
    const r2 = interpret(Le(this._client)).start(), { error: s } = await Ye(r2, e2, n2);
    return { error: s };
  }
  /**
   * Use `nhost.auth.changeEmail` to change a user's email. This will send a confirm-email-change link in an email to the new email. Once the user clicks on the confirm-email-change link the email will be change to the new email.
   *
   * @example
   * ```ts
   * nhost.auth.changeEmail({ newEmail: 'doe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/change-email
   */
  async changeEmail({ newEmail: e2, options: n2 }) {
    const r2 = interpret(Ke(this._client)).start(), { error: s } = await We(r2, e2, n2);
    return { error: s };
  }
  /**
   * Use `nhost.auth.deanonymize` to deanonymize a user.
   *
   * @example
   * ```ts
   * nhost.auth.deanonymize({signInMethod: 'email-password', email: 'joe@example.com' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/deanonymize
   */
  async deanonymize(e2) {
    const n2 = await this.waitUntilReady();
    if (e2.signInMethod === "passwordless") {
      if (e2.connection === "email") {
        const { error: r2 } = await Q(
          n2,
          e2.email,
          e2.options
        );
        return { error: r2 };
      }
      if (e2.connection === "sms") {
        const { error: r2 } = await B(
          n2,
          e2.phoneNumber,
          e2.options
        );
        return { error: r2 };
      }
    }
    if (e2.signInMethod === "email-password") {
      const { error: r2 } = await X(
        n2,
        e2.email,
        e2.password,
        e2.options
      );
      return { error: r2 };
    }
    throw Error("Unknown deanonymization method");
  }
  /**
   * Use `nhost.auth.addSecurityKey to add a security key to the user, using the WebAuthn API.
   * @param nickname optional human-readable nickname for the security key
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/add-security-key
   */
  async addSecurityKey(e2) {
    const { error: n2, key: r2 } = await qe(this._client, e2);
    return { error: n2, key: r2 };
  }
  /**
   * Use `nhost.auth.createPAT` to create a personal access token for the user.
   *
   * @param expiresAt Expiration date for the token
   * @param metadata Optional metadata to store with the token
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/create-pat
   */
  async createPAT(e2, n2) {
    return rr(this._client, { expiresAt: e2, metadata: n2 });
  }
  /**
   * Use `nhost.auth.onTokenChanged` to add a custom function that runs every time the access or refresh token is changed.
   *
   *
   * @example
   * ```ts
   * nhost.auth.onTokenChanged(() => console.log('The access and refresh token has changed'));
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/on-token-changed
   */
  onTokenChanged(e2) {
    return this._client.subscribe(() => {
      var r2;
      const n2 = (r2 = this._client.interpreter) == null ? void 0 : r2.onTransition(({ event: s, context: i }) => {
        s.type === "TOKEN_CHANGED" && e2(x(i));
      });
      return () => n2 == null ? void 0 : n2.stop();
    });
  }
  /**
   * Use `nhost.auth.onAuthStateChanged` to add a custom function that runs every time the authentication status of the user changes. E.g. add a custom function that runs every time the authentication status changes from signed-in to signed-out.
   *
   * @example
   * ```ts
   * nhost.auth.onAuthStateChanged((event, session) => {
   *   console.log(`The auth state has changed. State is now ${event} with session: ${session}`)
   * });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/on-auth-state-changed
   */
  onAuthStateChanged(e2) {
    return this._client.subscribe(() => {
      var r2;
      const n2 = (r2 = this._client.interpreter) == null ? void 0 : r2.onTransition(({ event: s, context: i }) => {
        (s.type === "SIGNED_IN" || s.type === "SIGNED_OUT") && e2(s.type, x(i));
      });
      return () => n2 == null ? void 0 : n2.stop();
    });
  }
  /**
   * Use `nhost.auth.isAuthenticated` to check if the user is authenticated or not.
   *
   * Note: `nhost.auth.isAuthenticated()` can return `false` for two reasons:
   * 1. The user is not authenticated
   * 2. The user is not authenticated but _might_ be authenticated soon (loading) because there is a network request in transit.
   *
   * Use `nhost.auth.getAuthenticationStatus` to get both authentication and loading status.
   *
   * @example
   * ```ts
   * const isAuthenticated = nhost.auth.isAuthenticated();
   *
   * if (isAuthenticated) {
   *   console.log('User is authenticated');
   * }
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated
   */
  isAuthenticated() {
    var e2;
    return !!((e2 = this._client.interpreter) != null && e2.getSnapshot().matches({ authentication: "signedIn" }));
  }
  /**
   * Use `nhost.auth.isAuthenticatedAsync` to wait (await) for any internal authentication network requests to finish and then return the authentication status.
   *
   * The promise won't resolve until the authentication status is known.
   * Attention: when using auto-signin and a refresh token is present in the client storage, the promise won't resolve if the server can't be reached (e.g. offline) or if it returns an internal error.
   *
   * @example
   * ```ts
   * const isAuthenticated  = await nhost.auth.isAuthenticatedAsync();
   *
   * if (isAuthenticated) {
   *   console.log('User is authenticated');
   * }
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/is-authenticated-async
   */
  async isAuthenticatedAsync() {
    return (await this.waitUntilReady()).getSnapshot().matches({ authentication: "signedIn" });
  }
  /**
   * Use `nhost.auth.getAuthenticationStatus` to get the authentication status of the user.
   *
   * If `isLoading` is `true`, the client doesn't know whether the user is authenticated yet or not
   * because some internal authentication network requests have not been resolved yet.
   *
   * The `connectionAttempts` returns the number of times the client has tried to connect to the server with no success (offline, or the server retruned an internal error).
   *
   * @example
   * ```ts
   * const { isAuthenticated, isLoading } = nhost.auth.getAuthenticationStatus();
   *
   * if (isLoading) {
   *   console.log('Loading...')
   * }
   *
   * if (isAuthenticated) {
   *   console.log('User is authenticated');
   * }
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-authentication-status
   */
  getAuthenticationStatus() {
    var n2;
    const e2 = ((n2 = this.client.interpreter) == null ? void 0 : n2.getSnapshot().context.importTokenAttempts) || 0;
    return this.isReady() ? { isAuthenticated: this.isAuthenticated(), isLoading: false, connectionAttempts: e2 } : {
      isAuthenticated: false,
      isLoading: true,
      connectionAttempts: e2
    };
  }
  /**
   * Use `nhost.auth.getAccessToken` to get the access token of the user.
   *
   * @example
   * ```ts
   * const accessToken = nhost.auth.getAccessToken();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-access-token
   */
  getAccessToken() {
    var e2, n2;
    return (n2 = (e2 = this._client.interpreter) == null ? void 0 : e2.getSnapshot().context.accessToken.value) != null ? n2 : void 0;
  }
  /**
   * Use `nhost.auth.getDecodedAccessToken` to get the decoded access token of the user.
   *
   * @example
   * ```ts
   * const decodedAccessToken = nhost.auth.getDecodedAccessToken();
   * ```
   *
   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}
   * @docs https://docs.nhost.io/reference/javascript/auth/get-decoded-access-token
   */
  getDecodedAccessToken() {
    const e2 = this.getAccessToken();
    return e2 ? jwt_decode_esm_default(e2) : null;
  }
  /**
   * Use `nhost.auth.getHasuraClaims` to get the Hasura claims of the user.
   *
   * @example
   * ```ts
   * const hasuraClaims = nhost.auth.getHasuraClaims();
   * ```
   *
   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}
   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claims
   */
  getHasuraClaims() {
    var e2;
    return ((e2 = this.getDecodedAccessToken()) == null ? void 0 : e2["https://hasura.io/jwt/claims"]) || null;
  }
  /**
   * Use `nhost.auth.getHasuraClaim` to get the value of a specific Hasura claim of the user.
   *
   * @example
   * ```ts
   * // if `x-hasura-company-id` exists as a custom claim
   * const companyId = nhost.auth.getHsauraClaim('company-id')
   * ```
   *
   * @param name Name of the variable. You don't have to specify `x-hasura-`.
   *
   * @see {@link https://hasura.io/docs/latest/graphql/core/auth/authentication/jwt/| Hasura documentation}
   * @docs https://docs.nhost.io/reference/javascript/auth/get-hasura-claim
   */
  getHasuraClaim(e2) {
    var n2;
    return ((n2 = this.getHasuraClaims()) == null ? void 0 : n2[e2.startsWith("x-hasura-") ? e2 : `x-hasura-${e2}`]) || null;
  }
  /**
   *
   * Use `nhost.auth.refreshSession` to refresh the session with either the current internal refresh token or an external refresh token.
   *
   * Note: The Nhost client automatically refreshes the session when the user is authenticated but `nhost.auth.refreshSession` can be useful in some special cases.
   *
   * @example
   * ```ts
   * // Refresh the session with the the current internal refresh token.
   * nhost.auth.refreshToken();
   *
   * // Refresh the session with an external refresh token.
   * nhost.auth.refreshToken(refreshToken);
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/refresh-session
   */
  async refreshSession(e2) {
    try {
      const n2 = await this.waitUntilReady();
      return new Promise((r2) => {
        const s = e2 || n2.getSnapshot().context.refreshToken.value;
        if (!s)
          return r2({ session: null, error: Te });
        const { changed: i } = n2.send("TRY_TOKEN", { token: s });
        if (!i)
          return r2({ session: null, error: pe });
        n2.onTransition((c) => {
          c.matches({ token: { idle: "error" } }) ? r2({
            session: null,
            // * TODO get the error from xstate once it is implemented
            error: ye
          }) : c.event.type === "TOKEN_CHANGED" && r2({ session: x(c.context), error: null });
        });
      });
    } catch (n2) {
      return { session: null, error: n2.message };
    }
  }
  /**
   *
   * Use `nhost.auth.getSession()` to get the session of the user.
   *
   * @example
   * ```ts
   * const session = nhost.auth.getSession();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-session
   */
  getSession() {
    var e2, n2;
    return x((n2 = (e2 = this._client.interpreter) == null ? void 0 : e2.getSnapshot()) == null ? void 0 : n2.context);
  }
  /**
   *
   * Use `nhost.auth.getUser()` to get the signed-in user.
   *
   * @example
   * ```ts
   * const user = nhost.auth.getUser();
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/auth/get-user
   */
  getUser() {
    var e2, n2, r2;
    return ((r2 = (n2 = (e2 = this._client.interpreter) == null ? void 0 : e2.getSnapshot()) == null ? void 0 : n2.context) == null ? void 0 : r2.user) || null;
  }
  /**
   * Make sure the state machine is set, and wait for it to be ready
   * @returns
   */
  waitUntilReady() {
    const n2 = this._client.interpreter;
    if (!n2)
      throw Error("Auth interpreter not set");
    return n2.getSnapshot().hasTag("loading") ? new Promise((r2, s) => {
      let i = setTimeout(
        () => s("The state machine is not yet ready after 15 seconds."),
        15e3
      );
      n2.onTransition((c) => {
        if (!c.hasTag("loading"))
          return clearTimeout(i), r2(n2);
      });
    }) : Promise.resolve(n2);
  }
  isReady() {
    var e2, n2;
    return !((n2 = (e2 = this._client.interpreter) == null ? void 0 : e2.getSnapshot()) != null && n2.hasTag("loading"));
  }
  get client() {
    return this._client;
  }
};

// node_modules/@nhost/hasura-storage-js/dist/index.esm.js
var import_fetch_ponyfill2 = __toESM(require_fetch_browser());
var import_form_data = __toESM(require_browser());
var _2 = globalThis.fetch;
var y2 = async (t2, e2, {
  accessToken: r2,
  name: s,
  fileId: o2,
  bucketId: a,
  adminSecret: n2,
  onUploadProgress: d2,
  headers: u2 = {}
} = {}) => {
  var L;
  const p = {
    ...u2
  };
  a && e2.append("bucket-id", a), n2 && (p["x-hasura-admin-secret"] = n2), r2 && (p.Authorization = `Bearer ${r2}`);
  const U3 = `${t2}/files`;
  if (typeof XMLHttpRequest == "undefined")
    try {
      e2 instanceof import_form_data.default && (_2 = (0, import_fetch_ponyfill2.default)().fetch);
      const c = await _2(U3, {
        method: "POST",
        headers: p,
        body: e2
        // * https://github.com/form-data/form-data/issues/513
      }), i = await c.json();
      return c.ok ? { fileMetadata: i, error: null } : { error: {
        status: c.status,
        message: ((L = i == null ? void 0 : i.error) == null ? void 0 : L.message) || c.statusText,
        // * errors from hasura-storage are not codified
        error: c.statusText
      }, fileMetadata: null };
    } catch (c) {
      return { error: {
        status: 0,
        message: c.message,
        error: c.message
      }, fileMetadata: null };
    }
  return new Promise((c) => {
    let i = new XMLHttpRequest();
    i.responseType = "json", i.onload = () => {
      var f, h, T3, S3, w3;
      return i.status < 200 || i.status >= 300 ? c({
        fileMetadata: null,
        error: {
          error: (h = (f = i.response) == null ? void 0 : f.error) != null ? h : i.response,
          message: (w3 = (S3 = (T3 = i.response) == null ? void 0 : T3.error) == null ? void 0 : S3.message) != null ? w3 : i.response,
          status: i.status
        }
      }) : c({ fileMetadata: i.response, error: null });
    }, i.onerror = () => c({
      fileMetadata: null,
      error: { error: i.statusText, message: i.statusText, status: i.status }
    }), d2 && i.upload.addEventListener("progress", d2, false), i.open("POST", U3, true), Object.entries(p).forEach(([f, h]) => {
      i.setRequestHeader(f, h);
    }), i.send(e2);
  });
};
var m;
typeof m == "undefined" && (m = (0, import_fetch_ponyfill2.default)().fetch);
var x2 = class {
  constructor({ url: e2 }) {
    this.url = e2;
  }
  async uploadFormData({
    formData: e2,
    headers: r2,
    bucketId: s
  }) {
    const { error: o2, fileMetadata: a } = await y2(this.url, e2, {
      accessToken: this.accessToken,
      adminSecret: this.adminSecret,
      bucketId: s,
      headers: r2
    });
    return o2 ? { fileMetadata: null, error: o2 } : a && !("processedFiles" in a) ? {
      fileMetadata: {
        processedFiles: [a]
      },
      error: null
    } : { fileMetadata: a, error: null };
  }
  async uploadFile({
    file: e2,
    bucketId: r2,
    id: s,
    name: o2
  }) {
    const a = typeof window == "undefined" ? new import_form_data.default() : new FormData();
    a.append("file[]", e2), a.append("metadata[]", JSON.stringify({ id: s, name: o2 }));
    const { error: n2, fileMetadata: d2 } = await y2(this.url, a, {
      accessToken: this.accessToken,
      adminSecret: this.adminSecret,
      bucketId: r2,
      fileId: s,
      name: o2
    });
    return n2 ? { fileMetadata: null, error: n2 } : d2 && "processedFiles" in d2 ? {
      fileMetadata: d2.processedFiles[0],
      error: null
    } : { fileMetadata: d2, error: null };
  }
  async getPresignedUrl(e2) {
    try {
      const { fileId: r2 } = e2, s = await m(`${this.url}/files/${r2}/presignedurl`, {
        method: "GET",
        headers: this.generateAuthHeaders()
      });
      if (!s.ok)
        throw new Error(await s.text());
      return { presignedUrl: await s.json(), error: null };
    } catch (r2) {
      return { presignedUrl: null, error: r2 };
    }
  }
  async delete(e2) {
    try {
      const { fileId: r2 } = e2, s = await m(`${this.url}/files/${r2}`, {
        method: "DELETE",
        headers: this.generateAuthHeaders()
      });
      if (!s.ok)
        throw new Error(await s.text());
      return { error: null };
    } catch (r2) {
      return { error: r2 };
    }
  }
  /**
   * Set the access token to use for authentication.
   *
   * @param accessToken Access token
   * @returns Hasura Storage API instance
   */
  setAccessToken(e2) {
    return this.accessToken = e2, this;
  }
  /**
   * Set the admin secret to use for authentication.
   *
   * @param adminSecret Hasura admin secret
   * @returns Hasura Storage API instance
   */
  setAdminSecret(e2) {
    return this.adminSecret = e2, this;
  }
  generateAuthHeaders() {
    if (!(!this.adminSecret && !this.accessToken))
      return this.adminSecret ? {
        "x-hasura-admin-secret": this.adminSecret
      } : {
        Authorization: `Bearer ${this.accessToken}`
      };
  }
};
function F2(t2, e2) {
  if (!e2 || Object.keys(e2).length === 0)
    return t2;
  const r2 = new URL(t2), s = Object.entries(e2).reduce(
    (o2, [a, n2]) => ({ ...o2, [a.charAt(0)]: n2 }),
    {}
  );
  return Object.entries(s).forEach(([o2, a]) => {
    a && r2.searchParams.set(o2, a);
  }), r2.toString();
}
var j2 = class {
  constructor({ url: e2, adminSecret: r2 }) {
    this.url = e2, this.api = new x2({ url: e2 }), this.setAdminSecret(r2);
  }
  async upload(e2) {
    return "file" in e2 ? this.api.uploadFile(e2) : this.api.uploadFormData(e2);
  }
  /**
   * Use `nhost.storage.getPublicUrl` to get the public URL of a file. The public URL can be used for un-authenticated users to access files. To access public files the `public` role must have permissions to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const publicUrl = nhost.storage.getPublicUrl({ fileId: '<File-ID>' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-public-url
   */
  getPublicUrl(e2) {
    const { fileId: r2, ...s } = e2;
    return F2(
      `${this.url}/files/${r2}`,
      s
    );
  }
  /**
   * Use `nhost.storage.getPresignedUrl` to get a presigned URL of a file. To get a presigned URL the user must have permission to select the file in the `storage.files` table.
   *
   * @example
   * ```ts
   * const { presignedUrl, error} = await nhost.storage.getPresignedUrl({ fileId: '<File-ID>' })
   *
   * if (error) {
   *   throw error;
   * }
   *
   * console.log('url: ', presignedUrl.url)
   * console.log('expiration: ', presignedUrl.expiration)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/get-presigned-url
   */
  async getPresignedUrl(e2) {
    const { fileId: r2, ...s } = e2, { presignedUrl: o2, error: a } = await this.api.getPresignedUrl(e2);
    if (a)
      return { presignedUrl: null, error: a };
    if (!o2)
      return { presignedUrl: null, error: new Error("Invalid file id") };
    const n2 = F2(
      o2.url,
      s
    );
    return {
      presignedUrl: {
        ...o2,
        url: n2
      },
      error: null
    };
  }
  /**
   * Use `nhost.storage.delete` to delete a file. To delete a file the user must have permissions to delete the file in the `storage.files` table. Deleting the file using `nhost.storage.delete()` will delete both the file and its metadata.
   *
   * @example
   * ```ts
   * const { error } = await nhost.storage.delete({ fileId: 'uuid' })
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/delete
   */
  async delete(e2) {
    const { error: r2 } = await this.api.delete(e2);
    return r2 ? { error: r2 } : { error: null };
  }
  /**
   * Use `nhost.storage.setAccessToken` to a set an access token to be used in subsequent storage requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.storage.setAccessToken('some-access-token')
   * ```
   *
   * @param accessToken Access token
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-access-token
   */
  setAccessToken(e2) {
    return this.api.setAccessToken(e2), this;
  }
  /**
   * Use `nhost.storage.adminSecret` to set the admin secret to be used for subsequent storage requests. This is useful if you want to run storage in "admin mode".
   *
   * @example
   * ```ts
   * nhost.storage.setAdminSecret('some-admin-secret')
   * ```
   *
   * @param adminSecret Hasura admin secret
   *
   * @docs https://docs.nhost.io/reference/javascript/storage/set-admin-secret
   */
  setAdminSecret(e2) {
    return this.api.setAdminSecret(e2), this;
  }
};
var E;
typeof E == "undefined" && (E = import_form_data.default);
var D2 = {
  progress: null,
  loaded: 0,
  error: null,
  bucketId: void 0,
  file: void 0,
  id: void 0
};
var b = () => createMachine(
  {
    predictableActionArguments: true,
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    context: { ...D2 },
    initial: "idle",
    on: {
      DESTROY: { actions: "sendDestroy", target: "stopped" }
    },
    states: {
      idle: {
        on: {
          ADD: { actions: "addFile" },
          UPLOAD: { cond: "hasFile", target: "uploading" }
        }
      },
      uploading: {
        entry: "resetProgress",
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress", "sendProgress"] },
          UPLOAD_DONE: "uploaded",
          UPLOAD_ERROR: "error",
          CANCEL: "idle"
        },
        invoke: { src: "uploadFile" }
      },
      uploaded: {
        entry: ["setFileMetadata", "sendDone"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      error: {
        entry: ["setError", "sendError"],
        on: {
          ADD: { actions: "addFile", target: "idle" },
          UPLOAD: { actions: "resetContext", target: "uploading" }
        }
      },
      stopped: { type: "final" }
    }
  },
  {
    guards: {
      hasFile: (t2, e2) => !!t2.file || !!e2.file
    },
    actions: {
      incrementProgress: assign({
        loaded: (t2, { loaded: e2 }) => e2,
        progress: (t2, { progress: e2 }) => e2
      }),
      setFileMetadata: assign({
        id: (t2, { id: e2 }) => e2,
        bucketId: (t2, { bucketId: e2 }) => e2,
        progress: (t2) => 100
      }),
      setError: assign({ error: (t2, { error: e2 }) => e2 }),
      sendProgress: () => {
      },
      sendError: () => {
      },
      sendDestroy: () => {
      },
      sendDone: () => {
      },
      resetProgress: assign({ progress: (t2) => null, loaded: (t2) => 0 }),
      resetContext: assign((t2) => D2),
      addFile: assign({
        file: (t2, { file: e2 }) => e2,
        bucketId: (t2, { bucketId: e2 }) => e2,
        id: (t2, { id: e2 }) => e2
      })
    },
    services: {
      uploadFile: (t2, e2) => (r2) => {
        const s = e2.file || t2.file, o2 = new E();
        o2.append("file[]", s);
        let a = 0;
        return y2(e2.url, o2, {
          fileId: e2.id || t2.id,
          bucketId: e2.bucketId || t2.bucketId,
          accessToken: e2.accessToken,
          adminSecret: e2.adminSecret,
          name: e2.name || s.name,
          onUploadProgress: (n2) => {
            const d2 = n2.total ? Math.round(n2.loaded * s.size / n2.total) : 0, u2 = d2 - a;
            a = d2, r2({
              type: "UPLOAD_PROGRESS",
              progress: n2.total ? Math.round(d2 * 100 / n2.total) : 0,
              loaded: d2,
              additions: u2
            });
          }
        }).then(({ fileMetadata: n2, error: d2 }) => {
          if (d2 && r2({ type: "UPLOAD_ERROR", error: d2 }), n2 && !("processedFiles" in n2)) {
            const { id: u2, bucketId: p } = n2;
            r2({ type: "UPLOAD_DONE", id: u2, bucketId: p });
          }
          if (n2 && "processedFiles" in n2) {
            const { id: u2, bucketId: p } = n2.processedFiles[0];
            r2({ type: "UPLOAD_DONE", id: u2, bucketId: p });
          }
        }), () => {
        };
      }
    }
  }
);
var { pure: P, sendParent: g2 } = actions_exports;
var H2 = () => createMachine(
  {
    id: "files-list",
    schema: {
      context: {},
      events: {}
    },
    tsTypes: {},
    predictableActionArguments: true,
    context: {
      progress: null,
      files: [],
      loaded: 0,
      total: 0
    },
    initial: "idle",
    on: {
      UPLOAD: { cond: "hasFileToDownload", actions: "addItem", target: "uploading" },
      ADD: { actions: "addItem" },
      REMOVE: { actions: "removeItem" }
    },
    states: {
      idle: {
        entry: ["resetProgress", "resetLoaded", "resetTotal"],
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      uploading: {
        entry: ["upload", "startProgress", "resetLoaded", "resetTotal"],
        on: {
          UPLOAD_PROGRESS: { actions: ["incrementProgress"] },
          UPLOAD_DONE: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          UPLOAD_ERROR: [
            { cond: "isAllUploaded", target: "uploaded" },
            { cond: "isAllUploadedOrError", target: "error" }
          ],
          CANCEL: { actions: "cancel", target: "idle" }
        }
      },
      uploaded: {
        entry: "setUploaded",
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      },
      error: {
        on: {
          CLEAR: { actions: "clearList", target: "idle" }
        }
      }
    }
  },
  {
    guards: {
      hasFileToDownload: (t2, e2) => t2.files.some((r2) => r2.getSnapshot().matches("idle")) || !!e2.files,
      isAllUploaded: (t2) => t2.files.every((e2) => {
        var r2;
        return (r2 = e2.getSnapshot()) == null ? void 0 : r2.matches("uploaded");
      }),
      isAllUploadedOrError: (t2) => t2.files.every((e2) => {
        const r2 = e2.getSnapshot();
        return (r2 == null ? void 0 : r2.matches("error")) || (r2 == null ? void 0 : r2.matches("uploaded"));
      })
    },
    actions: {
      incrementProgress: assign((t2, e2) => {
        const r2 = t2.loaded + e2.additions, s = Math.round(r2 * 100 / t2.total);
        return { ...t2, loaded: r2, progress: s };
      }),
      setUploaded: assign({
        progress: (t2) => 100,
        loaded: ({ files: t2 }) => t2.map((e2) => e2.getSnapshot()).filter((e2) => e2.matches("uploaded")).reduce((e2, r2) => {
          var s;
          return e2 + ((s = r2.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetTotal: assign({
        total: ({ files: t2 }) => t2.map((e2) => e2.getSnapshot()).filter((e2) => !e2.matches("uploaded")).reduce((e2, r2) => {
          var s;
          return e2 + ((s = r2.context.file) == null ? void 0 : s.size);
        }, 0)
      }),
      resetLoaded: assign({ loaded: (t2) => 0 }),
      startProgress: assign({ progress: (t2) => 0 }),
      resetProgress: assign({ progress: (t2) => null }),
      addItem: assign((t2, { files: e2, bucketId: r2 }) => {
        const s = e2 ? Array.isArray(e2) ? e2 : "item" in e2 ? Array.from(e2) : [e2] : [], o2 = t2.total + s.reduce((n2, d2) => n2 + d2.size, 0), a = Math.round(t2.loaded * 100 / o2);
        return {
          files: [
            ...t2.files,
            ...s.map(
              (n2) => spawn(
                b().withConfig({
                  actions: {
                    sendProgress: g2((d2, { additions: u2 }) => ({
                      type: "UPLOAD_PROGRESS",
                      additions: u2
                    })),
                    sendDone: g2("UPLOAD_DONE"),
                    sendError: g2("UPLOAD_ERROR"),
                    sendDestroy: g2("REMOVE")
                  }
                }).withContext({ ...D2, file: n2, bucketId: r2 }),
                { sync: true }
              )
            )
          ],
          total: o2,
          loaded: t2.loaded,
          progress: a
        };
      }),
      removeItem: assign({
        files: (t2) => t2.files.filter((e2) => {
          var s, o2;
          const r2 = (s = e2.getSnapshot()) == null ? void 0 : s.matches("stopped");
          return r2 && ((o2 = e2.stop) == null || o2.call(e2)), !r2;
        })
      }),
      clearList: P(
        (t2) => t2.files.map((e2) => send({ type: "DESTROY" }, { to: e2.id }))
      ),
      upload: P((t2, e2) => t2.files.map((r2) => send(e2, { to: r2.id }))),
      cancel: P(
        (t2) => t2.files.map((e2) => send({ type: "CANCEL" }, { to: e2.id }))
      )
    }
  }
);
var z2 = async (t2, e2) => new Promise((r2) => {
  e2.send({
    type: "UPLOAD",
    ...t2
  }), e2.subscribe((s) => {
    var o2;
    s.matches("error") ? r2({
      error: s.context.error,
      isError: true,
      isUploaded: false
    }) : s.matches("uploaded") && r2({
      error: null,
      isError: false,
      isUploaded: true,
      id: s.context.id,
      bucketId: s.context.id,
      name: (o2 = s.context.file) == null ? void 0 : o2.name
    });
  });
});
var G2 = async (t2, e2) => new Promise((r2) => {
  e2.send({
    type: "UPLOAD",
    ...t2,
    files: t2.files
  }), e2.onTransition((s) => {
    s.matches("error") ? r2({
      errors: s.context.files.filter((o2) => {
        var a;
        return (a = o2.getSnapshot()) == null ? void 0 : a.context.error;
      }),
      isError: true,
      files: []
    }) : s.matches("uploaded") && r2({ errors: [], isError: false, files: s.context.files });
  });
});

// node_modules/@nhost/nhost-js/dist/index.esm.js
var import_isomorphic_unfetch2 = __toESM(require_browser2());

// node_modules/@nhost/graphql-js/dist/index.esm.js
var import_isomorphic_unfetch = __toESM(require_browser2());
function y3(e2, r2, t2) {
  return e2.document ? e2 : {
    document: e2,
    variables: r2,
    config: t2
  };
}
function u(e2) {
  var s;
  let r2;
  const t2 = e2.definitions.filter(
    (a) => a.kind === "OperationDefinition"
  );
  return t2.length === 1 && (r2 = (s = t2[0].name) == null ? void 0 : s.value), r2;
}
function T(e2) {
  if (typeof e2 == "string") {
    let t2;
    try {
      const s = parse(e2);
      t2 = u(s);
    } catch {
    }
    return { query: e2, operationName: t2 };
  }
  const r2 = u(e2);
  return { query: print(e2), operationName: r2 };
}
var q2 = class {
  constructor(r2) {
    const { url: t2, adminSecret: s } = r2;
    this._url = t2, this.accessToken = null, this.adminSecret = s;
  }
  async request(r2, ...t2) {
    const [s, a] = t2, c = y3(r2, s, a), { headers: l, ...h } = a || {}, { query: p, operationName: f } = T(c.document);
    try {
      const o2 = await (0, import_isomorphic_unfetch.default)(this.httpUrl, {
        method: "POST",
        body: JSON.stringify({
          operationName: f,
          query: p,
          variables: s
        }),
        headers: {
          "Content-Type": "application/json",
          ...this.generateAccessTokenHeaders(),
          ...l
        },
        ...h
      });
      if (!o2.ok)
        return {
          data: null,
          error: {
            error: o2.statusText,
            message: o2.statusText,
            status: o2.status
          }
        };
      const { data: n2, errors: i } = await o2.json();
      return i ? {
        data: null,
        error: i
      } : typeof n2 != "object" || Array.isArray(n2) || n2 === null ? {
        data: null,
        error: {
          error: "invalid-response",
          message: "incorrect response data from GraphQL server",
          status: 0
        }
      } : { data: n2, error: null };
    } catch (o2) {
      const n2 = o2;
      return {
        data: null,
        error: {
          message: n2.message,
          status: n2.name === "AbortError" ? 0 : 500,
          error: n2.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  /**
   * Use `nhost.graphql.httpUrl` to get the GraphQL HTTP URL.
   * @example
   * ```ts
   * const url = nhost.graphql.httpUrl;
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/get-http-url
   */
  get httpUrl() {
    return this._url;
  }
  /**
   * Use `nhost.graphql.wsUrl` to get the GraphQL WebSocket URL.
   * @example
   * ```ts
   * const url = nhost.graphql.wsUrl;
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/get-ws-url
   */
  get wsUrl() {
    return this._url.replace(/^(http)(s?):\/\//, "ws$2://");
  }
  /**
   * Use `nhost.graphql.url` to get the GraphQL URL.
   * @deprecated Use `nhost.graphql.httpUrl` and `nhost.graphql.wsUrl` instead.
   */
  get url() {
    return this._url;
  }
  /**
   * Use `nhost.graphql.getUrl()` to get the GraphQL URL.
   * @deprecated Use `nhost.graphql.httpUrl` and `nhost.graphql.wsUrl` instead.
   */
  getUrl() {
    return this._url;
  }
  /**
   * Use `nhost.graphql.setAccessToken` to a set an access token to be used in subsequent graphql requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.graphql.setAccessToken('some-access-token')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/graphql/set-access-token
   */
  setAccessToken(r2) {
    if (!r2) {
      this.accessToken = null;
      return;
    }
    this.accessToken = r2;
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
};

// node_modules/@nhost/nhost-js/dist/index.esm.js
var w2 = /^((?<protocol>http[s]?):\/\/)?(?<host>(localhost|local))(:(?<port>(\d+|__\w+__)))?$/;
function d(e2, t2) {
  const { backendUrl: i, subdomain: o2, region: l } = e2;
  if (i)
    return `${i}/v1/${t2}`;
  if (!o2)
    throw new Error("Either `backendUrl` or `subdomain` must be set.");
  const a = o2.match(w2);
  if (a != null && a.groups) {
    const { protocol: s, host: h, port: r2 } = a.groups, n2 = U2(t2);
    return n2 || (h === "localhost" ? (console.warn(
      'The `subdomain` is set to "localhost". Support for this will be removed in a future release. Please use "local" instead.'
    ), `${s || "http"}://localhost:${r2 || 1337}/v1/${t2}`) : r2 ? `${s || "https"}://local.${t2}.nhost.run:${r2}/v1` : `${s || "https"}://local.${t2}.nhost.run/v1`);
  }
  if (!l)
    throw new Error('`region` must be set when using a `subdomain` other than "local".');
  return `https://${o2}.${t2}.${l}.nhost.run/v1`;
}
function b2() {
  return typeof window != "undefined";
}
function m3() {
  return typeof process != "undefined" && process.env;
}
function U2(e2) {
  return b2() || !m3() ? null : process.env[`NHOST_${e2.toUpperCase()}_URL`];
}
function A2(e2, t2) {
  const o2 = t2.startsWith("/") ? t2 : `/${t2}`;
  return e2 + o2;
}
function S2(e2) {
  const t2 = "subdomain" in e2 || "backendUrl" in e2 ? d(e2, "auth") : e2.authUrl;
  if (!t2)
    throw new Error("Please provide `subdomain` or `authUrl`.");
  return new dr({ url: t2, ...e2 });
}
function $2(e2) {
  const t2 = "subdomain" in e2 || "backendUrl" in e2 ? d(e2, "functions") : e2.functionsUrl;
  if (!t2)
    throw new Error("Please provide `subdomain` or `functionsUrl`.");
  return new v2({ url: t2, ...e2 });
}
var v2 = class {
  constructor(t2) {
    const { url: i, adminSecret: o2 } = t2;
    this.url = i, this.accessToken = null, this.adminSecret = o2;
  }
  /**
   * Use `nhost.functions.call` to call (sending a POST request to) a serverless function. Use generic
   * types to specify the expected response data, request body and error message.
   *
   * @example
   * ### Without generic types
   * ```ts
   * await nhost.functions.call('send-welcome-email', { email: 'joe@example.com', name: 'Joe Doe' })
   * ```
   *
   * @example
   * ### Using generic types
   * ```ts
   * type Data = {
   *   message: string
   * }
   *
   * type Body = {
   *   email: string
   *   name: string
   * }
   *
   * type ErrorMessage = {
   *   details: string
   * }
   *
   * // The function will only accept a body of type `Body`
   * const { res, error } = await nhost.functions.call<Data, Body, ErrorMessage>(
   *   'send-welcome-email',
   *   { email: 'joe@example.com', name: 'Joe Doe' }
   * )
   *
   * // Now the response data is typed as `Data`
   * console.log(res?.data.message)
   *
   * // Now the error message is typed as `ErrorMessage`
   * console.log(error?.message.details)
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/call
   */
  async call(t2, i, o2) {
    var s, h;
    const l = {
      "Content-Type": "application/json",
      ...this.generateAccessTokenHeaders(),
      ...o2 == null ? void 0 : o2.headers
    }, a = A2(this.url, t2);
    try {
      const r2 = await (0, import_isomorphic_unfetch2.default)(a, {
        body: i ? JSON.stringify(i) : null,
        headers: l,
        method: "POST"
      });
      if (!r2.ok) {
        let c;
        return (s = r2.headers.get("content-type")) != null && s.includes("application/json") ? c = await r2.json() : c = await r2.text(), {
          res: null,
          error: {
            message: c,
            error: r2.statusText,
            status: r2.status
          }
        };
      }
      let n2;
      return (h = r2.headers.get("content-type")) != null && h.includes("application/json") ? n2 = await r2.json() : n2 = await r2.text(), {
        res: { data: n2, status: r2.status, statusText: r2.statusText },
        error: null
      };
    } catch (r2) {
      const n2 = r2;
      return {
        res: null,
        error: {
          message: n2.message,
          status: n2.name === "AbortError" ? 0 : 500,
          error: n2.name === "AbortError" ? "abort-error" : "unknown"
        }
      };
    }
  }
  /**
   * Use `nhost.functions.setAccessToken` to a set an access token to be used in subsequent functions requests. Note that if you're signin in users with `nhost.auth.signIn()` the access token will be set automatically.
   *
   * @example
   * ```ts
   * nhost.functions.setAccessToken('some-access-token')
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript/nhost-js/functions/set-access-token
   */
  setAccessToken(t2) {
    if (!t2) {
      this.accessToken = null;
      return;
    }
    this.accessToken = t2;
  }
  generateAccessTokenHeaders() {
    return this.adminSecret ? {
      "x-hasura-admin-secret": this.adminSecret
    } : this.accessToken ? {
      Authorization: `Bearer ${this.accessToken}`
    } : {};
  }
};
function C2(e2) {
  const t2 = "subdomain" in e2 || "backendUrl" in e2 ? d(e2, "graphql") : e2.graphqlUrl;
  if (!t2)
    throw new Error("Please provide `subdomain` or `graphqlUrl`.");
  return new q2({ url: t2, ...e2 });
}
function E2(e2) {
  const t2 = "subdomain" in e2 || "backendUrl" in e2 ? d(e2, "storage") : e2.storageUrl;
  if (!t2)
    throw new Error("Please provide `subdomain` or `storageUrl`.");
  return new j2({ url: t2, ...e2 });
}
var H3 = (e2) => new _3(e2);
var _3 = class {
  /**
   * Nhost Client
   *
   * @example
   * ```ts
   * const nhost = new NhostClient({ subdomain, region });
   * ```
   *
   * @docs https://docs.nhost.io/reference/javascript
   */
  constructor({
    refreshIntervalTime: t2,
    clientStorage: i,
    clientStorageType: o2,
    autoRefreshToken: l,
    autoSignIn: a,
    adminSecret: s,
    devTools: h,
    start: r2 = true,
    ...n2
  }) {
    this.auth = S2({
      refreshIntervalTime: t2,
      clientStorage: i,
      clientStorageType: o2,
      autoRefreshToken: l,
      autoSignIn: a,
      start: r2,
      ...n2
    }), this.storage = E2({ adminSecret: s, ...n2 }), this.functions = $2({ adminSecret: s, ...n2 }), this.graphql = C2({ adminSecret: s, ...n2 }), this.auth.onAuthStateChanged((c, u2) => {
      if (c === "SIGNED_OUT") {
        this.storage.setAccessToken(void 0), this.functions.setAccessToken(void 0), this.graphql.setAccessToken(void 0);
        return;
      }
      const f = u2 == null ? void 0 : u2.accessToken;
      this.storage.setAccessToken(f), this.functions.setAccessToken(f), this.graphql.setAccessToken(f);
    }), this.auth.onTokenChanged((c) => {
      const u2 = c == null ? void 0 : c.accessToken;
      this.storage.setAccessToken(u2), this.functions.setAccessToken(u2), this.graphql.setAccessToken(u2);
    }), this._adminSecret = s, this.devTools = h;
  }
  get adminSecret() {
    return this._adminSecret;
  }
  set adminSecret(t2) {
    this._adminSecret = t2, this.storage.setAdminSecret(t2);
  }
};
export {
  ae as AuthClient,
  cr as AuthClientSSR,
  $e as AuthCookieClient,
  U as CodifiedError,
  ke as EMAIL_NEEDS_VERIFICATION,
  dr as HasuraAuthClient,
  x2 as HasuraStorageApi,
  j2 as HasuraStorageClient,
  D2 as INITIAL_FILE_CONTEXT,
  G as INITIAL_MACHINE_CONTEXT,
  A as INVALID_EMAIL_ERROR,
  me as INVALID_MFA_CODE_ERROR,
  Ee as INVALID_MFA_TICKET_ERROR,
  he as INVALID_MFA_TYPE_ERROR,
  $ as INVALID_PASSWORD_ERROR,
  Y as INVALID_PHONE_NUMBER_ERROR,
  ye as INVALID_REFRESH_TOKEN,
  Se as INVALID_SIGN_IN_METHOD,
  de as MIN_PASSWORD_LENGTH,
  Z as NETWORK_ERROR_CODE,
  R as NHOST_JWT_EXPIRES_AT_KEY,
  N as NHOST_REFRESH_TOKEN_ID_KEY,
  O as NHOST_REFRESH_TOKEN_KEY,
  ge as NO_MFA_TICKET_ERROR,
  Te as NO_REFRESH_TOKEN,
  _3 as NhostClient,
  v2 as NhostFunctionsClient,
  J as OTHER_ERROR_CODE,
  H as REFRESH_TOKEN_MAX_ATTEMPTS,
  C as STATE_ERROR_CODE,
  pe as TOKEN_REFRESHER_RUNNING_ERROR,
  fe as TOKEN_REFRESH_MARGIN_SECONDS,
  y as USER_ALREADY_SIGNED_IN,
  or as USER_NOT_ANONYMOUS,
  we as USER_UNAUTHENTICATED,
  k as VALIDATION_ERROR_CODE,
  lr as activateMfaPromise,
  qe as addSecurityKeyPromise,
  F2 as appendImageTransformationParameters,
  We as changeEmailPromise,
  je as changePasswordPromise,
  S2 as createAuthClient,
  Me as createAuthMachine,
  Ke as createChangeEmailMachine,
  Ve as createChangePasswordMachine,
  ar as createEnableMfaMachine,
  b as createFileUploadMachine,
  $2 as createFunctionsClient,
  C2 as createGraphqlClient,
  H2 as createMultipleFilesUploadMachine,
  H3 as createNhostClient,
  Ge as createResetPasswordMachine,
  Le as createSendVerificationEmailMachine,
  E2 as createStorageClient,
  oe as encodeQueryParameters,
  ur as generateQrCodePromise,
  v as getAuthenticationResult,
  De as getFetch,
  D as getParameterByName,
  x as getSession,
  q as isBrowser,
  I as isValidEmail,
  W as isValidPassword,
  z as isValidPhoneNumber,
  Ue as isValidTicket,
  Ne as localStorageGetter,
  xe as localStorageSetter,
  S as postFetch,
  F as removeParameterFromWindow,
  He as resetPasswordPromise,
  w as rewriteRedirectTo,
  Ye as sendVerificationEmailPromise,
  Fe as signInAnonymousPromise,
  ze as signInEmailPasswordPromise,
  Q as signInEmailPasswordlessPromise,
  Qe as signInEmailSecurityKeyPromise,
  Be as signInMfaTotpPromise,
  Xe as signInPATPromise,
  Ze as signInSmsPasswordlessOtpPromise,
  B as signInSmsPasswordlessPromise,
  Je as signOutPromise,
  X as signUpEmailPasswordPromise,
  er as signUpEmailSecurityKeyPromise,
  z2 as uploadFilePromise,
  G2 as uploadMultipleFilesPromise,
  d as urlFromSubdomain
};
//# sourceMappingURL=@nhost_nhost-js.js.map
